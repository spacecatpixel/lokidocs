{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Loki Network \u00b6 Information is Important \u00b6 Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Loki provides the means to transact and communicate privately and anonymously, using the decentralised nature of blockchain technology to create new methods of interacting with the internet. Loki is a private cryptocurrency based on Monero. Over the course of the coming months, the Loki project aims to offer an incenvised full node layer with a secondary p2p network that offers a private communications layer based on the Tor protocol. More information on the project can be found on the website and in the whitepaper . Loki is an open source project, and we encourage contributions from anyone with something to offer. For more information on contributing, please contact team@loki.network Copyright (c) 2018 The Loki Project. Portions Copyright (c) 2014-2018 The Monero Project. Portions Copyright (c) 2012-2013 The Cryptonote developers. Development resources \u00b6 Web: loki.network Telegram: t.me/LokiCommunity Mail: team@loki.network GitHub: https://github.com/loki-project/loki Discord: https://discord.gg/67GXfD6 Vulnerability disclosure \u00b6 Check out our Vulnerability Response Process , encourages prompt disclosure of any Vulnerabilities","title":"Home"},{"location":"#loki-network","text":"","title":"Loki Network"},{"location":"#information-is-important","text":"Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Loki provides the means to transact and communicate privately and anonymously, using the decentralised nature of blockchain technology to create new methods of interacting with the internet. Loki is a private cryptocurrency based on Monero. Over the course of the coming months, the Loki project aims to offer an incenvised full node layer with a secondary p2p network that offers a private communications layer based on the Tor protocol. More information on the project can be found on the website and in the whitepaper . Loki is an open source project, and we encourage contributions from anyone with something to offer. For more information on contributing, please contact team@loki.network Copyright (c) 2018 The Loki Project. Portions Copyright (c) 2014-2018 The Monero Project. Portions Copyright (c) 2012-2013 The Cryptonote developers.","title":"Information is Important"},{"location":"#development-resources","text":"Web: loki.network Telegram: t.me/LokiCommunity Mail: team@loki.network GitHub: https://github.com/loki-project/loki Discord: https://discord.gg/67GXfD6","title":"Development resources"},{"location":"#vulnerability-disclosure","text":"Check out our Vulnerability Response Process , encourages prompt disclosure of any Vulnerabilities","title":"Vulnerability disclosure"},{"location":"FAQ/","text":"FAQ \u00b6 TO DO","title":"FAQ"},{"location":"FAQ/#faq","text":"TO DO","title":"FAQ"},{"location":"About/Governance/","text":"Governance \u00b6 Governance is an essential part of cryptocurrency design and should be supported at the protocol level. The risk of weak, informally defined governance has been studied extensively throughout the history of blockchain technology. Bitcoin and Ethereum experienced contentious hard forks that split the focus and efforts of their respective communities. Although hard forks can be used as a governance strategy, they should always be considered as a last resort rather than the solution to every contentious issue. The Loki governance system is designed to resolve potential issues by providing a structured environment for discourse and representation, and also to source funding for the development of Loki without reliance on external influence or altruism. Beyond the prevention of hard forks, governance structures should create the means to internally fund new projects which improve upon the Loki ecosystem. Internally funding projects can prevent the formation of special interest groups that do not necessarily have motives that are in line with the users, miners, or Service Nodes. We have seen this in Bitcoin and various Bitcoin forks with the formation of for-profit companies, such as Blockstream, Bitcoin ABC, and Bitcoin Unlimited, that have been frequently accused of hiring developers to make protocol-specific changes to Bitcoin and Bitcoin Cash aimed to further their own business objectives or follow their specific ideology. It is for this reason that in every Loki block, 5% of the reward is allocated for the purpose of network governance. This provides a steady flow of Loki that will be distributed amongst community projects, software developers, and integration teams. Of this 5% block reward, 3.75% is controlled by the Loki Foundation and 1.25% is controlled by the Service Nodes through the Loki Funding System. Which encourages fair representation of the Service Nodes and allows for community funding proposals that can occur outside of the direct control of the Loki Foundation.","title":"Governance"},{"location":"About/Governance/#governance","text":"Governance is an essential part of cryptocurrency design and should be supported at the protocol level. The risk of weak, informally defined governance has been studied extensively throughout the history of blockchain technology. Bitcoin and Ethereum experienced contentious hard forks that split the focus and efforts of their respective communities. Although hard forks can be used as a governance strategy, they should always be considered as a last resort rather than the solution to every contentious issue. The Loki governance system is designed to resolve potential issues by providing a structured environment for discourse and representation, and also to source funding for the development of Loki without reliance on external influence or altruism. Beyond the prevention of hard forks, governance structures should create the means to internally fund new projects which improve upon the Loki ecosystem. Internally funding projects can prevent the formation of special interest groups that do not necessarily have motives that are in line with the users, miners, or Service Nodes. We have seen this in Bitcoin and various Bitcoin forks with the formation of for-profit companies, such as Blockstream, Bitcoin ABC, and Bitcoin Unlimited, that have been frequently accused of hiring developers to make protocol-specific changes to Bitcoin and Bitcoin Cash aimed to further their own business objectives or follow their specific ideology. It is for this reason that in every Loki block, 5% of the reward is allocated for the purpose of network governance. This provides a steady flow of Loki that will be distributed amongst community projects, software developers, and integration teams. Of this 5% block reward, 3.75% is controlled by the Loki Foundation and 1.25% is controlled by the Service Nodes through the Loki Funding System. Which encourages fair representation of the Service Nodes and allows for community funding proposals that can occur outside of the direct control of the Loki Foundation.","title":"Governance"},{"location":"About/LokiFundingSystem/","text":"Loki Funding System \u00b6 Although the Loki Foundation is made from a diverse group of individuals who represent the Loki Project, the Foundation is subject to both its own governing constitution and the laws of Australia. This could prove to be a limiting factor in the range of decisions the Foundation can make. The Loki Funding System allows for a portion of the block reward to be acted on purely by a vote from the Service Nodes . Service Nodes represent entities from all over the world and are not beholden to input from the Loki Project Team or Foundation, this allows them to reach a new level of autonomy in the decisions they can make. Service Nodes are the most staked participants in the network and they are financially incentivised to make decisions that grow the value of Loki. Proposals \u00b6 Every proposal that is put before the Service Nodes is published on the Loki blockchain. If a given party wants to present a proposal to the Service Nodes, the party must construct a proposal transaction. Because the proposal transactions contents must be readable and outputs must be burned, they forgo the privacy features of typical Loki transactions. Funding blocks are created every 43,000 blocks (approximately 60 Days). Proposal leaders can submit their proposals at any time during this period. However, it should be considered that the closer they submit to the beginning of each proposal phase, the more time they have to gain votes from each Service Node. Attached to each transaction is an extra field which contains the information that each Service Node needs to understand to vote on the proposal. This information includes; a 20 proposal title, a URL linking to a detailed explanation of the proposal, the amount of Loki the proposal is seeking, a payment address, and an escrow agent if chosen. Pending agreement from the Loki Foundation , users who make proposals can also elect for the Loki Foundation or any other third-party to act as an escrow agent, releasing funds as milestones are reached. Additionally, to encourage a high-standard of proposals and prevent spamming of these transactions, each proposal transaction must burn a non-trivial amount of Loki. Voting \u00b6 Each Service Nodes carries a specific key for voting. This key can be exported and utilized to vote on behalf of a Service Node without having to login to the server where it is hosted. Voting does not occur on chain, rather, each Service Node signals their support, dissent, or abstinence for each active proposal on the blockchain. Service Nodes can vote on proposals as soon as they are committed to the blockchain until the next bimonthly funding block. Shortly before the creation of the next funding block, a swarm is chosen to collect a tally of all of the votes that have been cast. This tally is then submitted into the nodes mempool and lives there until a miner reaches the funding block. This information is then used to construct the block which allocates a reward to the winning proposals. Proposals are only passed when the result of the yes votes minus the no votes is equal to 15% of the node count on the Service Node network. Funds Distribution \u00b6 All proceeds from the Loki Funding System are paid through funding blocks. Funding block rewards operate similarly to traditional block rewards, as an entirely non-custodial way to distribute Loki. Every 43,000 blocks (approximately 60 Days) a funding block is constructed by miners. This block contains 1.25% of the overall block reward for the entire funding block period. To construct a valid funding block, miners must be able to assess proposals that have reached the required percentage of votes. This is done by using the information that the Service Nodes commit to the blockchain, which contains both the addresses to be paid and the state of all votes. All Service Nodes will validate the miners funding block and discard any funding blocks which pay invalid addresses. Often the sum of Loki required by approved proposals will either exceed or fall below the total amount built up in that 60 day period. Should the total sum of approved proposals exceed that which is available in the funding block, the miner will construct the funding block prioritising proposals that were committed to the blockchain earlier. Remaining approved proposals will remain committed to the blockchain until the next Funding block.","title":"Loki Funding System"},{"location":"About/LokiFundingSystem/#loki-funding-system","text":"Although the Loki Foundation is made from a diverse group of individuals who represent the Loki Project, the Foundation is subject to both its own governing constitution and the laws of Australia. This could prove to be a limiting factor in the range of decisions the Foundation can make. The Loki Funding System allows for a portion of the block reward to be acted on purely by a vote from the Service Nodes . Service Nodes represent entities from all over the world and are not beholden to input from the Loki Project Team or Foundation, this allows them to reach a new level of autonomy in the decisions they can make. Service Nodes are the most staked participants in the network and they are financially incentivised to make decisions that grow the value of Loki.","title":"Loki Funding System"},{"location":"About/LokiFundingSystem/#proposals","text":"Every proposal that is put before the Service Nodes is published on the Loki blockchain. If a given party wants to present a proposal to the Service Nodes, the party must construct a proposal transaction. Because the proposal transactions contents must be readable and outputs must be burned, they forgo the privacy features of typical Loki transactions. Funding blocks are created every 43,000 blocks (approximately 60 Days). Proposal leaders can submit their proposals at any time during this period. However, it should be considered that the closer they submit to the beginning of each proposal phase, the more time they have to gain votes from each Service Node. Attached to each transaction is an extra field which contains the information that each Service Node needs to understand to vote on the proposal. This information includes; a 20 proposal title, a URL linking to a detailed explanation of the proposal, the amount of Loki the proposal is seeking, a payment address, and an escrow agent if chosen. Pending agreement from the Loki Foundation , users who make proposals can also elect for the Loki Foundation or any other third-party to act as an escrow agent, releasing funds as milestones are reached. Additionally, to encourage a high-standard of proposals and prevent spamming of these transactions, each proposal transaction must burn a non-trivial amount of Loki.","title":"Proposals"},{"location":"About/LokiFundingSystem/#voting","text":"Each Service Nodes carries a specific key for voting. This key can be exported and utilized to vote on behalf of a Service Node without having to login to the server where it is hosted. Voting does not occur on chain, rather, each Service Node signals their support, dissent, or abstinence for each active proposal on the blockchain. Service Nodes can vote on proposals as soon as they are committed to the blockchain until the next bimonthly funding block. Shortly before the creation of the next funding block, a swarm is chosen to collect a tally of all of the votes that have been cast. This tally is then submitted into the nodes mempool and lives there until a miner reaches the funding block. This information is then used to construct the block which allocates a reward to the winning proposals. Proposals are only passed when the result of the yes votes minus the no votes is equal to 15% of the node count on the Service Node network.","title":"Voting"},{"location":"About/LokiFundingSystem/#funds-distribution","text":"All proceeds from the Loki Funding System are paid through funding blocks. Funding block rewards operate similarly to traditional block rewards, as an entirely non-custodial way to distribute Loki. Every 43,000 blocks (approximately 60 Days) a funding block is constructed by miners. This block contains 1.25% of the overall block reward for the entire funding block period. To construct a valid funding block, miners must be able to assess proposals that have reached the required percentage of votes. This is done by using the information that the Service Nodes commit to the blockchain, which contains both the addresses to be paid and the state of all votes. All Service Nodes will validate the miners funding block and discard any funding blocks which pay invalid addresses. Often the sum of Loki required by approved proposals will either exceed or fall below the total amount built up in that 60 day period. Should the total sum of approved proposals exceed that which is available in the funding block, the miner will construct the funding block prioritising proposals that were committed to the blockchain earlier. Remaining approved proposals will remain committed to the blockchain until the next Funding block.","title":"Funds Distribution"},{"location":"About/TheLokiFoundation/","text":"The Loki Foundation \u00b6 The Loki Foundation is a registered non-profit organisation based in Australia. This central legal entity exists to allow the Loki Project to operate within a well defined legal framework and to give those working on the project legal protections and obligations. The Loki Foundation was incorporated in Australia, in 2018, and uses the same constitution as the example provided by the Australian Charities and Not-for-profits Commission (ACNC) . This constitution gives the Foundation the same corporate governance structure as many other non-profit organisations, where the company has no shareholders or beneficiaries, the governing board members each have seats with term limits, and conduct actions by voting on resolutions put forward by their fellow members. The Loki Foundation is structured to achieve registered charity status in Australia. This organisation is constitutionally bound to spend any income (including the governance block reward) on the furthering of the project and aligned initiatives. As an externally audited organisation, transparency is critical to maintaining any registered charity status the Loki Foundation receives, and to assure the general public that the Loki Foundation remains honest and keeps spending within reasonable bounds. The Loki Foundation is accountable both to the community and its auditors. Should this system ultimately fail to serve Loki and its surrounding projects, hard protections exist. Should a hard for with enough network consensus arise, there exists an opportunity to remove or replace the Loki Foundation as the recipient of this block reward .","title":"The Loki Foundation"},{"location":"About/TheLokiFoundation/#the-loki-foundation","text":"The Loki Foundation is a registered non-profit organisation based in Australia. This central legal entity exists to allow the Loki Project to operate within a well defined legal framework and to give those working on the project legal protections and obligations. The Loki Foundation was incorporated in Australia, in 2018, and uses the same constitution as the example provided by the Australian Charities and Not-for-profits Commission (ACNC) . This constitution gives the Foundation the same corporate governance structure as many other non-profit organisations, where the company has no shareholders or beneficiaries, the governing board members each have seats with term limits, and conduct actions by voting on resolutions put forward by their fellow members. The Loki Foundation is structured to achieve registered charity status in Australia. This organisation is constitutionally bound to spend any income (including the governance block reward) on the furthering of the project and aligned initiatives. As an externally audited organisation, transparency is critical to maintaining any registered charity status the Loki Foundation receives, and to assure the general public that the Loki Foundation remains honest and keeps spending within reasonable bounds. The Loki Foundation is accountable both to the community and its auditors. Should this system ultimately fail to serve Loki and its surrounding projects, hard protections exist. Should a hard for with enough network consensus arise, there exists an opportunity to remove or replace the Loki Foundation as the recipient of this block reward .","title":"The Loki Foundation"},{"location":"Advanced/CompilingGuide/","text":"Compiling Loki from source \u00b6 Dependencies \u00b6 The following table summarizes the tools and libraries required to build. A few of the libraries are also included in this repository (marked as \"Vendored\"). By default, the build uses the library installed on the system, and ignores the vendored sources. However, if no library is found installed on the system, then the vendored source will be built and used. The vendored sources are also used for statically-linked builds because distribution packages often include only shared library binaries ( .so ) but not static library archives ( .a ). Dep Min. version Vendored Debian/Ubuntu pkg Arch pkg Optional Purpose GCC 4.7.3 NO build-essential base-devel NO CMake 3.0.0 NO cmake cmake NO pkg-config any NO pkg-config base-devel NO Boost 1.58 NO libboost-all-dev boost NO C++ libraries OpenSSL basically any NO libssl-dev openssl NO sha256 sum libzmq 3.0.0 NO libzmq3-dev zeromq NO ZeroMQ library libunbound 1.4.16 YES libunbound-dev unbound NO DNS resolver libsodium ? NO libsodium-dev ? NO libsodium libminiupnpc 2.0 YES libminiupnpc-dev miniupnpc YES NAT punching libunwind any NO libunwind8-dev libunwind YES Stack traces liblzma any NO liblzma-dev xz YES For libunwind libreadline 6.3.0 NO libreadline6-dev readline YES Input editing ldns 1.6.17 NO libldns-dev ldns YES SSL toolkit expat 1.1 NO libexpat1-dev expat YES XML parsing GTest 1.5 YES libgtest-dev ^ gtest YES Test suite Doxygen any NO doxygen doxygen YES Documentation Graphviz any NO graphviz graphviz YES Documentation [^] On Debian/Ubuntu libgtest-dev only includes sources and headers. You must build the library binary manually. This can be done with the following command sudo apt-get install libgtest-dev && cd /usr/src/gtest && sudo cmake . && sudo make && sudo mv libg* /usr/lib/ Cloning the repository \u00b6 Clone recursively to pull-in needed submodule(s): $ git clone --recursive https://github.com/loki-project/loki If you already have a repo cloned, initialize and update: $ cd loki && git submodule init && git submodule update Build instructions \u00b6 Loki uses the CMake build system and a top-level Makefile that invokes cmake commands as needed. On Linux and OS X \u00b6 Install the dependencies Change to the root of the source code directory and build: cd loki make Optional : If your machine has several cores and enough memory, enable parallel build by running make -j<number of threads> instead of make . For this to be worthwhile, the machine should have one core and about 2GB of RAM available per thread. Note : If cmake can not find zmq.hpp file on OS X, installing zmq.hpp from https://github.com/zeromq/cppzmq to /usr/local/include should fix that error. The resulting executables can be found in build/release/bin Add PATH=\"$PATH:$HOME/loki/build/release/bin\" to .profile Run Loki with lokid --detach Optional : build and run the test suite to verify the binaries: make release-test NOTE : core_tests test may take a few hours to complete. Optional : to build binaries suitable for debugging: make debug Optional : to build statically-linked binaries: make release-static Dependencies need to be built with -fPIC. Static libraries usually aren't, so you may have to build them yourself with -fPIC. Refer to their documentation for how to build them. Optional : build documentation in doc/html (omit HAVE_DOT=YES if graphviz is not installed): HAVE_DOT=YES doxygen Doxyfile On the Raspberry Pi \u00b6 Tested on a Raspberry Pi Zero with a clean install of minimal Raspbian Stretch (2017-09-07 or later) from https://www.raspberrypi.org/downloads/raspbian/. If you are using Raspian Jessie, please see note in the following section . apt-get update && apt-get upgrade to install all of the latest software Install the dependencies for Loki from the 'Debian' column in the table above. Increase the system swap size: sudo /etc/init.d/dphys-swapfile stop sudo nano /etc/dphys-swapfile CONF_SWAPSIZE=1024 sudo /etc/init.d/dphys-swapfile start Clone loki and checkout most recent release version: git clone https://github.com/loki-project/loki.git cd loki git checkout tags/v0.11.0.0 Build: make release Wait 4-6 hours The resulting executables can be found in build/release/bin Add PATH=\"$PATH:$HOME/loki/build/release/bin\" to .profile Run Loki with lokid --detach You may wish to reduce the size of the swap file after the build has finished, and delete the boost directory from your home directory Note for Raspbian Jessie users: \u00b6 If you are using the older Raspbian Jessie image, compiling Loki is a bit more complicated. The version of Boost available in the Debian Jessie repositories is too old to use with Loki, and thus you must compile a newer version yourself. The following explains the extra steps, and has been tested on a Raspberry Pi 2 with a clean install of minimal Raspbian Jessie. As before, apt-get update && apt-get upgrade to install all of the latest software, and increase the system swap size sudo /etc/init.d/dphys-swapfile stop sudo nano /etc/dphys-swapfile CONF_SWAPSIZE=1024 sudo /etc/init.d/dphys-swapfile start Then, install the dependencies for Loki except libunwind and libboost-all-dev Install the latest version of boost (this may first require invoking apt-get remove --purge libboost* to remove a previous version if you're not using a clean install): cd wget https://sourceforge.net/projects/boost/files/boost/1.64.0/boost_1_64_0.tar.bz2 tar xvfo boost_1_64_0.tar.bz2 cd boost_1_64_0 ./bootstrap.sh sudo ./b2 Wait ~8 hours sudo ./bjam install Wait ~4 hours From here, follow the general Raspberry Pi instructions from the \"Clone loki and checkout most recent release version\" step. On Windows: \u00b6 Binaries for Windows are built on Windows using the MinGW toolchain within MSYS2 environment . The MSYS2 environment emulates a POSIX system. The toolchain runs within the environment and cross-compiles binaries that can run outside of the environment as a regular Windows application. Preparing the build environment Download and install the MSYS2 installer , either the 64-bit or the 32-bit package, depending on your system. Open the MSYS shell via the MSYS2 Shell shortcut Update packages using pacman: pacman -Syuu Exit the MSYS shell using Alt+F4 Edit the properties for the MSYS2 Shell shortcut changing \"msys2_shell.bat\" to \"msys2_shell.cmd -mingw64\" for 64-bit builds or \"msys2_shell.cmd -mingw32\" for 32-bit builds Restart MSYS shell via modified shortcut and update packages again using pacman: pacman -Syuu Install dependencies: To build for 64-bit Windows: pacman -S mingw-w64-x86_64-toolchain make mingw-w64-x86_64-cmake mingw-w64-x86_64-boost mingw-w64-x86_64-openssl mingw-w64-x86_64-zeromq mingw-w64-x86_64-libsodium To build for 32-bit Windows: pacman -S mingw-w64-i686-toolchain make mingw-w64-i686-cmake mingw-w64-i686-boost mingw-w64-i686-openssl mingw-w64-i686-zeromq mingw-w64-i686-libsodium Open the MingW shell via MinGW-w64-Win64 Shell shortcut on 64-bit Windows or MinGW-w64-Win64 Shell shortcut on 32-bit Windows. Note that if you are running 64-bit Windows, you will have both 64-bit and 32-bit MinGW shells. Building If you are on a 64-bit system, run: make release-static-win64 If you are on a 32-bit system, run: make release-static-win32 The resulting executables can be found in build/release/bin On FreeBSD: \u00b6 The project can be built from scratch by following instructions for Linux above. If you are running loki in a jail you need to add the flag: allow.sysvipc=1 to your jail configuration, otherwise lmdb will throw the error message: Failed to open lmdb environment: Function not implemented . On OpenBSD: \u00b6 OpenBSD < 6.2 \u00b6 This has been tested on OpenBSD 5.8. You will need to add a few packages to your system. pkg_add db cmake gcc gcc-libs g++ miniupnpc gtest . The doxygen and graphviz packages are optional and require the xbase set. The Boost package has a bug that will prevent librpc.a from building correctly. In order to fix this, you will have to Build boost yourself from scratch. Follow the directions here (under \"Building Boost\"): https://github.com/bitcoin/bitcoin/blob/master/doc/build-openbsd.md You will have to add the serialization, date_time, and regex modules to Boost when building as they are needed by Loki. To build: env CC=egcc CXX=eg++ CPP=ecpp DEVELOPER_LOCAL_TOOLS=1 BOOST_ROOT=/path/to/the/boost/you/built make release-static-64 OpenBSD >= 6.2 \u00b6 You will need to add a few packages to your system. pkg_add cmake miniupnpc zeromq libiconv . The doxygen and graphviz packages are optional and require the xbase set. Build the Boost library using clang. This guide is derived from: https://github.com/bitcoin/bitcoin/blob/master/doc/build-openbsd.md We assume you are compiling with a non-root user and you have doas enabled. Note: do not use the boost package provided by OpenBSD, as we are installing boost to /usr/local . # Create boost building directory mkdir ~/boost cd ~/boost # Fetch boost source ftp -o boost_1_64_0.tar.bz2 https://netcologne.dl.sourceforge.net/project/boost/boost/1.64.0/boost_1_64_0.tar.bz2 # MUST output: (SHA256) boost_1_64_0.tar.bz2: OK echo \"7bcc5caace97baa948931d712ea5f37038dbb1c5d89b43ad4def4ed7cb683332 boost_1_64_0.tar.bz2\" | sha256 -c tar xfj boost_1_64_0.tar.bz2 # Fetch and apply boost patches, required for OpenBSD ftp -o boost_test_impl_execution_monitor_ipp.patch https://raw.githubusercontent.com/openbsd/ports/bee9e6df517077a7269ff0dfd57995f5c6a10379/devel/boost/patches/patch-boost_test_impl_execution_monitor_ipp ftp -o boost_config_platform_bsd_hpp.patch https://raw.githubusercontent.com/openbsd/ports/90658284fb786f5a60dd9d6e8d14500c167bdaa0/devel/boost/patches/patch-boost_config_platform_bsd_hpp # MUST output: (SHA256) boost_config_platform_bsd_hpp.patch: OK echo \"1f5e59d1154f16ee1e0cc169395f30d5e7d22a5bd9f86358f738b0ccaea5e51d boost_config_platform_bsd_hpp.patch\" | sha256 -c # MUST output: (SHA256) boost_test_impl_execution_monitor_ipp.patch: OK echo \"30cec182a1437d40c3e0bd9a866ab5ddc1400a56185b7e671bb3782634ed0206 boost_test_impl_execution_monitor_ipp.patch\" | sha256 -c cd boost_1_64_0 patch -p0 < ../boost_test_impl_execution_monitor_ipp.patch patch -p0 < ../boost_config_platform_bsd_hpp.patch # Start building boost echo 'using clang : : c++ : <cxxflags>\"-fvisibility=hidden -fPIC\" <linkflags>\"\" <archiver>\"ar\" <striper>\"strip\" <ranlib>\"ranlib\" <rc>\"\" : ;' > user-config.jam ./bootstrap.sh --without-icu --with-libraries=chrono,filesystem,program_options,system,thread,test,date_time,regex,serialization,locale --with-toolset=clang ./b2 toolset=clang cxxflags=\"-stdlib=libc++\" linkflags=\"-stdlib=libc++\" -sICONV_PATH=/usr/local doas ./b2 -d0 runtime-link=shared threadapi=pthread threading=multi link=static variant=release --layout=tagged --build-type=complete --user-config=user-config.jam -sNO_BZIP2=1 -sICONV_PATH=/usr/local --prefix=/usr/local install Build cppzmq Build the cppzmq bindings. We assume you are compiling with a non-root user and you have doas enabled. # Create cppzmq building directory mkdir ~/cppzmq cd ~/cppzmq # Fetch cppzmq source ftp -o cppzmq-4.2.3.tar.gz https://github.com/zeromq/cppzmq/archive/v4.2.3.tar.gz # MUST output: (SHA256) cppzmq-4.2.3.tar.gz: OK echo \"3e6b57bf49115f4ae893b1ff7848ead7267013087dc7be1ab27636a97144d373 cppzmq-4.2.3.tar.gz\" | sha256 -c tar xfz cppzmq-4.2.3.tar.gz # Start building cppzmq cd cppzmq-4.2.3 mkdir build cd build cmake .. doas make install Build loki: env DEVELOPER_LOCAL_TOOLS=1 BOOST_ROOT=/usr/local make release-static On Solaris: \u00b6 The default Solaris linker can't be used, you have to install GNU ld, then run cmake manually with the path to your copy of GNU ld: mkdir -p build/release cd build/release cmake -DCMAKE_LINKER=/path/to/ld -D CMAKE_BUILD_TYPE=Release ../.. cd ../.. Then you can run make as usual. On Linux for Android (using docker): \u00b6 # Build image (select android64.Dockerfile for aarch64) cd utils/build_scripts/ &amp;&amp; docker build -f android32.Dockerfile -t loki-android . # Create container docker create -it --name loki-android loki-android bash # Get binaries docker cp loki-android:/opt/android/loki/build/release/bin . Building portable statically linked binaries \u00b6 By default, in either dynamically or statically linked builds, binaries target the specific host processor on which the build happens and are not portable to other processors. Portable binaries can be built using the following targets: make release-static-linux-x86_64 builds binaries on Linux on x86_64 portable across POSIX systems on x86_64 processors make release-static-linux-i686 builds binaries on Linux on x86_64 or i686 portable across POSIX systems on i686 processors make release-static-linux-armv8 builds binaries on Linux portable across POSIX systems on armv8 processors make release-static-linux-armv7 builds binaries on Linux portable across POSIX systems on armv7 processors make release-static-linux-armv6 builds binaries on Linux portable across POSIX systems on armv6 processors make release-static-win64 builds binaries on 64-bit Windows portable across 64-bit Windows systems make release-static-win32 builds binaries on 64-bit or 32-bit Windows portable across 32-bit Windows systems Running lokid \u00b6 The build places the binary in bin/ sub-directory within the build directory from which cmake was invoked (repository root by default). To run in foreground: ./bin/lokid To list all available options, run ./bin/lokid --help . Options can be specified either on the command line or in a configuration file passed by the --config-file argument. To specify an option in the configuration file, add a line with the syntax argumentname=value , where argumentname is the name of the argument without the leading dashes, for example log-level=1 . To run in background: ./bin/lokid --log-file lokid.log --detach Internationalization \u00b6 See Internationalization .","title":"Compiling Loki from source"},{"location":"Advanced/CompilingGuide/#compiling-loki-from-source","text":"","title":"Compiling Loki from source"},{"location":"Advanced/CompilingGuide/#dependencies","text":"The following table summarizes the tools and libraries required to build. A few of the libraries are also included in this repository (marked as \"Vendored\"). By default, the build uses the library installed on the system, and ignores the vendored sources. However, if no library is found installed on the system, then the vendored source will be built and used. The vendored sources are also used for statically-linked builds because distribution packages often include only shared library binaries ( .so ) but not static library archives ( .a ). Dep Min. version Vendored Debian/Ubuntu pkg Arch pkg Optional Purpose GCC 4.7.3 NO build-essential base-devel NO CMake 3.0.0 NO cmake cmake NO pkg-config any NO pkg-config base-devel NO Boost 1.58 NO libboost-all-dev boost NO C++ libraries OpenSSL basically any NO libssl-dev openssl NO sha256 sum libzmq 3.0.0 NO libzmq3-dev zeromq NO ZeroMQ library libunbound 1.4.16 YES libunbound-dev unbound NO DNS resolver libsodium ? NO libsodium-dev ? NO libsodium libminiupnpc 2.0 YES libminiupnpc-dev miniupnpc YES NAT punching libunwind any NO libunwind8-dev libunwind YES Stack traces liblzma any NO liblzma-dev xz YES For libunwind libreadline 6.3.0 NO libreadline6-dev readline YES Input editing ldns 1.6.17 NO libldns-dev ldns YES SSL toolkit expat 1.1 NO libexpat1-dev expat YES XML parsing GTest 1.5 YES libgtest-dev ^ gtest YES Test suite Doxygen any NO doxygen doxygen YES Documentation Graphviz any NO graphviz graphviz YES Documentation [^] On Debian/Ubuntu libgtest-dev only includes sources and headers. You must build the library binary manually. This can be done with the following command sudo apt-get install libgtest-dev && cd /usr/src/gtest && sudo cmake . && sudo make && sudo mv libg* /usr/lib/","title":"Dependencies"},{"location":"Advanced/CompilingGuide/#cloning-the-repository","text":"Clone recursively to pull-in needed submodule(s): $ git clone --recursive https://github.com/loki-project/loki If you already have a repo cloned, initialize and update: $ cd loki && git submodule init && git submodule update","title":"Cloning the repository"},{"location":"Advanced/CompilingGuide/#build-instructions","text":"Loki uses the CMake build system and a top-level Makefile that invokes cmake commands as needed.","title":"Build instructions"},{"location":"Advanced/CompilingGuide/#on-linux-and-os-x","text":"Install the dependencies Change to the root of the source code directory and build: cd loki make Optional : If your machine has several cores and enough memory, enable parallel build by running make -j<number of threads> instead of make . For this to be worthwhile, the machine should have one core and about 2GB of RAM available per thread. Note : If cmake can not find zmq.hpp file on OS X, installing zmq.hpp from https://github.com/zeromq/cppzmq to /usr/local/include should fix that error. The resulting executables can be found in build/release/bin Add PATH=\"$PATH:$HOME/loki/build/release/bin\" to .profile Run Loki with lokid --detach Optional : build and run the test suite to verify the binaries: make release-test NOTE : core_tests test may take a few hours to complete. Optional : to build binaries suitable for debugging: make debug Optional : to build statically-linked binaries: make release-static Dependencies need to be built with -fPIC. Static libraries usually aren't, so you may have to build them yourself with -fPIC. Refer to their documentation for how to build them. Optional : build documentation in doc/html (omit HAVE_DOT=YES if graphviz is not installed): HAVE_DOT=YES doxygen Doxyfile","title":"On Linux and OS X"},{"location":"Advanced/CompilingGuide/#on-the-raspberry-pi","text":"Tested on a Raspberry Pi Zero with a clean install of minimal Raspbian Stretch (2017-09-07 or later) from https://www.raspberrypi.org/downloads/raspbian/. If you are using Raspian Jessie, please see note in the following section . apt-get update && apt-get upgrade to install all of the latest software Install the dependencies for Loki from the 'Debian' column in the table above. Increase the system swap size: sudo /etc/init.d/dphys-swapfile stop sudo nano /etc/dphys-swapfile CONF_SWAPSIZE=1024 sudo /etc/init.d/dphys-swapfile start Clone loki and checkout most recent release version: git clone https://github.com/loki-project/loki.git cd loki git checkout tags/v0.11.0.0 Build: make release Wait 4-6 hours The resulting executables can be found in build/release/bin Add PATH=\"$PATH:$HOME/loki/build/release/bin\" to .profile Run Loki with lokid --detach You may wish to reduce the size of the swap file after the build has finished, and delete the boost directory from your home directory","title":"On the Raspberry Pi"},{"location":"Advanced/CompilingGuide/#note-for-raspbian-jessie-users","text":"If you are using the older Raspbian Jessie image, compiling Loki is a bit more complicated. The version of Boost available in the Debian Jessie repositories is too old to use with Loki, and thus you must compile a newer version yourself. The following explains the extra steps, and has been tested on a Raspberry Pi 2 with a clean install of minimal Raspbian Jessie. As before, apt-get update && apt-get upgrade to install all of the latest software, and increase the system swap size sudo /etc/init.d/dphys-swapfile stop sudo nano /etc/dphys-swapfile CONF_SWAPSIZE=1024 sudo /etc/init.d/dphys-swapfile start Then, install the dependencies for Loki except libunwind and libboost-all-dev Install the latest version of boost (this may first require invoking apt-get remove --purge libboost* to remove a previous version if you're not using a clean install): cd wget https://sourceforge.net/projects/boost/files/boost/1.64.0/boost_1_64_0.tar.bz2 tar xvfo boost_1_64_0.tar.bz2 cd boost_1_64_0 ./bootstrap.sh sudo ./b2 Wait ~8 hours sudo ./bjam install Wait ~4 hours From here, follow the general Raspberry Pi instructions from the \"Clone loki and checkout most recent release version\" step.","title":"Note for Raspbian Jessie users:"},{"location":"Advanced/CompilingGuide/#on-windows","text":"Binaries for Windows are built on Windows using the MinGW toolchain within MSYS2 environment . The MSYS2 environment emulates a POSIX system. The toolchain runs within the environment and cross-compiles binaries that can run outside of the environment as a regular Windows application. Preparing the build environment Download and install the MSYS2 installer , either the 64-bit or the 32-bit package, depending on your system. Open the MSYS shell via the MSYS2 Shell shortcut Update packages using pacman: pacman -Syuu Exit the MSYS shell using Alt+F4 Edit the properties for the MSYS2 Shell shortcut changing \"msys2_shell.bat\" to \"msys2_shell.cmd -mingw64\" for 64-bit builds or \"msys2_shell.cmd -mingw32\" for 32-bit builds Restart MSYS shell via modified shortcut and update packages again using pacman: pacman -Syuu Install dependencies: To build for 64-bit Windows: pacman -S mingw-w64-x86_64-toolchain make mingw-w64-x86_64-cmake mingw-w64-x86_64-boost mingw-w64-x86_64-openssl mingw-w64-x86_64-zeromq mingw-w64-x86_64-libsodium To build for 32-bit Windows: pacman -S mingw-w64-i686-toolchain make mingw-w64-i686-cmake mingw-w64-i686-boost mingw-w64-i686-openssl mingw-w64-i686-zeromq mingw-w64-i686-libsodium Open the MingW shell via MinGW-w64-Win64 Shell shortcut on 64-bit Windows or MinGW-w64-Win64 Shell shortcut on 32-bit Windows. Note that if you are running 64-bit Windows, you will have both 64-bit and 32-bit MinGW shells. Building If you are on a 64-bit system, run: make release-static-win64 If you are on a 32-bit system, run: make release-static-win32 The resulting executables can be found in build/release/bin","title":"On Windows:"},{"location":"Advanced/CompilingGuide/#on-freebsd","text":"The project can be built from scratch by following instructions for Linux above. If you are running loki in a jail you need to add the flag: allow.sysvipc=1 to your jail configuration, otherwise lmdb will throw the error message: Failed to open lmdb environment: Function not implemented .","title":"On FreeBSD:"},{"location":"Advanced/CompilingGuide/#on-openbsd","text":"","title":"On OpenBSD:"},{"location":"Advanced/CompilingGuide/#openbsd-62","text":"This has been tested on OpenBSD 5.8. You will need to add a few packages to your system. pkg_add db cmake gcc gcc-libs g++ miniupnpc gtest . The doxygen and graphviz packages are optional and require the xbase set. The Boost package has a bug that will prevent librpc.a from building correctly. In order to fix this, you will have to Build boost yourself from scratch. Follow the directions here (under \"Building Boost\"): https://github.com/bitcoin/bitcoin/blob/master/doc/build-openbsd.md You will have to add the serialization, date_time, and regex modules to Boost when building as they are needed by Loki. To build: env CC=egcc CXX=eg++ CPP=ecpp DEVELOPER_LOCAL_TOOLS=1 BOOST_ROOT=/path/to/the/boost/you/built make release-static-64","title":"OpenBSD &lt; 6.2"},{"location":"Advanced/CompilingGuide/#openbsd-62_1","text":"You will need to add a few packages to your system. pkg_add cmake miniupnpc zeromq libiconv . The doxygen and graphviz packages are optional and require the xbase set. Build the Boost library using clang. This guide is derived from: https://github.com/bitcoin/bitcoin/blob/master/doc/build-openbsd.md We assume you are compiling with a non-root user and you have doas enabled. Note: do not use the boost package provided by OpenBSD, as we are installing boost to /usr/local . # Create boost building directory mkdir ~/boost cd ~/boost # Fetch boost source ftp -o boost_1_64_0.tar.bz2 https://netcologne.dl.sourceforge.net/project/boost/boost/1.64.0/boost_1_64_0.tar.bz2 # MUST output: (SHA256) boost_1_64_0.tar.bz2: OK echo \"7bcc5caace97baa948931d712ea5f37038dbb1c5d89b43ad4def4ed7cb683332 boost_1_64_0.tar.bz2\" | sha256 -c tar xfj boost_1_64_0.tar.bz2 # Fetch and apply boost patches, required for OpenBSD ftp -o boost_test_impl_execution_monitor_ipp.patch https://raw.githubusercontent.com/openbsd/ports/bee9e6df517077a7269ff0dfd57995f5c6a10379/devel/boost/patches/patch-boost_test_impl_execution_monitor_ipp ftp -o boost_config_platform_bsd_hpp.patch https://raw.githubusercontent.com/openbsd/ports/90658284fb786f5a60dd9d6e8d14500c167bdaa0/devel/boost/patches/patch-boost_config_platform_bsd_hpp # MUST output: (SHA256) boost_config_platform_bsd_hpp.patch: OK echo \"1f5e59d1154f16ee1e0cc169395f30d5e7d22a5bd9f86358f738b0ccaea5e51d boost_config_platform_bsd_hpp.patch\" | sha256 -c # MUST output: (SHA256) boost_test_impl_execution_monitor_ipp.patch: OK echo \"30cec182a1437d40c3e0bd9a866ab5ddc1400a56185b7e671bb3782634ed0206 boost_test_impl_execution_monitor_ipp.patch\" | sha256 -c cd boost_1_64_0 patch -p0 < ../boost_test_impl_execution_monitor_ipp.patch patch -p0 < ../boost_config_platform_bsd_hpp.patch # Start building boost echo 'using clang : : c++ : <cxxflags>\"-fvisibility=hidden -fPIC\" <linkflags>\"\" <archiver>\"ar\" <striper>\"strip\" <ranlib>\"ranlib\" <rc>\"\" : ;' > user-config.jam ./bootstrap.sh --without-icu --with-libraries=chrono,filesystem,program_options,system,thread,test,date_time,regex,serialization,locale --with-toolset=clang ./b2 toolset=clang cxxflags=\"-stdlib=libc++\" linkflags=\"-stdlib=libc++\" -sICONV_PATH=/usr/local doas ./b2 -d0 runtime-link=shared threadapi=pthread threading=multi link=static variant=release --layout=tagged --build-type=complete --user-config=user-config.jam -sNO_BZIP2=1 -sICONV_PATH=/usr/local --prefix=/usr/local install Build cppzmq Build the cppzmq bindings. We assume you are compiling with a non-root user and you have doas enabled. # Create cppzmq building directory mkdir ~/cppzmq cd ~/cppzmq # Fetch cppzmq source ftp -o cppzmq-4.2.3.tar.gz https://github.com/zeromq/cppzmq/archive/v4.2.3.tar.gz # MUST output: (SHA256) cppzmq-4.2.3.tar.gz: OK echo \"3e6b57bf49115f4ae893b1ff7848ead7267013087dc7be1ab27636a97144d373 cppzmq-4.2.3.tar.gz\" | sha256 -c tar xfz cppzmq-4.2.3.tar.gz # Start building cppzmq cd cppzmq-4.2.3 mkdir build cd build cmake .. doas make install Build loki: env DEVELOPER_LOCAL_TOOLS=1 BOOST_ROOT=/usr/local make release-static","title":"OpenBSD &gt;= 6.2"},{"location":"Advanced/CompilingGuide/#on-solaris","text":"The default Solaris linker can't be used, you have to install GNU ld, then run cmake manually with the path to your copy of GNU ld: mkdir -p build/release cd build/release cmake -DCMAKE_LINKER=/path/to/ld -D CMAKE_BUILD_TYPE=Release ../.. cd ../.. Then you can run make as usual.","title":"On Solaris:"},{"location":"Advanced/CompilingGuide/#on-linux-for-android-using-docker","text":"# Build image (select android64.Dockerfile for aarch64) cd utils/build_scripts/ &amp;&amp; docker build -f android32.Dockerfile -t loki-android . # Create container docker create -it --name loki-android loki-android bash # Get binaries docker cp loki-android:/opt/android/loki/build/release/bin .","title":"On Linux for Android (using docker):"},{"location":"Advanced/CompilingGuide/#building-portable-statically-linked-binaries","text":"By default, in either dynamically or statically linked builds, binaries target the specific host processor on which the build happens and are not portable to other processors. Portable binaries can be built using the following targets: make release-static-linux-x86_64 builds binaries on Linux on x86_64 portable across POSIX systems on x86_64 processors make release-static-linux-i686 builds binaries on Linux on x86_64 or i686 portable across POSIX systems on i686 processors make release-static-linux-armv8 builds binaries on Linux portable across POSIX systems on armv8 processors make release-static-linux-armv7 builds binaries on Linux portable across POSIX systems on armv7 processors make release-static-linux-armv6 builds binaries on Linux portable across POSIX systems on armv6 processors make release-static-win64 builds binaries on 64-bit Windows portable across 64-bit Windows systems make release-static-win32 builds binaries on 64-bit or 32-bit Windows portable across 32-bit Windows systems","title":"Building portable statically linked binaries"},{"location":"Advanced/CompilingGuide/#running-lokid","text":"The build places the binary in bin/ sub-directory within the build directory from which cmake was invoked (repository root by default). To run in foreground: ./bin/lokid To list all available options, run ./bin/lokid --help . Options can be specified either on the command line or in a configuration file passed by the --config-file argument. To specify an option in the configuration file, add a line with the syntax argumentname=value , where argumentname is the name of the argument without the leading dashes, for example log-level=1 . To run in background: ./bin/lokid --log-file lokid.log --detach","title":"Running lokid"},{"location":"Advanced/CompilingGuide/#internationalization","text":"See Internationalization .","title":"Internationalization"},{"location":"Advanced/Debugging/","text":"Debugging \u00b6 This section contains general instructions for debugging failed installs or problems encountered with Loki. First ensure you are running the latest version built from the Github repo. Obtaining stack traces and core dumps on Unix systems \u00b6 We generally use the tool gdb (GNU debugger) to provide stack trace functionality, and ulimit to provide core dumps in builds which crash or segfault. To use gdb in order to obtain a stack trace for a build that has stalled: Run the build. Once it stalls, enter the following command: gdb /path/to/lokid `pidof lokid` Type thread apply all bt within gdb in order to obtain the stack trace If however the core dumps or segfaults: Enter ulimit -c unlimited on the command line to enable unlimited filesizes for core dumps Enter echo core | sudo tee /proc/sys/kernel/core_pattern to stop cores from being hijacked by other tools Run the build. When it terminates with an output along the lines of \"Segmentation fault (core dumped)\", there should be a core dump file in the same directory as lokid. It may be named just core , or core.xxxx with numbers appended. You can now analyse this core dump with gdb as follows: gdb /path/to/lokid /path/to/dumpfile Print the stack trace with bt To run loki within gdb: Type gdb /path/to/lokid Pass command-line options with --args followed by the relevant arguments Type run to run lokid Analysing memory corruption \u00b6 We use the tool valgrind for this. Run with valgrind /path/to/lokid . It will be slow. LMDB \u00b6 Instructions for debugging suspected blockchain corruption as per @HYC There is an mdb_stat command in the LMDB source that can print statistics about the database but it's not routinely built. This can be built with the following command: cd ~/loki/external/db_drivers/liblmdb && make The output of mdb_stat -ea <path to blockchain dir> will indicate inconsistencies in the blocks, block_heights and block_info table. The output of mdb_dump -s blocks <path to blockchain dir> and mdb_dump -s block_info <path to blockchain dir> is useful for indicating whether blocks and block_info contain the same keys. These records are dumped as hex data, where the first line is the key and the second line is the data.","title":"Debugging"},{"location":"Advanced/Debugging/#debugging","text":"This section contains general instructions for debugging failed installs or problems encountered with Loki. First ensure you are running the latest version built from the Github repo.","title":"Debugging"},{"location":"Advanced/Debugging/#obtaining-stack-traces-and-core-dumps-on-unix-systems","text":"We generally use the tool gdb (GNU debugger) to provide stack trace functionality, and ulimit to provide core dumps in builds which crash or segfault. To use gdb in order to obtain a stack trace for a build that has stalled: Run the build. Once it stalls, enter the following command: gdb /path/to/lokid `pidof lokid` Type thread apply all bt within gdb in order to obtain the stack trace If however the core dumps or segfaults: Enter ulimit -c unlimited on the command line to enable unlimited filesizes for core dumps Enter echo core | sudo tee /proc/sys/kernel/core_pattern to stop cores from being hijacked by other tools Run the build. When it terminates with an output along the lines of \"Segmentation fault (core dumped)\", there should be a core dump file in the same directory as lokid. It may be named just core , or core.xxxx with numbers appended. You can now analyse this core dump with gdb as follows: gdb /path/to/lokid /path/to/dumpfile Print the stack trace with bt To run loki within gdb: Type gdb /path/to/lokid Pass command-line options with --args followed by the relevant arguments Type run to run lokid","title":"Obtaining stack traces and core dumps on Unix systems"},{"location":"Advanced/Debugging/#analysing-memory-corruption","text":"We use the tool valgrind for this. Run with valgrind /path/to/lokid . It will be slow.","title":"Analysing memory corruption"},{"location":"Advanced/Debugging/#lmdb","text":"Instructions for debugging suspected blockchain corruption as per @HYC There is an mdb_stat command in the LMDB source that can print statistics about the database but it's not routinely built. This can be built with the following command: cd ~/loki/external/db_drivers/liblmdb && make The output of mdb_stat -ea <path to blockchain dir> will indicate inconsistencies in the blocks, block_heights and block_info table. The output of mdb_dump -s blocks <path to blockchain dir> and mdb_dump -s block_info <path to blockchain dir> is useful for indicating whether blocks and block_info contain the same keys. These records are dumped as hex data, where the first line is the key and the second line is the data.","title":"LMDB"},{"location":"Advanced/DenialofServiceAttacks/","text":"Denial of Service Attacks \u00b6 Users of decentralised blockchains are not required to provide digital or physical identifiers. This can be beneficial to users who lack identity or are being persecuted because of it. However, systems that do not require identification render themselves vulnerable to Sybil attacks , where a malicious actor produces numerous false identities (in Loki\u2019s case, numerous public-private key pairs) and uses these identities to spam the network with requests. Many cryptocurrencies have struggled with this problem, and are forced to implement either a fee-for-service model or a proof-of-work model. In fee-for-service models such as Siacoin, users pay for the services that they use. In Siacoins case, the cost is determined per TB of storage per month. Fee-for-service models are effective at reducing Sybil attacks, however, they drive many users away from the system especially when similar services are available for free (such as Google Drive and Onedrive in the case of Siacoin). Proof-of-work systems such as those used in Hashcash and Nano require users to calculate a small proof-of-work before sending a message or transaction. These small proof-of-work systems are arguably more egalitarian than the fee-for-service model but can fall prey to attackers who possess large amounts of computing power. Loki proposes a modified proof-of-work scheme to address the two largest Sybil attack surfaces in the Loki system; offline messages and path creation. Offline messages present a potential target because each message must be stored by a swarm of nine nodes. Potential abuse could arise where a malicious user overloads a particular swarm with a high volume of 15 messages that it would have to store. In path creation attacks, the attacker seeks to engage in the path creation process with as many nodes as possible, taking up bandwidth resources and denying service to users who create paths through the network for legitimate purposes. To prevent both attacks, the Loki network requires that a short proof-of-work be attached when both messages and paths are created. For messages, this proof-of-work is calculated as a Blake2b hash of the message. For path creation, the proof-of-work is sent along with the request for a node to be included in the path building process. To ensure scalability and accessibility for mobile users, the proof-of-work difficulty requirement is fixed based on the Time-to-live (TTL) of the message or the path, and not based on global network activity.","title":"Denial of Service Attacks"},{"location":"Advanced/DenialofServiceAttacks/#denial-of-service-attacks","text":"Users of decentralised blockchains are not required to provide digital or physical identifiers. This can be beneficial to users who lack identity or are being persecuted because of it. However, systems that do not require identification render themselves vulnerable to Sybil attacks , where a malicious actor produces numerous false identities (in Loki\u2019s case, numerous public-private key pairs) and uses these identities to spam the network with requests. Many cryptocurrencies have struggled with this problem, and are forced to implement either a fee-for-service model or a proof-of-work model. In fee-for-service models such as Siacoin, users pay for the services that they use. In Siacoins case, the cost is determined per TB of storage per month. Fee-for-service models are effective at reducing Sybil attacks, however, they drive many users away from the system especially when similar services are available for free (such as Google Drive and Onedrive in the case of Siacoin). Proof-of-work systems such as those used in Hashcash and Nano require users to calculate a small proof-of-work before sending a message or transaction. These small proof-of-work systems are arguably more egalitarian than the fee-for-service model but can fall prey to attackers who possess large amounts of computing power. Loki proposes a modified proof-of-work scheme to address the two largest Sybil attack surfaces in the Loki system; offline messages and path creation. Offline messages present a potential target because each message must be stored by a swarm of nine nodes. Potential abuse could arise where a malicious user overloads a particular swarm with a high volume of 15 messages that it would have to store. In path creation attacks, the attacker seeks to engage in the path creation process with as many nodes as possible, taking up bandwidth resources and denying service to users who create paths through the network for legitimate purposes. To prevent both attacks, the Loki network requires that a short proof-of-work be attached when both messages and paths are created. For messages, this proof-of-work is calculated as a Blake2b hash of the message. For path creation, the proof-of-work is sent along with the request for a node to be included in the path building process. To ensure scalability and accessibility for mobile users, the proof-of-work difficulty requirement is fixed based on the Time-to-live (TTL) of the message or the path, and not based on global network activity.","title":"Denial of Service Attacks"},{"location":"Advanced/DynamicBlockSize/","text":"Dynamic Block Size \u00b6 Like other CryptoNote coins, Loki does not have a fixed block size. Instead, the block size changes over time, growing to include more transactions as the network reaches higher transaction throughput. The Loki block size scales by observing the median block size over the last 100 blocks and slowly retargets the maximum size of any new blocks accordingly. The long-term concern in other cryptocurrencies is that large block sizes burden the nodes that store and verify transactions. As block sizes grow, nodes that run on lower grade hardware are unable to process and propagate new blocks, leading to centralisation of the node network among those with a commercial interest in maintaining nodes. This can be concerning because distributing the blockchain across many nodes allows for the state of the chain to be confirmed among many different parties, adding to its validity and censorship resistance. In Loki, a portion of the block reward is given to Service Nodes that process and propagate blocks as full nodes. Because Service Nodes with insufficient bandwidth and performance are dropped from the Service Node network, the reward pool self-enforces a minimum performance requirement. This incentive structure not only ensures that the node count remains high, but that the said nodes are of a sufficient performance level to successfully share blockchain data across the network, irrespective of how large the blockchain grows or how demanding the bandwidth requirements are. Even so, transaction size optimisations are still required to ensure that the network scales efficiently so as to keep the Service Node operating costs down so that a high node count can be sustained in the long term.","title":"Dynamic Block Size"},{"location":"Advanced/DynamicBlockSize/#dynamic-block-size","text":"Like other CryptoNote coins, Loki does not have a fixed block size. Instead, the block size changes over time, growing to include more transactions as the network reaches higher transaction throughput. The Loki block size scales by observing the median block size over the last 100 blocks and slowly retargets the maximum size of any new blocks accordingly. The long-term concern in other cryptocurrencies is that large block sizes burden the nodes that store and verify transactions. As block sizes grow, nodes that run on lower grade hardware are unable to process and propagate new blocks, leading to centralisation of the node network among those with a commercial interest in maintaining nodes. This can be concerning because distributing the blockchain across many nodes allows for the state of the chain to be confirmed among many different parties, adding to its validity and censorship resistance. In Loki, a portion of the block reward is given to Service Nodes that process and propagate blocks as full nodes. Because Service Nodes with insufficient bandwidth and performance are dropped from the Service Node network, the reward pool self-enforces a minimum performance requirement. This incentive structure not only ensures that the node count remains high, but that the said nodes are of a sufficient performance level to successfully share blockchain data across the network, irrespective of how large the blockchain grows or how demanding the bandwidth requirements are. Even so, transaction size optimisations are still required to ensure that the network scales efficiently so as to keep the Service Node operating costs down so that a high node count can be sustained in the long term.","title":"Dynamic Block Size"},{"location":"Advanced/EmissionCurve/","text":"Emission Curve \u00b6 Loki is a Blockchain network oriented toward the provision of privacy-preserving services over a network of Service Nodes. The salient cryptoeconomic problem is how to incentivise actors in the Loki network to operate Service Nodes in a manner compatible with the objectives of the Loki network, in particular decentralisation and privacy. To solve this problem the Loki Project team commissioned two Economic papers: Cryptoeconomics of the Loki Network : This Economic Report was commissioned to characterise the game theory behind incentivising Service Node operators. Loki Cryptoeconomics : This Report was commissioned to apply the game theory specific to the Loki Networks economics. Block Reward \u00b6 As a result of this study, on the 30th of July, 2018, at block 64324, the Loki block reward went from being calculated in terms of the circulating supply with an emission speed factor of 20(link to Monero stuff), to be derived from the block height. The formula used to calculate the block reward BR where h is the block height is: Block Reward Split \u00b6 As Service Node's went live on 20th of September, 2018, at block 101250, the addition of a Block Reward split was required to financially incentive the Service Node Operators to maintain and run a Service Node. During the fork on the 30th of July, 2018, the Block Reward was hard coded to split the reward as follows: Party Percent of Reward Service Nodes 50% Miners 45% Governance 5%","title":"Emission Curve"},{"location":"Advanced/EmissionCurve/#emission-curve","text":"Loki is a Blockchain network oriented toward the provision of privacy-preserving services over a network of Service Nodes. The salient cryptoeconomic problem is how to incentivise actors in the Loki network to operate Service Nodes in a manner compatible with the objectives of the Loki network, in particular decentralisation and privacy. To solve this problem the Loki Project team commissioned two Economic papers: Cryptoeconomics of the Loki Network : This Economic Report was commissioned to characterise the game theory behind incentivising Service Node operators. Loki Cryptoeconomics : This Report was commissioned to apply the game theory specific to the Loki Networks economics.","title":"Emission Curve"},{"location":"Advanced/EmissionCurve/#block-reward","text":"As a result of this study, on the 30th of July, 2018, at block 64324, the Loki block reward went from being calculated in terms of the circulating supply with an emission speed factor of 20(link to Monero stuff), to be derived from the block height. The formula used to calculate the block reward BR where h is the block height is:","title":"Block Reward"},{"location":"Advanced/EmissionCurve/#block-reward-split","text":"As Service Node's went live on 20th of September, 2018, at block 101250, the addition of a Block Reward split was required to financially incentive the Service Node Operators to maintain and run a Service Node. During the fork on the 30th of July, 2018, the Block Reward was hard coded to split the reward as follows: Party Percent of Reward Service Nodes 50% Miners 45% Governance 5%","title":"Block Reward Split"},{"location":"Advanced/IPandPacketBlocking/","text":"IP and Packet Blocking \u00b6 Although the Service Node network has no central points of failure, two significant censorship threats face the network; namely harvesting attacks and deep packet inspection . Harvesting attacks would seek to gather the IP addresses of all operating Service Nodes on the network and use ISP level firewalls to block connections to those particular addresses. This type of censorship is regularly performed on the Tor network in China . Deep packet inspection (DPI), aims to investigate the structuring of each individual packet that passes through a firewall, and selectively drop or block packets that appear to relate to a particular service. Again, DPI has been used extensively by state-level actors. Much work has been done to design systems which evade DPI. Users can leverage types of pluggable transports which alter the signature of each packet aiming to appear as normal unblocked traffic. IP blocking is generally avoided by running domain fronting bridges which will encrypt traffic as HTTPS requests to unblocked services like Azure or Cloudflare. Once they reach the unblocked service, the bridge will forward the request to the desired location. In the case of domain fronting, it becomes difficult for a state level actor to prevent the flow of all traffic to popular bridges without causing significant disruption to the general usage of the internet. Governance mechanisms built into Loki can be used to operate domain fronting bridges so that users can access Loki services in countries where large-scale internet censorship policies are at play. Additionally, OBFS4 pluggable transport support will be bundled with the Service Node release of the Loki wallet to help further protect against DPI.","title":"IP and Packet Blocking"},{"location":"Advanced/IPandPacketBlocking/#ip-and-packet-blocking","text":"Although the Service Node network has no central points of failure, two significant censorship threats face the network; namely harvesting attacks and deep packet inspection . Harvesting attacks would seek to gather the IP addresses of all operating Service Nodes on the network and use ISP level firewalls to block connections to those particular addresses. This type of censorship is regularly performed on the Tor network in China . Deep packet inspection (DPI), aims to investigate the structuring of each individual packet that passes through a firewall, and selectively drop or block packets that appear to relate to a particular service. Again, DPI has been used extensively by state-level actors. Much work has been done to design systems which evade DPI. Users can leverage types of pluggable transports which alter the signature of each packet aiming to appear as normal unblocked traffic. IP blocking is generally avoided by running domain fronting bridges which will encrypt traffic as HTTPS requests to unblocked services like Azure or Cloudflare. Once they reach the unblocked service, the bridge will forward the request to the desired location. In the case of domain fronting, it becomes difficult for a state level actor to prevent the flow of all traffic to popular bridges without causing significant disruption to the general usage of the internet. Governance mechanisms built into Loki can be used to operate domain fronting bridges so that users can access Loki services in countries where large-scale internet censorship policies are at play. Additionally, OBFS4 pluggable transport support will be bundled with the Service Node release of the Loki wallet to help further protect against DPI.","title":"IP and Packet Blocking"},{"location":"Advanced/RingSignature/","text":"Ring Signature \u00b6 Ring signatures are used to hide real outputs amongst others in any given transaction. Ring Signature Size \u00b6 The size of a ring signature refers to how many mixins are used to construct the ring. Monero currently has an enforced minimum ring signature size of seven, with six mixins used alongside the real unspent output in a transaction. The effect of larger ring-sizes has been sparsely studied, however, in paper 0001 (published by the Monero Research Lab), the effect of differing ring-sizes was analysed versus an attacker who owned a large number of outputs on the blockchain . It was found that higher ring-sizes reduce the timeframe in which a malicious attacker who owned a large number of unspent outputs would be able to perform effective analysis of transactions. Mandating larger ring-sizes also protects against a theoretical attack known as an EABE/Knacc attack , where a third-party (i.e. an exchange) can perform limited temporal analysis on transactions between two users. Additionally, Monero has no maximum ring-size enforced by network consensus rules. Many wallets like the Monero GUI wallet cap the ring-size at 26. However, a user is free to manually create a transaction with whatever ring-size they wish, as long as it is above a ring-size of seven. This is problematic since most wallets have a default ring-size of seven. Increasing a transactions ring-size above seven makes it stand out. Further, if an individuals transactions were to always use a non-standard ring-size in Monero (ten for example), a passive third-party could analyse the blockchain and infer patterns using temporal analysis. transaction hash ring size tx size[kB] 3feaff3f48de0bc4c92ec027236165337b64df404aca098e212c1215e9456697 7 13.47 39d484f7c0a2e8f3823a514056d7cb0bf269171cb4582e05955d4c5ee995cad0 7 13.47 e08f5a937e725011bedd44075334ae98dcca32749da231c56da1278d49c0a231 7 13.50 ab35e69d9cca39219c90df8b2b7aab4a54c82127fb1fbaae65d76357f8f76387 7 13.5 6d8ccd56dc2d3eb7de03ba767f0dbf4d5f42ae91e67f4c28f16d6f8b0229c272 10 13.87 Loki Static Ring Size \u00b6 Loki improves on both of these problems by statically enforcing ring-sizes, and setting the ring-size to ten. Statically setting the maximum ring-size protects users who construct rings with more than nine mixins and setting the ring-size minimum to ten more effectively prevents an attacker who owns a large number of outputs from discerning the true outputs spent in a ring signature. Larger ring-sizes also increase the default churning effectiveness non-linearly, becoming more effective as ring-sizes grow. In the current transaction scheme, increasing the ring-size to 10 would lead to a 2.6% increase in the size of the transaction. However, when Bulletproofs are implemented it will account for about a 8 - 13% increase in the size of a transaction. This is because of the overall reduction in transaction size caused by Bulletproofs. Increasing the minimum ring-size may present a problem on a network that lacks architecture to support larger sized transactions, due to the increased overhead. With Loki however, this burden can be carried by Service Nodes that are incentivised to operate and provide sufficient bandwidth.","title":"Ring Signature"},{"location":"Advanced/RingSignature/#ring-signature","text":"Ring signatures are used to hide real outputs amongst others in any given transaction.","title":"Ring Signature"},{"location":"Advanced/RingSignature/#ring-signature-size","text":"The size of a ring signature refers to how many mixins are used to construct the ring. Monero currently has an enforced minimum ring signature size of seven, with six mixins used alongside the real unspent output in a transaction. The effect of larger ring-sizes has been sparsely studied, however, in paper 0001 (published by the Monero Research Lab), the effect of differing ring-sizes was analysed versus an attacker who owned a large number of outputs on the blockchain . It was found that higher ring-sizes reduce the timeframe in which a malicious attacker who owned a large number of unspent outputs would be able to perform effective analysis of transactions. Mandating larger ring-sizes also protects against a theoretical attack known as an EABE/Knacc attack , where a third-party (i.e. an exchange) can perform limited temporal analysis on transactions between two users. Additionally, Monero has no maximum ring-size enforced by network consensus rules. Many wallets like the Monero GUI wallet cap the ring-size at 26. However, a user is free to manually create a transaction with whatever ring-size they wish, as long as it is above a ring-size of seven. This is problematic since most wallets have a default ring-size of seven. Increasing a transactions ring-size above seven makes it stand out. Further, if an individuals transactions were to always use a non-standard ring-size in Monero (ten for example), a passive third-party could analyse the blockchain and infer patterns using temporal analysis. transaction hash ring size tx size[kB] 3feaff3f48de0bc4c92ec027236165337b64df404aca098e212c1215e9456697 7 13.47 39d484f7c0a2e8f3823a514056d7cb0bf269171cb4582e05955d4c5ee995cad0 7 13.47 e08f5a937e725011bedd44075334ae98dcca32749da231c56da1278d49c0a231 7 13.50 ab35e69d9cca39219c90df8b2b7aab4a54c82127fb1fbaae65d76357f8f76387 7 13.5 6d8ccd56dc2d3eb7de03ba767f0dbf4d5f42ae91e67f4c28f16d6f8b0229c272 10 13.87","title":"Ring Signature Size"},{"location":"Advanced/RingSignature/#loki-static-ring-size","text":"Loki improves on both of these problems by statically enforcing ring-sizes, and setting the ring-size to ten. Statically setting the maximum ring-size protects users who construct rings with more than nine mixins and setting the ring-size minimum to ten more effectively prevents an attacker who owns a large number of outputs from discerning the true outputs spent in a ring signature. Larger ring-sizes also increase the default churning effectiveness non-linearly, becoming more effective as ring-sizes grow. In the current transaction scheme, increasing the ring-size to 10 would lead to a 2.6% increase in the size of the transaction. However, when Bulletproofs are implemented it will account for about a 8 - 13% increase in the size of a transaction. This is because of the overall reduction in transaction size caused by Bulletproofs. Increasing the minimum ring-size may present a problem on a network that lacks architecture to support larger sized transactions, due to the increased overhead. With Loki however, this burden can be carried by Service Nodes that are incentivised to operate and provide sufficient bandwidth.","title":"Loki Static Ring Size"},{"location":"Advanced/SNRPCGuide/","text":"Service Nodes Guide \u00b6 JSON 2.0 RPC Calls \u00b6 get_quorum_state \u00b6 Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_quorum_state\", \"params\": {\"height\": 200}}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"nodes_to_test\": [\"578e5ee53150a3276dd3c411cb6313324a63b530cf3651f5c15e3d0ca58ceddd\", \u2026 \"c917034e9fcd0e9b0d423638664bbfc36eb8a2eeb68a1ff8bed8be5f699bc3c0\"], \"quorum_nodes\": [\"fc86a737756b6ed9f81233d22da3baee32537f3087901c3e94384be85ca1a9ee\", \u2026 \"ee597c5c7bbf1452e689a785f1133fc1355889b4111955d54cb5ed826cd35a32\"], \"status\": \"OK\", \"untrusted\": false } } Nodes have been omitted with \u201c...\u201d for brevity in nodes_to_test and quorum_nodes. Inputs \u00b6 Int height The height to query the quorum state for Outputs \u00b6 String[] nodes_to_test An array of public keys identifying service nodes which are being tested for the queried height. String[] quorum_state An array of public keys identifying service nodes which are responsible for voting on the queried height. get_staking_requirement \u00b6 Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the --stagenet or --testnet flags respectively. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_staking_requirement\", \"params\": {\u201cheight\u201d: 111111}}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"staking_requirement\": 100000000000, \"status\": \"OK\" } } Inputs \u00b6 Int height The height to query the staking requirement for Outputs \u00b6 Uint64 staking_requirement The staking requirement in Loki atomic units for the queried height get_service_node_key \u00b6 Get the service node public key of the queried daemon. The daemon must be started in --service-node mode otherwise this RPC command will fail. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_node_key\"}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_pubkey\": \"8d56c1fa0304884e612ee2efe763b2c50991a66329418fd084a3f23c75399f34\", \"status\": \"OK\" } } Inputs \u00b6 N/A Outputs \u00b6 String service_node_pubkey The public key identifying the queried service node get_service_nodes \u00b6 Get the metadata currently associated with the queried service node public keys such as, registration height and contributors, etc. If no public key is specified, this returns all the metadata for every service node the queried daemon currently knows about. Testnet Example \u00b6 curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_nodes\", \u201cparams\u201d: \u201cservice_node_pubkeys\u201d: []}' -H 'Content-Type: application/json' Result \u00b6 { \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_states\": [{ \"contributors\": [{ \"address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"amount\": 100000000000, \"reserved\": 100000000000 }], \"last_reward_block_height\": 2968, \"last_reward_transaction_index\": 4294967295, \"last_uptime_proof\": 0, \"operator_address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"portions_for_operator\": 18446744073709551612, \"registration_height\": 1860, \"service_node_pubkey\": \"3afa36a4855a429f5eac1b2f8e7e77657a2e862999ab4d59e473826f9b15f2da\", \"staking_requirement\": 100000000000, \"total_contributed\": 100000000000, \"total_reserved\": 100000000000 }], \"status\": \"OK\" } } Inputs \u00b6 String[] service_node_pubkeys An array of service node public keys in strings that you wish to query metadata for. If an empty array is given, this RPC command returns all service nodes it knows about. Outputs \u00b6 Entry[] service_node_states The array of metadata for the queried service node(s) String service_node_pubkey The queried service node\u2019s identifying public key Uint64 registration_height The height at which the registration transaction arrived on the blockchain Uint64 last_reward_block_height The last block height this service node received a reward. Rewards are sent to service nodes whom have been waiting longest since their last reward and are then sent to the back of the queue. Uint64 last_reward_transaction_index The position in the queue to receive a reward for the service nodes grouped in the last_reward_block_height. Uint64 last_uptime_proof Unix epoch timestamp of the last time this daemon has received a ping from the queried service node. Contribution[] contributors An array consisting of all the addresses that have contributed to the queried service node. Uint64 Contribution.amount The amount of Loki in atomic units the contributor has staked. Uint64 Contribution.reserved The amount of Loki in atomic units the contributor has reserved and must fulfill to completely contribute their part to the service node. Amount is equal to reserved once the contributor has fully contributed their part. String Contribution.address The Loki address that funds must come from to fulfill the contribution requirement. Uint64 total_contributed The total Loki currently contributed going towards the staking requirement. Uint64 total_reserved The total Loki that has been reserved by all contributors. The remaining Loki is open for other contributors to increase their stake towards the service node. Uint64 portions_for_operator The operator cut expressed as a value from 0 -> STAKING_PORTIONS (defined in loki/src/cryptonote_config.h) which is the fee taken from the service node reward and given to the operator address before rewards are distributed to the contributors. Uint64 operator_address The wallet address which is the primary owner of the service node and also the address which the operator cut is sent to.","title":"Service Node RPC Guide"},{"location":"Advanced/SNRPCGuide/#service-nodes-guide","text":"","title":"Service Nodes Guide"},{"location":"Advanced/SNRPCGuide/#json-20-rpc-calls","text":"","title":"JSON 2.0 RPC Calls"},{"location":"Advanced/SNRPCGuide/#get95quorum95state","text":"Get the quorum state which is the list of public keys of the nodes who are voting, and the list of public keys of the nodes who are being tested.","title":"get_quorum_state"},{"location":"Advanced/SNRPCGuide/#testnet-example","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_quorum_state\", \"params\": {\"height\": 200}}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Advanced/SNRPCGuide/#result","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"nodes_to_test\": [\"578e5ee53150a3276dd3c411cb6313324a63b530cf3651f5c15e3d0ca58ceddd\", \u2026 \"c917034e9fcd0e9b0d423638664bbfc36eb8a2eeb68a1ff8bed8be5f699bc3c0\"], \"quorum_nodes\": [\"fc86a737756b6ed9f81233d22da3baee32537f3087901c3e94384be85ca1a9ee\", \u2026 \"ee597c5c7bbf1452e689a785f1133fc1355889b4111955d54cb5ed826cd35a32\"], \"status\": \"OK\", \"untrusted\": false } } Nodes have been omitted with \u201c...\u201d for brevity in nodes_to_test and quorum_nodes.","title":"Result"},{"location":"Advanced/SNRPCGuide/#inputs","text":"Int height The height to query the quorum state for","title":"Inputs"},{"location":"Advanced/SNRPCGuide/#outputs","text":"String[] nodes_to_test An array of public keys identifying service nodes which are being tested for the queried height. String[] quorum_state An array of public keys identifying service nodes which are responsible for voting on the queried height.","title":"Outputs"},{"location":"Advanced/SNRPCGuide/#get95staking95requirement","text":"Get the required amount of Loki to become a Service Node at the queried height. For stagenet and testnet values, ensure the daemon is started with the --stagenet or --testnet flags respectively.","title":"get_staking_requirement"},{"location":"Advanced/SNRPCGuide/#testnet-example_1","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_staking_requirement\", \"params\": {\u201cheight\u201d: 111111}}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Advanced/SNRPCGuide/#result_1","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"staking_requirement\": 100000000000, \"status\": \"OK\" } }","title":"Result"},{"location":"Advanced/SNRPCGuide/#inputs_1","text":"Int height The height to query the staking requirement for","title":"Inputs"},{"location":"Advanced/SNRPCGuide/#outputs_1","text":"Uint64 staking_requirement The staking requirement in Loki atomic units for the queried height","title":"Outputs"},{"location":"Advanced/SNRPCGuide/#get95service95node95key","text":"Get the service node public key of the queried daemon. The daemon must be started in --service-node mode otherwise this RPC command will fail.","title":"get_service_node_key"},{"location":"Advanced/SNRPCGuide/#testnet-example_2","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_node_key\"}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Advanced/SNRPCGuide/#result_2","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_pubkey\": \"8d56c1fa0304884e612ee2efe763b2c50991a66329418fd084a3f23c75399f34\", \"status\": \"OK\" } }","title":"Result"},{"location":"Advanced/SNRPCGuide/#inputs_2","text":"N/A","title":"Inputs"},{"location":"Advanced/SNRPCGuide/#outputs_2","text":"String service_node_pubkey The public key identifying the queried service node","title":"Outputs"},{"location":"Advanced/SNRPCGuide/#get95service95nodes","text":"Get the metadata currently associated with the queried service node public keys such as, registration height and contributors, etc. If no public key is specified, this returns all the metadata for every service node the queried daemon currently knows about.","title":"get_service_nodes"},{"location":"Advanced/SNRPCGuide/#testnet-example_3","text":"curl -X POST http://127.0.0.1:38157/json_rpc -d '{\"jsonrpc\":\"2.0\",\"id\":\"0\",\"method\":\"get_service_nodes\", \u201cparams\u201d: \u201cservice_node_pubkeys\u201d: []}' -H 'Content-Type: application/json'","title":"Testnet Example"},{"location":"Advanced/SNRPCGuide/#result_3","text":"{ \"id\": \"0\", \"jsonrpc\": \"2.0\", \"result\": { \"service_node_states\": [{ \"contributors\": [{ \"address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"amount\": 100000000000, \"reserved\": 100000000000 }], \"last_reward_block_height\": 2968, \"last_reward_transaction_index\": 4294967295, \"last_uptime_proof\": 0, \"operator_address\": \"T6T6kZfTEf5JGw2SgLrGuxRNFxRTf51fvbbcCYW949RsKjX75JMA1B1d8CT4VbwfGR8uf3f3AJSTaBHGpN3QRG2N2LyiksWVg\", \"portions_for_operator\": 18446744073709551612, \"registration_height\": 1860, \"service_node_pubkey\": \"3afa36a4855a429f5eac1b2f8e7e77657a2e862999ab4d59e473826f9b15f2da\", \"staking_requirement\": 100000000000, \"total_contributed\": 100000000000, \"total_reserved\": 100000000000 }], \"status\": \"OK\" } }","title":"Result"},{"location":"Advanced/SNRPCGuide/#inputs_3","text":"String[] service_node_pubkeys An array of service node public keys in strings that you wish to query metadata for. If an empty array is given, this RPC command returns all service nodes it knows about.","title":"Inputs"},{"location":"Advanced/SNRPCGuide/#outputs_3","text":"Entry[] service_node_states The array of metadata for the queried service node(s) String service_node_pubkey The queried service node\u2019s identifying public key Uint64 registration_height The height at which the registration transaction arrived on the blockchain Uint64 last_reward_block_height The last block height this service node received a reward. Rewards are sent to service nodes whom have been waiting longest since their last reward and are then sent to the back of the queue. Uint64 last_reward_transaction_index The position in the queue to receive a reward for the service nodes grouped in the last_reward_block_height. Uint64 last_uptime_proof Unix epoch timestamp of the last time this daemon has received a ping from the queried service node. Contribution[] contributors An array consisting of all the addresses that have contributed to the queried service node. Uint64 Contribution.amount The amount of Loki in atomic units the contributor has staked. Uint64 Contribution.reserved The amount of Loki in atomic units the contributor has reserved and must fulfill to completely contribute their part to the service node. Amount is equal to reserved once the contributor has fully contributed their part. String Contribution.address The Loki address that funds must come from to fulfill the contribution requirement. Uint64 total_contributed The total Loki currently contributed going towards the staking requirement. Uint64 total_reserved The total Loki that has been reserved by all contributors. The remaining Loki is open for other contributors to increase their stake towards the service node. Uint64 portions_for_operator The operator cut expressed as a value from 0 -> STAKING_PORTIONS (defined in loki/src/cryptonote_config.h) which is the fee taken from the service node reward and given to the operator address before rewards are distributed to the contributors. Uint64 operator_address The wallet address which is the primary owner of the service node and also the address which the operator cut is sent to.","title":"Outputs"},{"location":"Advanced/SwarmFlagging/","text":"Swarm Flagging \u00b6 When nodes operate in a trustless environment without a centralised leader enforcing over arching rules, maintaining proper node behaviour on the network becomes difficult. Although Service Nodes in Loki must hold the correct collateral requirement , they may choose to not route traffic or store data in their memory pools. Because this option is financially beneficial (using less bandwidth/CPU cycles/storage), a system of distributed flagging must be proposed to remove underperforming nodes. For Loki, such distributed flagging faces major implementation issues. Fundamentally, every Service Nodes is financially incentivised to flag every other Service Node as a bad actor. This is because when a Service Node is flagged it will face removal from the staking pool and thereby increase the flaggers chance at winning a reward. One potential method of distributed flagging is one in which evidence is provided when a flagging event occurs, however, this solution falls prey to nodes fabricating evidence in their favour. Conversely, flagging without restrictions allows either single nodes or groups of collaborating nodes to intentionally flag honest nodes in order to improve their chances of winning block rewards . To circumvent these issues, Loki proposes swarm flagging. Swarm flagging works by using existing swarms to choose members that will participate in each testing round. Each Service Node holds a copy of the blockchain, and each block created by a miner will deterministically select a number of test swarms. Every block, 1% of the networks swarms are selected for participation in a testing swarm. To calculate participating swarms, the hash of the five previous blocks is used to seed a Mersenne Twister function which then selects swarms by order of their position in the deterministic list. When a swarm has been selected to participate, each node in that swarm is expected to conduct a number of tests on every other node in the swarm. These are not active tests; rather each node stores historical information about its interactions with every other nodenwithin its swarm. Information about bandwidth, message storage, blockchain requests, andn exit node functionality are collected and retained over time. New swarm entrants that have yet to gather this information can query Service Nodes outside of their immediate swarm so as to gather data on each of the Service Nodes they test. Each Service Nodes decides how to vote on each of the other swarm members. Once it has made its decision based on the aforementioned tests, it collects and broadcasts its votes to the swarm. Each node in the swarm can now check the votes for all members. If any single node in the swarm has over 50% of the nodes voting against it, any swarm member has the required information to construct a deregistration transaction. Once this transaction is validated and included in a block, all Service Nodes update their DHT, purging any nodes that were voted off. Testing Suite \u00b6 In order to allow the network to self-enforce performance standards, Service Nodes must be equipped with the required tools so as to test other Service Nodes. These tests should cover the scope of all functionality provided by Service Nodes to prevent lazy masternode attacks . In this initial design, four fundamental tests are proposed. Further tests may be added to the test suite as the function of Services Nodes expands. When an operator first runs the Service Nodes software, an empty file with a predetermined size is allocated on disk to ensure that space is present for tasks that require storage. Next, a simple bandwidth test is conducted between the Service Node and a geographically distributed set of testing servers run by the Loki Foundation . These checks are optional, and Service Nodes are allowed to skip, ignore or fail them, and join the pool of untrusted Service Nodes. However, running and passing these tests provides a good indicator to any would-be Service Node operator as to whether they should risk locking collateral in a node that may not meet minimum requirements. Once a Service Node joins the untrusted Service Node pool, their collateral is locked and they are tested by the next chosen swarm. Swarm tests are enforced via consensus and new entrants to the Service Node network cannot evade these tests. If a node passes all swarm tests, they are awarded the trusted node flag and can begin routing packets. Failing this, they are removed from the network and their collateral remains locked for 30 days. Bandwidth Test \u00b6 The bandwidth test forms the backbone of the Loki network test suite. If a node passes this test then it is assumed to be honestly routing packets above the minimum threshold. Each time a node interacts with another Service Node, it will make and retain a record of the incoming bandwidth provided. Over time, nodes will be included in thousands of paths and route millions of messages . These interactions will form the basis of each nodes bandwidth tables. From this table, a node can respond to bandwidth tests about Service Nodes inside its swarm. All nodes are also expected to respond to queries of their own bandwidth tables from other nodes. This means that even nodes who have recently joined the network can query the wider network for information about any specific node in their swarm. Message Storage Test \u00b6 Message storage is essential for offline messaging functionality for users of Loki Messenger . Service Nodes must be tested for their ability to cache messages and serve them to users over the course of the message\u2019s Time-to-live (TTL). Users sending offline messages randomly select a Service Node within the destination users swarm. This node must distribute a copy of the message amongst the rest of the swarm. Depending on the proof-of-work attached to the header of the message, Service Nodes that receive a copy will store the data for the TTL. As the TTL on the original message reaches finality, the distributing node sends a nonce to all other members of the swarm. The swarm uses the nonce adding it to the message then hashing the result and then finally sending it back to the distributing node. This test ensures that Service Nodes hold messages until TTL finality, and face eviction if they are unable to produce the correct message digest. As the sampling of the distributing node is random, over time each Service Node will be able to collect performance data on their swarm peers. Blockchain Storage Test \u00b6 Service Nodes are expected to hold a full copy of the Loki blockchain. By holding a full copy of the blockchain, Service Nodes can perform a number of tasks that are essential to users of the network including acting as a remote node, validating transactions, and locking transactions in Blink. As honest nodes also hold a copy of the blockchain, a dishonest node could avoid holding a full copy by simply requesting blocks from an honest node when tested. To avoid this outcome, the blockchain storage test is designed so that honest nodes that hold a copy of the blockchain can pass this test, while dishonest nodes cannot. To achieve this, the testing node requests each tested node to make a selection of K random transactions within the history of the blockchain which are then concatenated and hashed. This hash is then be returned to the testing node. By measuring the latency of this request, the testing node can compare the latency with the expected return time T . The exact value for T will be set to accurately differentiate expected latency between loading from disk and downloading blocks from the network. For any attacker, it should be infeasible to download and hash K blocks within T , and thus piggybacking attacks become difficult. Exit Node Test \u00b6 Service Nodes that opt to act as exit nodes receive additional rewards, and so functional tests are required to ensure this extra reward is not abused. For functional exit testing to occur, a Service Node must be able to emulate the natural search behaviour of a human. If a Service Node can detect that it is being tested, it can respond only to tests and discard legitimate user requests. Emulating natural page request behaviour is difficult, however, exit tests can be designed in such a way so as to make the overhead of sorting between legitimate requests and tests sufficiently difficult so that the difference in bandwidth cost between running a legitimate node and a malicious node is negligible. Service Nodes use a list of search engines, held locally, combined with a dictionary so as to construct pseudorandom natural search terms. The search terms are then fed into the search engines and web pages are randomly chosen from the results. The Service node can now build a path with random nodes acting as relays and the node being tested as the exit node. From this exit, the Service Node requests the webpage result generated from its pseudorandom search. If the result returned by the exit node matches the result as generated by the Service Node, then the exit node is deemed to have passed the test.","title":"Swarm Flagging"},{"location":"Advanced/SwarmFlagging/#swarm-flagging","text":"When nodes operate in a trustless environment without a centralised leader enforcing over arching rules, maintaining proper node behaviour on the network becomes difficult. Although Service Nodes in Loki must hold the correct collateral requirement , they may choose to not route traffic or store data in their memory pools. Because this option is financially beneficial (using less bandwidth/CPU cycles/storage), a system of distributed flagging must be proposed to remove underperforming nodes. For Loki, such distributed flagging faces major implementation issues. Fundamentally, every Service Nodes is financially incentivised to flag every other Service Node as a bad actor. This is because when a Service Node is flagged it will face removal from the staking pool and thereby increase the flaggers chance at winning a reward. One potential method of distributed flagging is one in which evidence is provided when a flagging event occurs, however, this solution falls prey to nodes fabricating evidence in their favour. Conversely, flagging without restrictions allows either single nodes or groups of collaborating nodes to intentionally flag honest nodes in order to improve their chances of winning block rewards . To circumvent these issues, Loki proposes swarm flagging. Swarm flagging works by using existing swarms to choose members that will participate in each testing round. Each Service Node holds a copy of the blockchain, and each block created by a miner will deterministically select a number of test swarms. Every block, 1% of the networks swarms are selected for participation in a testing swarm. To calculate participating swarms, the hash of the five previous blocks is used to seed a Mersenne Twister function which then selects swarms by order of their position in the deterministic list. When a swarm has been selected to participate, each node in that swarm is expected to conduct a number of tests on every other node in the swarm. These are not active tests; rather each node stores historical information about its interactions with every other nodenwithin its swarm. Information about bandwidth, message storage, blockchain requests, andn exit node functionality are collected and retained over time. New swarm entrants that have yet to gather this information can query Service Nodes outside of their immediate swarm so as to gather data on each of the Service Nodes they test. Each Service Nodes decides how to vote on each of the other swarm members. Once it has made its decision based on the aforementioned tests, it collects and broadcasts its votes to the swarm. Each node in the swarm can now check the votes for all members. If any single node in the swarm has over 50% of the nodes voting against it, any swarm member has the required information to construct a deregistration transaction. Once this transaction is validated and included in a block, all Service Nodes update their DHT, purging any nodes that were voted off.","title":"Swarm Flagging"},{"location":"Advanced/SwarmFlagging/#testing-suite","text":"In order to allow the network to self-enforce performance standards, Service Nodes must be equipped with the required tools so as to test other Service Nodes. These tests should cover the scope of all functionality provided by Service Nodes to prevent lazy masternode attacks . In this initial design, four fundamental tests are proposed. Further tests may be added to the test suite as the function of Services Nodes expands. When an operator first runs the Service Nodes software, an empty file with a predetermined size is allocated on disk to ensure that space is present for tasks that require storage. Next, a simple bandwidth test is conducted between the Service Node and a geographically distributed set of testing servers run by the Loki Foundation . These checks are optional, and Service Nodes are allowed to skip, ignore or fail them, and join the pool of untrusted Service Nodes. However, running and passing these tests provides a good indicator to any would-be Service Node operator as to whether they should risk locking collateral in a node that may not meet minimum requirements. Once a Service Node joins the untrusted Service Node pool, their collateral is locked and they are tested by the next chosen swarm. Swarm tests are enforced via consensus and new entrants to the Service Node network cannot evade these tests. If a node passes all swarm tests, they are awarded the trusted node flag and can begin routing packets. Failing this, they are removed from the network and their collateral remains locked for 30 days.","title":"Testing Suite"},{"location":"Advanced/SwarmFlagging/#bandwidth-test","text":"The bandwidth test forms the backbone of the Loki network test suite. If a node passes this test then it is assumed to be honestly routing packets above the minimum threshold. Each time a node interacts with another Service Node, it will make and retain a record of the incoming bandwidth provided. Over time, nodes will be included in thousands of paths and route millions of messages . These interactions will form the basis of each nodes bandwidth tables. From this table, a node can respond to bandwidth tests about Service Nodes inside its swarm. All nodes are also expected to respond to queries of their own bandwidth tables from other nodes. This means that even nodes who have recently joined the network can query the wider network for information about any specific node in their swarm.","title":"Bandwidth Test"},{"location":"Advanced/SwarmFlagging/#message-storage-test","text":"Message storage is essential for offline messaging functionality for users of Loki Messenger . Service Nodes must be tested for their ability to cache messages and serve them to users over the course of the message\u2019s Time-to-live (TTL). Users sending offline messages randomly select a Service Node within the destination users swarm. This node must distribute a copy of the message amongst the rest of the swarm. Depending on the proof-of-work attached to the header of the message, Service Nodes that receive a copy will store the data for the TTL. As the TTL on the original message reaches finality, the distributing node sends a nonce to all other members of the swarm. The swarm uses the nonce adding it to the message then hashing the result and then finally sending it back to the distributing node. This test ensures that Service Nodes hold messages until TTL finality, and face eviction if they are unable to produce the correct message digest. As the sampling of the distributing node is random, over time each Service Node will be able to collect performance data on their swarm peers.","title":"Message Storage Test"},{"location":"Advanced/SwarmFlagging/#blockchain-storage-test","text":"Service Nodes are expected to hold a full copy of the Loki blockchain. By holding a full copy of the blockchain, Service Nodes can perform a number of tasks that are essential to users of the network including acting as a remote node, validating transactions, and locking transactions in Blink. As honest nodes also hold a copy of the blockchain, a dishonest node could avoid holding a full copy by simply requesting blocks from an honest node when tested. To avoid this outcome, the blockchain storage test is designed so that honest nodes that hold a copy of the blockchain can pass this test, while dishonest nodes cannot. To achieve this, the testing node requests each tested node to make a selection of K random transactions within the history of the blockchain which are then concatenated and hashed. This hash is then be returned to the testing node. By measuring the latency of this request, the testing node can compare the latency with the expected return time T . The exact value for T will be set to accurately differentiate expected latency between loading from disk and downloading blocks from the network. For any attacker, it should be infeasible to download and hash K blocks within T , and thus piggybacking attacks become difficult.","title":"Blockchain Storage Test"},{"location":"Advanced/SwarmFlagging/#exit-node-test","text":"Service Nodes that opt to act as exit nodes receive additional rewards, and so functional tests are required to ensure this extra reward is not abused. For functional exit testing to occur, a Service Node must be able to emulate the natural search behaviour of a human. If a Service Node can detect that it is being tested, it can respond only to tests and discard legitimate user requests. Emulating natural page request behaviour is difficult, however, exit tests can be designed in such a way so as to make the overhead of sorting between legitimate requests and tests sufficiently difficult so that the difference in bandwidth cost between running a legitimate node and a malicious node is negligible. Service Nodes use a list of search engines, held locally, combined with a dictionary so as to construct pseudorandom natural search terms. The search terms are then fed into the search engines and web pages are randomly chosen from the results. The Service node can now build a path with random nodes acting as relays and the node being tested as the exit node. From this exit, the Service Node requests the webpage result generated from its pseudorandom search. If the result returned by the exit node matches the result as generated by the Service Node, then the exit node is deemed to have passed the test.","title":"Exit Node Test"},{"location":"Advanced/SybilResistance/","text":"Sybil Resistance \u00b6","title":"Sybil Resistance"},{"location":"Advanced/SybilResistance/#sybil-resistance","text":"","title":"Sybil Resistance"},{"location":"Advanced/TechnicalSpecs/","text":"","title":"Technical Specs"},{"location":"Advanced/UsingLokiNET/","text":"Using LokiNET \u00b6 // TODO: overview for lokinet cli guide --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation). --p2p-bind-ifname=lokitun0 to bind to just the lokinet tun interface // TODO: note which version of lokid has --p2p-bind-ifname option Example command line to start lokid for JUST lokinet traffic lokid --no-igd --p2p-bind-ifname=lokitun0","title":"Using LokiNET"},{"location":"Advanced/UsingLokiNET/#using-lokinet","text":"// TODO: overview for lokinet cli guide --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation). --p2p-bind-ifname=lokitun0 to bind to just the lokinet tun interface // TODO: note which version of lokid has --p2p-bind-ifname option Example command line to start lokid for JUST lokinet traffic lokid --no-igd --p2p-bind-ifname=lokitun0","title":"Using LokiNET"},{"location":"Advanced/UsingTor/","text":"Using Tor \u00b6 While Loki isn't made to integrate with Tor, it can be used wrapped with torsocks, by setting the following configuration parameters and environment variables: --p2p-bind-ip 127.0.0.1 on the command line or p2p-bind-ip=127.0.0.1 in lokid.conf to disable listening for connections on external interfaces. --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation), which is pointless with Tor. DNS_PUBLIC=tcp or DNS_PUBLIC=tcp://x.x.x.x where x.x.x.x is the IP of the desired DNS server, for DNS requests to go over TCP, so that they are routed through Tor. When IP is not specified, lokid uses the default list of servers defined in src/common/dns_utils.cpp . TORSOCKS_ALLOW_INBOUND=1 to tell torsocks to allow lokid to bind to interfaces to accept connections from the wallet. On some Linux systems, torsocks allows binding to localhost by default, so setting this variable is only necessary to allow binding to local LAN/VPN interfaces to allow wallets to connect from remote hosts. On other systems, it may be needed for local wallets as well. Do NOT pass --detach when running through torsocks with systemd, (see utils/systemd/lokid.service for details). Example command line to start lokid through Tor: DNS_PUBLIC=tcp torsocks lokid --p2p-bind-ip 127.0.0.1 --no-igd Using Tor on Tails \u00b6 TAILS ships with a very restrictive set of firewall rules. Therefore, you need to add a rule to allow this connection too, in addition to telling torsocks to allow inbound connections. Full example: sudo iptables -I OUTPUT 2 -p tcp -d 127.0.0.1 -m tcp --dport 18081 -j ACCEPT DNS_PUBLIC=tcp torsocks ./lokid --p2p-bind-ip 127.0.0.1 --no-igd --rpc-bind-ip 127.0.0.1 \\ --data-dir /home/amnesia/Persistent/your/directory/to/the/blockchain","title":"Using Tor"},{"location":"Advanced/UsingTor/#using-tor","text":"While Loki isn't made to integrate with Tor, it can be used wrapped with torsocks, by setting the following configuration parameters and environment variables: --p2p-bind-ip 127.0.0.1 on the command line or p2p-bind-ip=127.0.0.1 in lokid.conf to disable listening for connections on external interfaces. --no-igd on the command line or no-igd=1 in lokid.conf to disable IGD (UPnP port forwarding negotiation), which is pointless with Tor. DNS_PUBLIC=tcp or DNS_PUBLIC=tcp://x.x.x.x where x.x.x.x is the IP of the desired DNS server, for DNS requests to go over TCP, so that they are routed through Tor. When IP is not specified, lokid uses the default list of servers defined in src/common/dns_utils.cpp . TORSOCKS_ALLOW_INBOUND=1 to tell torsocks to allow lokid to bind to interfaces to accept connections from the wallet. On some Linux systems, torsocks allows binding to localhost by default, so setting this variable is only necessary to allow binding to local LAN/VPN interfaces to allow wallets to connect from remote hosts. On other systems, it may be needed for local wallets as well. Do NOT pass --detach when running through torsocks with systemd, (see utils/systemd/lokid.service for details). Example command line to start lokid through Tor: DNS_PUBLIC=tcp torsocks lokid --p2p-bind-ip 127.0.0.1 --no-igd","title":"Using Tor"},{"location":"Advanced/UsingTor/#using-tor-on-tails","text":"TAILS ships with a very restrictive set of firewall rules. Therefore, you need to add a rule to allow this connection too, in addition to telling torsocks to allow inbound connections. Full example: sudo iptables -I OUTPUT 2 -p tcp -d 127.0.0.1 -m tcp --dport 18081 -j ACCEPT DNS_PUBLIC=tcp torsocks ./lokid --p2p-bind-ip 127.0.0.1 --no-igd --rpc-bind-ip 127.0.0.1 \\ --data-dir /home/amnesia/Persistent/your/directory/to/the/blockchain","title":"Using Tor on Tails"},{"location":"Advanced/lokid/","text":"TO DO","title":"lokid"},{"location":"Contributing/Github/","text":"","title":"Using Github"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/","text":"Vulnerability disclosure Loki \u00b6 This Vulnerability Response Process and subsequent bounty reward apply to the following: Code implementation as seen in the Loki repository which sits underneath the Loki-Project Written research from the Loki Team which dictates said code implementation Researchers/Hackers: while you research/hack, we ask that you please refrain from committing the following: Denial of Service / Active exploiting against the Loki mainnet, Runechain or Service node networks Social Engineering of Loki staff, contractors or Foundation members Any physical or electronic attempts against Loki community property and/or data centers As a pro-privacy project we have volunteers running copies of the websites on hidden services on Tor and I2P, as well as on multiple public domains. The live sites are NOT in the scope of this process; only the code is! Bounty will be released for all projects in Loki (LOK) only. For more information on how to use Loki, visit the Loki website Bounty is not eligible to those who: do not abide by the VRP for responsible disclosure 1. Points of contact for security issues \u00b6 Kee [at] Loki.network PGP fingerprint = 8877 EEBB 9721 ABC5 DF64 9AE4 AC97 1489 5CE4 5D55 -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrbANQBCAC5HMKeapz+WECQ3vY1XuSOM32yUfzp4V/rY5+YvJ/Gb7wxczF2 NTLxfr7ueJTyICXcj/h7qnvdtpbN87ZhjWTZzG0lmrCIfZX75dOQIjch8DkGblEB RUG90edRx4GwYHPjfIUbIxYHcINKYMgH9jKqfHAVQD7HuvkBX1IYbNi/Kgj0wVgJ vVA94x8JCD5blqGbos7r02bZxQHujAHnC19/PQxRyZwJNI0v1xJgy6w/cQduFLzL GeEnkQfmJiSKEYzRLY3BYRSmysqD0bLGWLLSa1fcxAD+kllY1kSZXpHKH1XmErpi pRCLblQs0kZYqHDKG2gscfpuaaM4fSiGmY8nABEBAAG0H0tlZSBKZWZmZXJ5cyA8 S2VlQGxva2kubmV0d29yaz6JATwEEwEKACYFAlrbANQCGwMFCQlmRIwFCwkIBwMF FQoJCAsEFgIBAAIeAQIXgAAKCRCslxSJXORdVa7zCACAw7eEYcXlZXxXOB43TSKq BTBtqISmu0+Me94PXNGo5XOp0gzVhgXPedbuz58Y1g9aCp0/wwg5cZvh6ky8zwgt q2BtayTb36elUkcejo9IdgN+1Ruzr8bUdWQrw7w/sZGgI3ZaoMlHvm7mus1cqKH4 3gKaBYG/zPG25hgne13j365kxi+xgklvo0lL3atHV61UxdTlgDm2s4ZtfrMeV9fY DRwcIjzyYv3HWAJvD60dN1RHzTCBxiMiyl6HLawh/3dpHVDOAdrIGqHfIbzodVLW SA4JLw8at3JA8ColWkyFQj1srxvJJunT+haH32h2g9rNS/lf5z+Mdv+LfIPv/iZ5 uQENBFrbANQBCAC+4N/f+RZ8jYHW6VLPGT8nspuEyEgE++zab5XOkS8qcnP0e2sR F0G1RLlJr6hfaowEqLOO0CTIguOBpRfeTWLHzSUK+w8pFx2GfvxXAyxViNbsA5/U E4gbDgOu8AkZWOQLK0nPnE0eyBhHCz22yTJY7P5AUcbo2jw9q9Ye78GbTQx8JPXl jia/VZprMILFOGQROGkH1amqDcaNuX6iOMKS6GtyP+eElPj+IWqwMUlr9aX+ptBQ zfsw+KzgYC+RBS44SM98ZgNBEibZXKfQMT2t80riKgRUPTBQcOref9T+jAtfZl1A OAKm0tLc3o0n0WvmjvxxOOfzdpvEDya12e4VABEBAAGJASUEGAEKAA8FAlrbANQC GwwFCQlmRIwACgkQrJcUiVzkXVWaNQf8C0oYU0iN3YuA+AXGxBlfMHlxz4xhbbd7 Fn8EOIxi3scOltYeU/WvdSdXZ4IJEjydPo7TmVrQ746MUfLC+6ZfH9EDP322s+T/ TYbt3oNA0RWl2CxakpIlRKgCIuC6EEc1U32nKsXH3Uz7UVx8u9GrDxSvGhTSVppN k3nhtcWeSBtANrWuhei1MC4+bRdHHExf6kHtdDMNsuwJmG3FtlKoP9l/Vpb3KscX 9FqdEYPrJSNk3QrndS/a9QzWsm4PR0LTp2+2WC2cDgFjPUqZqZVLA5hSutUVTzGG fKg1gFLyG7Ed4fSa25pe5nUSJUCjFy1HprSM+I9IsSxc8sDll60a3Q== =iX6u -----END PGP PUBLIC KEY BLOCK----- Simon [at] Loki.network PGP fingerprint = 45FF F23B 7805 CEC7 7C7E 15F6 2246 DFA8 0945 A5BD -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrmnhgBCAC3LWatVxk3QWV7V42B++En8l3xDeQ3uAaXwRot98/4ybImAwmc ur4YCuLBXBiyZPrUQ8m6DxGG9a2RaNll+2dEkaxjDxIJsM7Op+2nUxlDBGrSS3Cf p40BxM4pDBDe1j9haSdoamujYpUDCpYTLA1npKiCUncITsmc+ivefkXBskgh66eI f69yEdeN7dvAqOWaaogBKucQfk9Si3MDXTAqm+hJbR1ByHBw/C0yXfNuq46mEVn6 Tu25cquQPIfYebXldJ4MDD5vogzPJqjMH5Kna/24PqKiR9KpI8NYjUbiRlhuJj2q SjOvks9bJ4Qf+yp7o7qA41TCecsVxdciqtnJABEBAAG0IVNpbW9uIEhhcm1hbiA8 c2ltb25AbG9raS5uZXR3b3JrPokBPAQTAQoAJgUCWuaeGAIbAwUJCWaEyAULCQgH AwUVCgkICwQWAgEAAh4BAheAAAoJECJG36gJRaW9G9QH+gLTCoILegkdJDqGvjsK r7eeD4jxuuRWcWohf+g/Xt9WUR4vOYdUY5+zXwpB7jMK0TKfNt2XMuWU6s32baXT M5dpQs7np5lCkFl7KFyz6AZtz5l8f1pW3PevMDILmqDiljFAXCYzG6GZ4AaB9s5c ikyrnRKreMdFLNR62pOCb5B8PAUBkT4BA5q2Yzfjo8oPX325zdsIlIOLvGDL8E2B 28vzm0MCbnwiimCb8GlddjjpLWMjNe/SU4YeSOUxK0/zr902+X3ooJPmDtDnC5rs I5Kdfh7H9wWPbOcZhfYGL/pNZHIfIErY17qpNyv+s3YJNh/Be5dXG3QBbTcLH5xV sK65AQ0EWuaeGAEIAL3piiswJOJQHNtTbdwSc0xzTm/iPfpZUyobcSSZpVzOZUPQ D3ULlx/5RGO6cdwq+8Tz/OR+mUJHCJSxOnI+/PWMs+3ZyKPMIlhC9Khq3RiWHPQt aRD7USRSWXWwZH6JVCCFpMnhnnHfY+eJzlZC7G8nCJzUk15s/3425HTRlavfRaf7 S6i28wQ98AEUBTITOx3mesnKF7oprZX89El/ToplC0QGRNJj7ZPPNw3QAC244u7B ExKiZKSWjDpcLANB6ORQv1eriy/VuIg/dDwwVIi9pR561tmqbVM7QeIsg52QpY63 ctyHa2CrCyBt4ceR5mqJLuAWow7xmZWrT2+LA2cAEQEAAYkBJQQYAQoADwUCWuae GAIbDAUJCWaEyAAKCRAiRt+oCUWlvQL2B/9gcSBhf0FwAmVUVM/OFe1yww38i/xA IMUI5rPO8bKh5i3uOVZx7QucY9xPctu4YkCI8SgWLfOnQJtNbjbvduSVlWMjlmGW 9qDOpjiFX95AFlUboZ5ii4hxAetFjCOqpMamd6DAFP7ojIbrOE3chN8axqOe4Lx0 Ydsi20b25qT+IRAoIFWker14PHoAo8Xh+JgQ7tCijS8FzLpLZh/K99qhCz32FMIH 5cMPQTI3EPCo+08tWpkjC/a/vtm/Q9/55+5mbdwRVpWfmQ1X0881PybvGqQbmfrT tnRmtnBe0ZSQ8P79bMq+OQMVdrCDTUEp3JqFgH1z2yd4BIeEKN69fy6Q =iGxZ -----END PGP PUBLIC KEY BLOCK----- 2. Incident response \u00b6 Researcher submits report via PGP encrypted Email to the relevant Disclosure manger (DA), use the appropriate public keys listed in section 1 to contact specific DA\u2019s, the subject of the email should be \u201cVulnerability disclosure\u201d In no more than 3 working days, the DA should respond to the researcher using encrypted, secure channels DA makes inquiries to satisfy any needed information to confirm if submission is indeed a vulnerability a. If submission proves to be vulnerable with PoC code / exploit, proceed to next step b. If not vulnerable: i. DA responds with reasons why submission is not a vulnerability ii. DA moves discussion to a new or existing ticket on GitHub if necessary DA Establishes severity of vulnerability: a. HIGH: impacts network as a whole, has potential to break entire Loki network, or service nodes, could result in the loss of Loki. b. MEDIUM: impacts individual nodes, routers, wallets, or must be carefully exploited c. LOW: is not easily exploitable or is low impact d. If there are any disputes regarding bug severity, the Loki Foundation will ultimately define bug severity Respond according to the severity of the vulnerability: a. HIGH severities must be notified on website and reddit /r/LokiProject within 3 working days of classification i. The notification should list appropriate steps for users to take, if any ii. The notification must not include any details that could suggest an exploitation path iii. The latter takes precedence over the former b. MEDIUM and HIGH severities will require a Point Release c. LOW severities will be addressed in the next Regular Release DA and Loki project team will apply appropriate patch(es) a. DA designates a PRIVATE git \"hotfix branch\" to work in b. Patches are reviewed with the researcher c. Any messages associated with PUBLIC commits during the time of review should not make reference to the security nature of the PRIVATE branch or its commits d. Vulnerability announcement is drafted i. Include the severity of the vulnerability ii. Include all vulnerable systems/apps/code iii. Include solutions (if any) if patch cannot be applied e. Release date is discussed At release date, DA coordinates with developers to finalize update: a. Response Manager propagates the \"hotfix branch\" to trunk b. Response Manager includes vulnerability announcement draft in release notes c. Proceed with the Point or Regular Release 3. Post-release disclosure process \u00b6 The DA has 90 days to fulfill all points within section 2 If the Incident Response process in section 2 is successfully completed: a. Researcher decides whether or not to opt out of receiving name/handle/organization credit. By default, the researcher will receive name/handle/organization credit. i. If bounty is applicable, release bounty to the researcher as defined in section \"Bounty Distribution\" b. Finalize vulnerability announcement draft and include the following: i. Project name and URL ii. Versions known to be affected iii. Versions known to be not affected (for example, the vulnerable code was introduced in a recent version, and older versions are therefore unaffected) iv. Versions not checked v. Type of vulnerability and its impact vi. If already obtained or applicable, a CVE-ID vii. The planned, coordinated release date viii. Mitigating factors (for example, the vulnerability is only exposed in uncommon, non-default configurations) ix. Workarounds (configuration changes users can make to reduce their exposure to the vulnerability) x. If applicable, credits to the original reporter c. Release finalized vulnerability announcement on website and reddit e. If applicable, developers request a CVE-ID i. The commit that applied the fix is made reference too in a future commit and includes a CVE-ID If the Incident Response process in section 2 is not successfully completed: a. DA and developers organize a meeting to discuss why/what points in section 2 were not resolved and how the team can resolve them in the future c. If disputes arise about whether or when to disclose information about a vulnerability, the DA will publicly discuss the issue via IRC and attempt to reach consensus d. If consensus on a timely disclosure is not met (no later than 90 days), the researcher (after 90 days) has every right to expose the vulnerability to the public 4. Bounty Amount and distribution \u00b6 The Total Pool of Loki bounties is 100,000 LOK this will decrease over time as bugs are claimed, rewards are given as a percentage of the reward pool size, incentivizing fast disclosure Bug bounties are rewarded by the severity of the Bug 10% reserved for LOW severity bugs 30% reserved for MEDIUM severity bugs 60% for HIGH severity bugs Each bug will receive at most 10% of their relevant category dependent on the inter-category classification by the DA","title":"Vulnerability Response"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#vulnerability-disclosure-loki","text":"This Vulnerability Response Process and subsequent bounty reward apply to the following: Code implementation as seen in the Loki repository which sits underneath the Loki-Project Written research from the Loki Team which dictates said code implementation Researchers/Hackers: while you research/hack, we ask that you please refrain from committing the following: Denial of Service / Active exploiting against the Loki mainnet, Runechain or Service node networks Social Engineering of Loki staff, contractors or Foundation members Any physical or electronic attempts against Loki community property and/or data centers As a pro-privacy project we have volunteers running copies of the websites on hidden services on Tor and I2P, as well as on multiple public domains. The live sites are NOT in the scope of this process; only the code is! Bounty will be released for all projects in Loki (LOK) only. For more information on how to use Loki, visit the Loki website Bounty is not eligible to those who: do not abide by the VRP for responsible disclosure","title":"Vulnerability disclosure Loki"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#1-points-of-contact-for-security-issues","text":"Kee [at] Loki.network PGP fingerprint = 8877 EEBB 9721 ABC5 DF64 9AE4 AC97 1489 5CE4 5D55 -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrbANQBCAC5HMKeapz+WECQ3vY1XuSOM32yUfzp4V/rY5+YvJ/Gb7wxczF2 NTLxfr7ueJTyICXcj/h7qnvdtpbN87ZhjWTZzG0lmrCIfZX75dOQIjch8DkGblEB RUG90edRx4GwYHPjfIUbIxYHcINKYMgH9jKqfHAVQD7HuvkBX1IYbNi/Kgj0wVgJ vVA94x8JCD5blqGbos7r02bZxQHujAHnC19/PQxRyZwJNI0v1xJgy6w/cQduFLzL GeEnkQfmJiSKEYzRLY3BYRSmysqD0bLGWLLSa1fcxAD+kllY1kSZXpHKH1XmErpi pRCLblQs0kZYqHDKG2gscfpuaaM4fSiGmY8nABEBAAG0H0tlZSBKZWZmZXJ5cyA8 S2VlQGxva2kubmV0d29yaz6JATwEEwEKACYFAlrbANQCGwMFCQlmRIwFCwkIBwMF FQoJCAsEFgIBAAIeAQIXgAAKCRCslxSJXORdVa7zCACAw7eEYcXlZXxXOB43TSKq BTBtqISmu0+Me94PXNGo5XOp0gzVhgXPedbuz58Y1g9aCp0/wwg5cZvh6ky8zwgt q2BtayTb36elUkcejo9IdgN+1Ruzr8bUdWQrw7w/sZGgI3ZaoMlHvm7mus1cqKH4 3gKaBYG/zPG25hgne13j365kxi+xgklvo0lL3atHV61UxdTlgDm2s4ZtfrMeV9fY DRwcIjzyYv3HWAJvD60dN1RHzTCBxiMiyl6HLawh/3dpHVDOAdrIGqHfIbzodVLW SA4JLw8at3JA8ColWkyFQj1srxvJJunT+haH32h2g9rNS/lf5z+Mdv+LfIPv/iZ5 uQENBFrbANQBCAC+4N/f+RZ8jYHW6VLPGT8nspuEyEgE++zab5XOkS8qcnP0e2sR F0G1RLlJr6hfaowEqLOO0CTIguOBpRfeTWLHzSUK+w8pFx2GfvxXAyxViNbsA5/U E4gbDgOu8AkZWOQLK0nPnE0eyBhHCz22yTJY7P5AUcbo2jw9q9Ye78GbTQx8JPXl jia/VZprMILFOGQROGkH1amqDcaNuX6iOMKS6GtyP+eElPj+IWqwMUlr9aX+ptBQ zfsw+KzgYC+RBS44SM98ZgNBEibZXKfQMT2t80riKgRUPTBQcOref9T+jAtfZl1A OAKm0tLc3o0n0WvmjvxxOOfzdpvEDya12e4VABEBAAGJASUEGAEKAA8FAlrbANQC GwwFCQlmRIwACgkQrJcUiVzkXVWaNQf8C0oYU0iN3YuA+AXGxBlfMHlxz4xhbbd7 Fn8EOIxi3scOltYeU/WvdSdXZ4IJEjydPo7TmVrQ746MUfLC+6ZfH9EDP322s+T/ TYbt3oNA0RWl2CxakpIlRKgCIuC6EEc1U32nKsXH3Uz7UVx8u9GrDxSvGhTSVppN k3nhtcWeSBtANrWuhei1MC4+bRdHHExf6kHtdDMNsuwJmG3FtlKoP9l/Vpb3KscX 9FqdEYPrJSNk3QrndS/a9QzWsm4PR0LTp2+2WC2cDgFjPUqZqZVLA5hSutUVTzGG fKg1gFLyG7Ed4fSa25pe5nUSJUCjFy1HprSM+I9IsSxc8sDll60a3Q== =iX6u -----END PGP PUBLIC KEY BLOCK----- Simon [at] Loki.network PGP fingerprint = 45FF F23B 7805 CEC7 7C7E 15F6 2246 DFA8 0945 A5BD -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1 mQENBFrmnhgBCAC3LWatVxk3QWV7V42B++En8l3xDeQ3uAaXwRot98/4ybImAwmc ur4YCuLBXBiyZPrUQ8m6DxGG9a2RaNll+2dEkaxjDxIJsM7Op+2nUxlDBGrSS3Cf p40BxM4pDBDe1j9haSdoamujYpUDCpYTLA1npKiCUncITsmc+ivefkXBskgh66eI f69yEdeN7dvAqOWaaogBKucQfk9Si3MDXTAqm+hJbR1ByHBw/C0yXfNuq46mEVn6 Tu25cquQPIfYebXldJ4MDD5vogzPJqjMH5Kna/24PqKiR9KpI8NYjUbiRlhuJj2q SjOvks9bJ4Qf+yp7o7qA41TCecsVxdciqtnJABEBAAG0IVNpbW9uIEhhcm1hbiA8 c2ltb25AbG9raS5uZXR3b3JrPokBPAQTAQoAJgUCWuaeGAIbAwUJCWaEyAULCQgH AwUVCgkICwQWAgEAAh4BAheAAAoJECJG36gJRaW9G9QH+gLTCoILegkdJDqGvjsK r7eeD4jxuuRWcWohf+g/Xt9WUR4vOYdUY5+zXwpB7jMK0TKfNt2XMuWU6s32baXT M5dpQs7np5lCkFl7KFyz6AZtz5l8f1pW3PevMDILmqDiljFAXCYzG6GZ4AaB9s5c ikyrnRKreMdFLNR62pOCb5B8PAUBkT4BA5q2Yzfjo8oPX325zdsIlIOLvGDL8E2B 28vzm0MCbnwiimCb8GlddjjpLWMjNe/SU4YeSOUxK0/zr902+X3ooJPmDtDnC5rs I5Kdfh7H9wWPbOcZhfYGL/pNZHIfIErY17qpNyv+s3YJNh/Be5dXG3QBbTcLH5xV sK65AQ0EWuaeGAEIAL3piiswJOJQHNtTbdwSc0xzTm/iPfpZUyobcSSZpVzOZUPQ D3ULlx/5RGO6cdwq+8Tz/OR+mUJHCJSxOnI+/PWMs+3ZyKPMIlhC9Khq3RiWHPQt aRD7USRSWXWwZH6JVCCFpMnhnnHfY+eJzlZC7G8nCJzUk15s/3425HTRlavfRaf7 S6i28wQ98AEUBTITOx3mesnKF7oprZX89El/ToplC0QGRNJj7ZPPNw3QAC244u7B ExKiZKSWjDpcLANB6ORQv1eriy/VuIg/dDwwVIi9pR561tmqbVM7QeIsg52QpY63 ctyHa2CrCyBt4ceR5mqJLuAWow7xmZWrT2+LA2cAEQEAAYkBJQQYAQoADwUCWuae GAIbDAUJCWaEyAAKCRAiRt+oCUWlvQL2B/9gcSBhf0FwAmVUVM/OFe1yww38i/xA IMUI5rPO8bKh5i3uOVZx7QucY9xPctu4YkCI8SgWLfOnQJtNbjbvduSVlWMjlmGW 9qDOpjiFX95AFlUboZ5ii4hxAetFjCOqpMamd6DAFP7ojIbrOE3chN8axqOe4Lx0 Ydsi20b25qT+IRAoIFWker14PHoAo8Xh+JgQ7tCijS8FzLpLZh/K99qhCz32FMIH 5cMPQTI3EPCo+08tWpkjC/a/vtm/Q9/55+5mbdwRVpWfmQ1X0881PybvGqQbmfrT tnRmtnBe0ZSQ8P79bMq+OQMVdrCDTUEp3JqFgH1z2yd4BIeEKN69fy6Q =iGxZ -----END PGP PUBLIC KEY BLOCK-----","title":"1. Points of contact for security issues"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#2-incident-response","text":"Researcher submits report via PGP encrypted Email to the relevant Disclosure manger (DA), use the appropriate public keys listed in section 1 to contact specific DA\u2019s, the subject of the email should be \u201cVulnerability disclosure\u201d In no more than 3 working days, the DA should respond to the researcher using encrypted, secure channels DA makes inquiries to satisfy any needed information to confirm if submission is indeed a vulnerability a. If submission proves to be vulnerable with PoC code / exploit, proceed to next step b. If not vulnerable: i. DA responds with reasons why submission is not a vulnerability ii. DA moves discussion to a new or existing ticket on GitHub if necessary DA Establishes severity of vulnerability: a. HIGH: impacts network as a whole, has potential to break entire Loki network, or service nodes, could result in the loss of Loki. b. MEDIUM: impacts individual nodes, routers, wallets, or must be carefully exploited c. LOW: is not easily exploitable or is low impact d. If there are any disputes regarding bug severity, the Loki Foundation will ultimately define bug severity Respond according to the severity of the vulnerability: a. HIGH severities must be notified on website and reddit /r/LokiProject within 3 working days of classification i. The notification should list appropriate steps for users to take, if any ii. The notification must not include any details that could suggest an exploitation path iii. The latter takes precedence over the former b. MEDIUM and HIGH severities will require a Point Release c. LOW severities will be addressed in the next Regular Release DA and Loki project team will apply appropriate patch(es) a. DA designates a PRIVATE git \"hotfix branch\" to work in b. Patches are reviewed with the researcher c. Any messages associated with PUBLIC commits during the time of review should not make reference to the security nature of the PRIVATE branch or its commits d. Vulnerability announcement is drafted i. Include the severity of the vulnerability ii. Include all vulnerable systems/apps/code iii. Include solutions (if any) if patch cannot be applied e. Release date is discussed At release date, DA coordinates with developers to finalize update: a. Response Manager propagates the \"hotfix branch\" to trunk b. Response Manager includes vulnerability announcement draft in release notes c. Proceed with the Point or Regular Release","title":"2. Incident response"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#3-post-release-disclosure-process","text":"The DA has 90 days to fulfill all points within section 2 If the Incident Response process in section 2 is successfully completed: a. Researcher decides whether or not to opt out of receiving name/handle/organization credit. By default, the researcher will receive name/handle/organization credit. i. If bounty is applicable, release bounty to the researcher as defined in section \"Bounty Distribution\" b. Finalize vulnerability announcement draft and include the following: i. Project name and URL ii. Versions known to be affected iii. Versions known to be not affected (for example, the vulnerable code was introduced in a recent version, and older versions are therefore unaffected) iv. Versions not checked v. Type of vulnerability and its impact vi. If already obtained or applicable, a CVE-ID vii. The planned, coordinated release date viii. Mitigating factors (for example, the vulnerability is only exposed in uncommon, non-default configurations) ix. Workarounds (configuration changes users can make to reduce their exposure to the vulnerability) x. If applicable, credits to the original reporter c. Release finalized vulnerability announcement on website and reddit e. If applicable, developers request a CVE-ID i. The commit that applied the fix is made reference too in a future commit and includes a CVE-ID If the Incident Response process in section 2 is not successfully completed: a. DA and developers organize a meeting to discuss why/what points in section 2 were not resolved and how the team can resolve them in the future c. If disputes arise about whether or when to disclose information about a vulnerability, the DA will publicly discuss the issue via IRC and attempt to reach consensus d. If consensus on a timely disclosure is not met (no later than 90 days), the researcher (after 90 days) has every right to expose the vulnerability to the public","title":"3. Post-release disclosure process"},{"location":"Contributing/VULNERABILITY_RESPONSE_LOKI/#4-bounty-amount-and-distribution","text":"The Total Pool of Loki bounties is 100,000 LOK this will decrease over time as bugs are claimed, rewards are given as a percentage of the reward pool size, incentivizing fast disclosure Bug bounties are rewarded by the severity of the Bug 10% reserved for LOW severity bugs 30% reserved for MEDIUM severity bugs 60% for HIGH severity bugs Each bug will receive at most 10% of their relevant category dependent on the inter-category classification by the DA","title":"4. Bounty Amount and distribution"},{"location":"Introduction/BeginnersGuide/","text":"Beginners Guide \u00b6 TO DO","title":"Where to begin?"},{"location":"Introduction/BeginnersGuide/#beginners-guide","text":"TO DO","title":"Beginners Guide"},{"location":"Introduction/Overview/","text":"Overview \u00b6 Wallets \u00b6 The Loki wallets offer a gateway to private decentralised transactions and communications. It allows you to hold and secure Loki, mine and trade peer-to-peer. Download the official Loki wallet today and start taking back control of your online privacy. Web Wallet : The quickest way to access a Loki Wallet is through a web based wallet, Loki Locker . Graphical User Interface Wallet (GUI) : The Gui Wallet is just as easy to use however requires you to download the latest release from Loki Projects Github . Command Line Interface Wallet (CLI) : The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain... and feels the most badass. Mining \u00b6 TO DO Service Nodes \u00b6 The Loki cryptocurrency creates a network of Service Nodes who are paid to propagate the blockchain, process transactions, and route traffic and messages on LokiNET . The following are useful guides or resources for Service Nodes : Service Node Portal : Loki's official Service Node Portal. Full Guide : How to setup a Service Node using the CLI Wallet. Setup Video Guide : Video Guide on how to setup a Service Node using the CLI Wallet. Reward Calculator OSX : Service Node reward calculator for OSX. Reward Calculator Windows : Service Node reward calculator for Windows. Staking Requirement Calculator WEB : Webpage showing Staking Requirement at current Block Height. LokiNET \u00b6 LokiNET is a new type of mixnet that uses market-based Sybil attack resistance and onion routing to create a new private tunnel to the internet. Users of Lokinet will be able to access normal websites and SNApps without revealing their IP address. SNApps are traditional web applications that sit inside LokiNET . As the host\u2019s IP is never revealed, this provides great protection for the development of censorship resistant social media, marketplaces, information sharing sites, and other apps that depend on user and server anonymity. The following are useful guides or resources for LokiNET : Setting Up A SNApp : How to host a hidden service the right way. Setting Up A TestNet Relay : How to host a relay on the test network. Developer Info : Protocol Specifications. Advanced \u00b6 TO DO FAQ \u00b6 TO DO Contributing \u00b6 TO DO About \u00b6 TO DO","title":"Overview"},{"location":"Introduction/Overview/#overview","text":"","title":"Overview"},{"location":"Introduction/Overview/#wallets","text":"The Loki wallets offer a gateway to private decentralised transactions and communications. It allows you to hold and secure Loki, mine and trade peer-to-peer. Download the official Loki wallet today and start taking back control of your online privacy. Web Wallet : The quickest way to access a Loki Wallet is through a web based wallet, Loki Locker . Graphical User Interface Wallet (GUI) : The Gui Wallet is just as easy to use however requires you to download the latest release from Loki Projects Github . Command Line Interface Wallet (CLI) : The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain... and feels the most badass.","title":"Wallets"},{"location":"Introduction/Overview/#mining","text":"TO DO","title":"Mining"},{"location":"Introduction/Overview/#service-nodes","text":"The Loki cryptocurrency creates a network of Service Nodes who are paid to propagate the blockchain, process transactions, and route traffic and messages on LokiNET . The following are useful guides or resources for Service Nodes : Service Node Portal : Loki's official Service Node Portal. Full Guide : How to setup a Service Node using the CLI Wallet. Setup Video Guide : Video Guide on how to setup a Service Node using the CLI Wallet. Reward Calculator OSX : Service Node reward calculator for OSX. Reward Calculator Windows : Service Node reward calculator for Windows. Staking Requirement Calculator WEB : Webpage showing Staking Requirement at current Block Height.","title":"Service Nodes"},{"location":"Introduction/Overview/#lokinet","text":"LokiNET is a new type of mixnet that uses market-based Sybil attack resistance and onion routing to create a new private tunnel to the internet. Users of Lokinet will be able to access normal websites and SNApps without revealing their IP address. SNApps are traditional web applications that sit inside LokiNET . As the host\u2019s IP is never revealed, this provides great protection for the development of censorship resistant social media, marketplaces, information sharing sites, and other apps that depend on user and server anonymity. The following are useful guides or resources for LokiNET : Setting Up A SNApp : How to host a hidden service the right way. Setting Up A TestNet Relay : How to host a relay on the test network. Developer Info : Protocol Specifications.","title":"LokiNET"},{"location":"Introduction/Overview/#advanced","text":"TO DO","title":"Advanced"},{"location":"Introduction/Overview/#faq","text":"TO DO","title":"FAQ"},{"location":"Introduction/Overview/#contributing","text":"TO DO","title":"Contributing"},{"location":"Introduction/Overview/#about","text":"TO DO","title":"About"},{"location":"LokiNET/DeveloperInfo/","text":"Developer Info \u00b6 DHT entities \u00b6 Intro : Router Identity Key + Path ID + expiration timestamp + extra metadata, advertised by a hidden service as a middle point for communication. Introset : A set of intros and related metadata signed by the hidden service's public signing key , used to advertise how to access a hidden service to the LokiNET DHT. Link Layer entities \u00b6 Router Contact : self signed metadata associated with a Service Node, includes public key address of a SN (Service Node), and AddressInfos Address Info : // TODO Exit Info : // TODO","title":"Developers"},{"location":"LokiNET/DeveloperInfo/#developer-info","text":"","title":"Developer Info"},{"location":"LokiNET/DeveloperInfo/#dht-entities","text":"Intro : Router Identity Key + Path ID + expiration timestamp + extra metadata, advertised by a hidden service as a middle point for communication. Introset : A set of intros and related metadata signed by the hidden service's public signing key , used to advertise how to access a hidden service to the LokiNET DHT.","title":"DHT entities"},{"location":"LokiNET/DeveloperInfo/#link-layer-entities","text":"Router Contact : self signed metadata associated with a Service Node, includes public key address of a SN (Service Node), and AddressInfos Address Info : // TODO Exit Info : // TODO","title":"Link Layer entities"},{"location":"LokiNET/LLARP/","text":"Low Latency Anonymous Routing Protocol (LLARP) \u00b6 Underlying all applications for Service Nodes is an anonymous routing protocol, which defines the way each Service Node communicates with its peers. Loki proposes a new routing protocol called LLARP which is designed as a hybrid between Tor and I2P to provide additional desirable properties versus any existing routing protocol. LLARP is built specifically to run on top of the Loki Service Nodes network and all LLARP optimisations consider this architecture. To understand the goals of LLARP, it is best to conduct an analysis of existing routing protocols and consider how LLARP improves upon them. LLARP operates without the need to make use of directory authorities and, instead, relies on a DHT built from blockchain staking transactions, which allows Service Nodes to act as routers in the network. Bandwidth is not monitored or recorded in the DHT. Instead, bandwidth measurement and triage result from swarms that assess each node and make a judgement on the nodes ability to provide appropriate bandwidth to the network. In the Open Systems Interconnection model (OSI model), LLARP only attempts to provide an anonymous network layer. This means that it supports a larger range of internet protocols and it also minimises the overhead for storing file descriptors should exit nodes pass through User Datagram Protocol (UDP) traffic. Additionally, LLARP opts for packet-switched based routing instead of tunnel-based routing, allowing for better load balancing and redundancy across the network. End users of Lokinet are not expected (or even allowed) to route packets, this means that Lokinet exposes itself to a much lower attack surface for a Sybil attack due to the significant capital outlay required to begin Service Nodes operation. The Onion Router (Tor) \u00b6 In recent years, Tor has been the most popular anonymous mixnet. The Tor network maintains a high-level of censorship resistance and has proved a valuable tool for preserving internet privacy. However,Tor is not a decentralised network as much as it is a hierarchical one. Tor is reliant on a group of directory authorities which are centralised servers operated by a group of volunteers close to the Tor Foundation . These directory authorities perform two main functions. Firstly, they act as trusted reporters on the state of nodes in the network. When a Tor user (or relay) connects to the network for the first time they can connect to one of ten hard-coded directory authorities. These directory authorities provide the user or relay with a file called the consensus. This file provides a list of all of the relays, guard nodes, and exit nodes currently in operation (excluding bridges) on the Tor network. Secondly, the directory authorities also measure the bandwidth that each relay can provide to the network. They use this information to triage relays into categories, deciding whether nodes can operate as relays, guard nodes, or exit nodes. This high level of centralisation creates points of failure that leaves Tor vulnerable. In 2014, Tor received information of a credible threat to take down the directory authority servers . If the directory authorities in the United States and either Germany or the Netherlands were to be shut down, that would be enough to shut down five of the ten directory authority servers. This would result in a highly unstable Tor network, with new relays being greatly diminished in their ability to interact with the network. Methods of communication in Tor are also limited, as Tor only allows communication overTCP. IP over Tor is possible, but it lacks support for UDP based protocols (such as VoIP). Invisible Internet Project (I2P) \u00b6 I2P takes a different approach to mixnet architecture, maintaining a higher level of trust agility by referring to a Distributed Hashing Table (DHT) to ascertain the network state instead of trusted directory authorities [15]. I2P also allows for both TCP and UDP traffic, supporting a larger scope of protocol interactions. However, I2P has not had a steady development process and over time it has accumulated technical debt, specifically in its cryptography usage. I2P uses 2048 bit ElGamal, which makes encryption and decryption slow in contrast to elliptic curve operations. While plans to migrate away from ElGamal exist in the I2P roadmap, progress has been slow. Additionally, I2P lacks formal support for exit nodes, meaning the majority of traffic on the network is accessing internally hosted websites, called Eepsites. This has greatly reduced the ability for the I2P network to reach users whose main purpose for using anonymising networks is to access the wider internet. Furthermore, the manner in which I2P is built means that the majority of users that connect to the network also become routers, which is problematic as the resulting network often lacks sufficient bandwidth to be able to build fast paths. Network speeds in mixnets are bottlenecked by the least capable node in each circuit, and as a result of low-performance users becoming relays in I2P, a reduction in overall performance is seen. Finally, I2P differs from Tor in that it offers a packet-switched (rather than circuit-switched) network. Instead of establishing a single longer-term tunnel which all traffic travels through, I2P establishes multiple paths that each packet being communicated can use to use to take a different route through the network. This gives I2P the ability to transparently route around network congestion and node failures. Both I2P and Tor have not fully mitigated Sybil attacks. A sufficiently motivated attacker that has enough time and capital to buy large amounts of relays can perform temporal analysis which undermines user privacy. The effectiveness of this analysis increases the more exit nodes, relays and guard nodes the attacker operates . Tor and I2P are operated entirely by volunteers that donate both their time and money to the operation of nodes. We surmise that a network constructed from financial incentives rather than altruism can achieve a greater resilience against attacks, while providing a more reliable service.","title":"LLARP"},{"location":"LokiNET/LLARP/#low-latency-anonymous-routing-protocol-llarp","text":"Underlying all applications for Service Nodes is an anonymous routing protocol, which defines the way each Service Node communicates with its peers. Loki proposes a new routing protocol called LLARP which is designed as a hybrid between Tor and I2P to provide additional desirable properties versus any existing routing protocol. LLARP is built specifically to run on top of the Loki Service Nodes network and all LLARP optimisations consider this architecture. To understand the goals of LLARP, it is best to conduct an analysis of existing routing protocols and consider how LLARP improves upon them. LLARP operates without the need to make use of directory authorities and, instead, relies on a DHT built from blockchain staking transactions, which allows Service Nodes to act as routers in the network. Bandwidth is not monitored or recorded in the DHT. Instead, bandwidth measurement and triage result from swarms that assess each node and make a judgement on the nodes ability to provide appropriate bandwidth to the network. In the Open Systems Interconnection model (OSI model), LLARP only attempts to provide an anonymous network layer. This means that it supports a larger range of internet protocols and it also minimises the overhead for storing file descriptors should exit nodes pass through User Datagram Protocol (UDP) traffic. Additionally, LLARP opts for packet-switched based routing instead of tunnel-based routing, allowing for better load balancing and redundancy across the network. End users of Lokinet are not expected (or even allowed) to route packets, this means that Lokinet exposes itself to a much lower attack surface for a Sybil attack due to the significant capital outlay required to begin Service Nodes operation.","title":"Low Latency Anonymous Routing Protocol (LLARP)"},{"location":"LokiNET/LLARP/#the-onion-router-tor","text":"In recent years, Tor has been the most popular anonymous mixnet. The Tor network maintains a high-level of censorship resistance and has proved a valuable tool for preserving internet privacy. However,Tor is not a decentralised network as much as it is a hierarchical one. Tor is reliant on a group of directory authorities which are centralised servers operated by a group of volunteers close to the Tor Foundation . These directory authorities perform two main functions. Firstly, they act as trusted reporters on the state of nodes in the network. When a Tor user (or relay) connects to the network for the first time they can connect to one of ten hard-coded directory authorities. These directory authorities provide the user or relay with a file called the consensus. This file provides a list of all of the relays, guard nodes, and exit nodes currently in operation (excluding bridges) on the Tor network. Secondly, the directory authorities also measure the bandwidth that each relay can provide to the network. They use this information to triage relays into categories, deciding whether nodes can operate as relays, guard nodes, or exit nodes. This high level of centralisation creates points of failure that leaves Tor vulnerable. In 2014, Tor received information of a credible threat to take down the directory authority servers . If the directory authorities in the United States and either Germany or the Netherlands were to be shut down, that would be enough to shut down five of the ten directory authority servers. This would result in a highly unstable Tor network, with new relays being greatly diminished in their ability to interact with the network. Methods of communication in Tor are also limited, as Tor only allows communication overTCP. IP over Tor is possible, but it lacks support for UDP based protocols (such as VoIP).","title":"The Onion Router (Tor)"},{"location":"LokiNET/LLARP/#invisible-internet-project-i2p","text":"I2P takes a different approach to mixnet architecture, maintaining a higher level of trust agility by referring to a Distributed Hashing Table (DHT) to ascertain the network state instead of trusted directory authorities [15]. I2P also allows for both TCP and UDP traffic, supporting a larger scope of protocol interactions. However, I2P has not had a steady development process and over time it has accumulated technical debt, specifically in its cryptography usage. I2P uses 2048 bit ElGamal, which makes encryption and decryption slow in contrast to elliptic curve operations. While plans to migrate away from ElGamal exist in the I2P roadmap, progress has been slow. Additionally, I2P lacks formal support for exit nodes, meaning the majority of traffic on the network is accessing internally hosted websites, called Eepsites. This has greatly reduced the ability for the I2P network to reach users whose main purpose for using anonymising networks is to access the wider internet. Furthermore, the manner in which I2P is built means that the majority of users that connect to the network also become routers, which is problematic as the resulting network often lacks sufficient bandwidth to be able to build fast paths. Network speeds in mixnets are bottlenecked by the least capable node in each circuit, and as a result of low-performance users becoming relays in I2P, a reduction in overall performance is seen. Finally, I2P differs from Tor in that it offers a packet-switched (rather than circuit-switched) network. Instead of establishing a single longer-term tunnel which all traffic travels through, I2P establishes multiple paths that each packet being communicated can use to use to take a different route through the network. This gives I2P the ability to transparently route around network congestion and node failures. Both I2P and Tor have not fully mitigated Sybil attacks. A sufficiently motivated attacker that has enough time and capital to buy large amounts of relays can perform temporal analysis which undermines user privacy. The effectiveness of this analysis increases the more exit nodes, relays and guard nodes the attacker operates . Tor and I2P are operated entirely by volunteers that donate both their time and money to the operation of nodes. We surmise that a network constructed from financial incentives rather than altruism can achieve a greater resilience against attacks, while providing a more reliable service.","title":"Invisible Internet Project (I2P)"},{"location":"LokiNET/LokiNetOverview/","text":"LokiNET Overview \u00b6 Onion routing protocols allow for users to form tunnels or paths through a distributed network, using multiple nodes as hops to obfuscate the destination and origin of data packets. Service Nodes on the Loki network will operate a low latency onion routing protocol, forming a fully decentralised overlay network, called Lokinet. The network does not rely on trusted authorities and its state is fully derived from the blockchain. Users can connect to individual Service Nodes and create bidirectional paths for packets to be routed through. The network can be used to access internally hosted services called SNApps . Users can utilise Service Nodes exit functionality to browse the external internet without their IP address being exposed. Terms \u00b6 Service Node : Full nodes on the Loki Network. SNApps/Hidden Services : An anonymized IP endpoint. LLARP : Low Latency Anonymous Routing Protocol. Guides \u00b6 Setting Up A SNApp : How to host a hidden service the right way. Setting Up A TestNet Relay : How to host a relay on the test network. Developer Info : Protocol Specifications. Concepts \u00b6 Path : Bidirection Onion Routing Construct, (I2P tunnel / Tor circuit equiv.)","title":"Overview"},{"location":"LokiNET/LokiNetOverview/#lokinet-overview","text":"Onion routing protocols allow for users to form tunnels or paths through a distributed network, using multiple nodes as hops to obfuscate the destination and origin of data packets. Service Nodes on the Loki network will operate a low latency onion routing protocol, forming a fully decentralised overlay network, called Lokinet. The network does not rely on trusted authorities and its state is fully derived from the blockchain. Users can connect to individual Service Nodes and create bidirectional paths for packets to be routed through. The network can be used to access internally hosted services called SNApps . Users can utilise Service Nodes exit functionality to browse the external internet without their IP address being exposed.","title":"LokiNET Overview"},{"location":"LokiNET/LokiNetOverview/#terms","text":"Service Node : Full nodes on the Loki Network. SNApps/Hidden Services : An anonymized IP endpoint. LLARP : Low Latency Anonymous Routing Protocol.","title":"Terms"},{"location":"LokiNET/LokiNetOverview/#guides","text":"Setting Up A SNApp : How to host a hidden service the right way. Setting Up A TestNet Relay : How to host a relay on the test network. Developer Info : Protocol Specifications.","title":"Guides"},{"location":"LokiNET/LokiNetOverview/#concepts","text":"Path : Bidirection Onion Routing Construct, (I2P tunnel / Tor circuit equiv.)","title":"Concepts"},{"location":"LokiNET/Messenger/","text":"Loki Messenger \u00b6 The first Loki service to be developed and deployed on the Loki network will be a decentralised, end-to-end encrypted private messaging application called Loki Messenger. End-to-end encrypted messaging applications that provide a platform for users to send messages without revealing their contents already exist, however they rely on centralised servers that can be targeted, blocked and shut down. These centralised service models present a high-risk for the anonymity of communicating parties, as they often require the user to register a phone number or other identifying information and connect directly via the IP address of the user. This information could be extracted from servers through data leaks or legal processes and used against the user. Leveraging the Service Nodes architecture on the Loki network, we can deliver a service similar to popular centralised encrypted messaging apps, such as Signal, with a higher degree of privacy and censorship resistance. Messenger Routing \u00b6 Message routing on the Loki network changes depending on whether the receiving user is online or offline. When both users are online, higher bandwidth communications can take place due to the fact that messages do not need to be stored on the Service Nodes . In Loki, a public key acts both as long-term encryption key and a routing address. In the most simple case, this key should be exchanged out-of-band to ensure protection against a man-in-the-middle attack. Such an exchange should take place either in person or through another secure mode of exchange. Online Messaging \u00b6 Once Alice knows Bobs public key, she assumes he is online and tries to create a path to him. Alice does this by querying the DHT of any Service Node and obtains any introduction set that corresponds with Bobs public key. In LLARP, introduction sets list the introducers that each user maintains. It is through these introducers that paths can be established. With Bobs introducer, Alice now chooses three random Service Nodes to act as intermediary hops between her origin and her destination (Bobs introducer). A path has now been established, through which Alice and Bob can transmit messages. If correctly authenticated, and using OTR , Alice and Bob can now communicate while maintaining a high-level of privacy. Offline Messaging \u00b6 If Alice fails to receive a response from Bob, she can then initiate the offline messaging process. Offline routing uses a modified version of Postal Services over Swarm (PSS) . Swarms are logical groupings of Service Nodes , based both on their public keys and the hash of the block that their staking transaction first appeared in. Each swarm has a swarmID and consists of nine nodes. To send a message to Bob, Alice can use his public key to calculate which swarm Bob belongs to. With this information, Alice can anonymously route a message through the network to a random Service Nodes in that swarm. When a Service Nodes receives a unique message destined for its swarm, it must distribute that message to the other eight nodes in the swarm. All nodes are additionally required to store messages for their allocated Time-to-live (TTL). When Bob comes online, he can query any two nodes in his swarm for messages he can decrypt. Offline messaging is protected from spamming with a small proof-of-work that is attached to each message. Messenger Encryption and Authentication \u00b6 Once a message chain is established, Loki Messenger enforces Perfect Forward Secrecy (PFS) and Deniable Authentication (DA). PFS and DA are key concepts of the Off The Record (OTR) messaging protocol. Centralised services, such as Signal and WhatsApp, use off the existing Tox protocol, which is a distributed, peer-to-peer instant messaging protocol that uses the highly audited NaCl library . PFS enables resistance from attacks where a long-term key is exposed. A new shared encryption key is used for each session, so if a single session key is revealed, the whole message chain is not compromised. If a third-party wanted to break the encryption of a message chain they would need to obtain the keys for every individual session. PFS ensures that Loki Messenger is extremely difficult to compromise when compared to existing methods, such as Pretty Good Privacy (PGP) encryption, where only one long-term key pair is required to compromise the whole message chain. DA refers to the ability for two parties to prove to each other that they are the sender of each new message. However, a third-party cannot ascertain who the true sender of any message is. When using DA, Message Authentication Codes (MACs) are published after each session, allowing third-parties to plausibly create messages that appear as if they originate from the senders public address. When correctly implemented, it is impossible for any third-party to prove that a sender of a specific message was the actual sender. User Authentication \u00b6 Authentication of users is important to ensure protection against man-in-the-middle attacks. For example, if Bob is expecting a message from Alice but does not yet know what her public key is, then a third-party (Eve), could send a message to Bob pretending to be Alice. This is why users should authenticate each other before sharing personal information. Like Pidgin and other OTR messaging services, Loki Messenger uses Pre-Shared Key (PSK) authentication. Users have multiple options for the establishment of a PSK. They can establish a key out-of-band, or alternatively, they can agree on a PSK over Loki Messenger by 9 asking the other a question which no third-party would know the answer. Loki will implement PSK authentication based on a modified version of the Pidgin encryption authentication plugin.","title":"Messenger"},{"location":"LokiNET/Messenger/#loki-messenger","text":"The first Loki service to be developed and deployed on the Loki network will be a decentralised, end-to-end encrypted private messaging application called Loki Messenger. End-to-end encrypted messaging applications that provide a platform for users to send messages without revealing their contents already exist, however they rely on centralised servers that can be targeted, blocked and shut down. These centralised service models present a high-risk for the anonymity of communicating parties, as they often require the user to register a phone number or other identifying information and connect directly via the IP address of the user. This information could be extracted from servers through data leaks or legal processes and used against the user. Leveraging the Service Nodes architecture on the Loki network, we can deliver a service similar to popular centralised encrypted messaging apps, such as Signal, with a higher degree of privacy and censorship resistance.","title":"Loki Messenger"},{"location":"LokiNET/Messenger/#messenger-routing","text":"Message routing on the Loki network changes depending on whether the receiving user is online or offline. When both users are online, higher bandwidth communications can take place due to the fact that messages do not need to be stored on the Service Nodes . In Loki, a public key acts both as long-term encryption key and a routing address. In the most simple case, this key should be exchanged out-of-band to ensure protection against a man-in-the-middle attack. Such an exchange should take place either in person or through another secure mode of exchange.","title":"Messenger Routing"},{"location":"LokiNET/Messenger/#online-messaging","text":"Once Alice knows Bobs public key, she assumes he is online and tries to create a path to him. Alice does this by querying the DHT of any Service Node and obtains any introduction set that corresponds with Bobs public key. In LLARP, introduction sets list the introducers that each user maintains. It is through these introducers that paths can be established. With Bobs introducer, Alice now chooses three random Service Nodes to act as intermediary hops between her origin and her destination (Bobs introducer). A path has now been established, through which Alice and Bob can transmit messages. If correctly authenticated, and using OTR , Alice and Bob can now communicate while maintaining a high-level of privacy.","title":"Online Messaging"},{"location":"LokiNET/Messenger/#offline-messaging","text":"If Alice fails to receive a response from Bob, she can then initiate the offline messaging process. Offline routing uses a modified version of Postal Services over Swarm (PSS) . Swarms are logical groupings of Service Nodes , based both on their public keys and the hash of the block that their staking transaction first appeared in. Each swarm has a swarmID and consists of nine nodes. To send a message to Bob, Alice can use his public key to calculate which swarm Bob belongs to. With this information, Alice can anonymously route a message through the network to a random Service Nodes in that swarm. When a Service Nodes receives a unique message destined for its swarm, it must distribute that message to the other eight nodes in the swarm. All nodes are additionally required to store messages for their allocated Time-to-live (TTL). When Bob comes online, he can query any two nodes in his swarm for messages he can decrypt. Offline messaging is protected from spamming with a small proof-of-work that is attached to each message.","title":"Offline Messaging"},{"location":"LokiNET/Messenger/#messenger-encryption-and-authentication","text":"Once a message chain is established, Loki Messenger enforces Perfect Forward Secrecy (PFS) and Deniable Authentication (DA). PFS and DA are key concepts of the Off The Record (OTR) messaging protocol. Centralised services, such as Signal and WhatsApp, use off the existing Tox protocol, which is a distributed, peer-to-peer instant messaging protocol that uses the highly audited NaCl library . PFS enables resistance from attacks where a long-term key is exposed. A new shared encryption key is used for each session, so if a single session key is revealed, the whole message chain is not compromised. If a third-party wanted to break the encryption of a message chain they would need to obtain the keys for every individual session. PFS ensures that Loki Messenger is extremely difficult to compromise when compared to existing methods, such as Pretty Good Privacy (PGP) encryption, where only one long-term key pair is required to compromise the whole message chain. DA refers to the ability for two parties to prove to each other that they are the sender of each new message. However, a third-party cannot ascertain who the true sender of any message is. When using DA, Message Authentication Codes (MACs) are published after each session, allowing third-parties to plausibly create messages that appear as if they originate from the senders public address. When correctly implemented, it is impossible for any third-party to prove that a sender of a specific message was the actual sender.","title":"Messenger Encryption and Authentication"},{"location":"LokiNET/Messenger/#user-authentication","text":"Authentication of users is important to ensure protection against man-in-the-middle attacks. For example, if Bob is expecting a message from Alice but does not yet know what her public key is, then a third-party (Eve), could send a message to Bob pretending to be Alice. This is why users should authenticate each other before sharing personal information. Like Pidgin and other OTR messaging services, Loki Messenger uses Pre-Shared Key (PSK) authentication. Users have multiple options for the establishment of a PSK. They can establish a key out-of-band, or alternatively, they can agree on a PSK over Loki Messenger by 9 asking the other a question which no third-party would know the answer. Loki will implement PSK authentication based on a modified version of the Pidgin encryption authentication plugin.","title":"User Authentication"},{"location":"LokiNET/SNapps/","text":"SNApps \u00b6 The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the mixnet environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet. SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network.","title":"SNapps"},{"location":"LokiNET/SNapps/#snapps","text":"The function of SNApps is similar to so-called hidden services in Tor which have flourished. They provide users with a way to interact fully within the mixnet environment, providing an even higher-degree of anonymity than can be achieved when accessing externally hosted content. SNApps allow for users to setup and host marketplaces, forums, whistle-blowing websites, social media, and most other internet applications on their own machines or servers while maintaining full-server and user-side anonymity. This greatly expands the scope of the network and allows users to build meaningful communities within Lokinet. SNApp operators use the traditional server-client model with the key difference being that Service Nodes will be intermediaries in a users connection through Lokinet. When a SNApp wishes to register on the network, it must update the DHT with its descriptor. This descriptor contains various introducers, which are specific Service Nodes that users can contact to form a path to the SNApp. When these paths are set up, users can connect to the SNApp without either party knowing where the other is located in the network.","title":"SNApps"},{"location":"LokiNET/Guides/ExitNode/","text":"LokiNET Exit Node Guide \u00b6 // TODO: exit node overview goes here Prequesites \u00b6 // TODO: technical prequesites goes here Technical \u00b6 // TODO: technical overview about exit nodes Bandwidth \u00b6 // TODO: notes about bandwidth OS Limits (?) \u00b6 // TODO: talk about OS level limits for IPv4 exits // TODO: talk about ipv6 exit requirements, i.e. a /120 to /64 Legal \u00b6 // TODO: legal overivew Disclaimer \u00b6 // TODO: overview of exit traffic legality in various regions Email Templates \u00b6 // TODO: links to response templates go here Dear Sir/Madam, [Insert response template here] Best of luck, [Exit node oper name/organization here] Best Practices \u00b6 // TODO: insert best practices here // TODO: abuse complaints // TODO: Automated DMCA Spam Notices // TODO: traffic shaping (?) // TODO: ipv6 implications Worst Case Emergencies \u00b6 // TODO: link to EFF resources // TODO: insert info about handling police here // TODO: don't talk to the police video goes here","title":"Exit Nodes"},{"location":"LokiNET/Guides/ExitNode/#lokinet-exit-node-guide","text":"// TODO: exit node overview goes here","title":"LokiNET Exit Node Guide"},{"location":"LokiNET/Guides/ExitNode/#prequesites","text":"// TODO: technical prequesites goes here","title":"Prequesites"},{"location":"LokiNET/Guides/ExitNode/#technical","text":"// TODO: technical overview about exit nodes","title":"Technical"},{"location":"LokiNET/Guides/ExitNode/#bandwidth","text":"// TODO: notes about bandwidth","title":"Bandwidth"},{"location":"LokiNET/Guides/ExitNode/#os-limits","text":"// TODO: talk about OS level limits for IPv4 exits // TODO: talk about ipv6 exit requirements, i.e. a /120 to /64","title":"OS Limits (?)"},{"location":"LokiNET/Guides/ExitNode/#legal","text":"// TODO: legal overivew","title":"Legal"},{"location":"LokiNET/Guides/ExitNode/#disclaimer","text":"// TODO: overview of exit traffic legality in various regions","title":"Disclaimer"},{"location":"LokiNET/Guides/ExitNode/#email-templates","text":"// TODO: links to response templates go here Dear Sir/Madam, [Insert response template here] Best of luck, [Exit node oper name/organization here]","title":"Email Templates"},{"location":"LokiNET/Guides/ExitNode/#best-practices","text":"// TODO: insert best practices here // TODO: abuse complaints // TODO: Automated DMCA Spam Notices // TODO: traffic shaping (?) // TODO: ipv6 implications","title":"Best Practices"},{"location":"LokiNET/Guides/ExitNode/#worst-case-emergencies","text":"// TODO: link to EFF resources // TODO: insert info about handling police here // TODO: don't talk to the police video goes here","title":"Worst Case Emergencies"},{"location":"LokiNET/Guides/SNApps/","text":"LokiNET SNApps/Hidden Service Setup Guide \u00b6 // TODO: overview goes here Installing \u00b6 // TOOD: LokiNET install instructions go here Setup \u00b6 // TODO: hidden service config and setup goes here Best Practices \u00b6 // TODO: talk about binding to all interfaces being bad // TODO: talk about networking namespaces options for linux Examples \u00b6 // TODO: insert secure example here","title":"SNApps"},{"location":"LokiNET/Guides/SNApps/#lokinet-snappshidden-service-setup-guide","text":"// TODO: overview goes here","title":"LokiNET SNApps/Hidden Service Setup Guide"},{"location":"LokiNET/Guides/SNApps/#installing","text":"// TOOD: LokiNET install instructions go here","title":"Installing"},{"location":"LokiNET/Guides/SNApps/#setup","text":"// TODO: hidden service config and setup goes here","title":"Setup"},{"location":"LokiNET/Guides/SNApps/#best-practices","text":"// TODO: talk about binding to all interfaces being bad // TODO: talk about networking namespaces options for linux","title":"Best Practices"},{"location":"LokiNET/Guides/SNApps/#examples","text":"// TODO: insert secure example here","title":"Examples"},{"location":"LokiNET/Guides/TestNetRelay/","text":"LokiNET testnet relay guide \u00b6 // TODO: overview Prequisites \u00b6 // TODO: insert prequesites here Installing \u00b6 // TODO: insert install guide here Configuration \u00b6 // TODO: insert config guide here Exit Traffic \u00b6 // TODO: exit node oper overview goes here For More information see the Exit Node Guide .","title":"Test Network Relay"},{"location":"LokiNET/Guides/TestNetRelay/#lokinet-testnet-relay-guide","text":"// TODO: overview","title":"LokiNET testnet relay guide"},{"location":"LokiNET/Guides/TestNetRelay/#prequisites","text":"// TODO: insert prequesites here","title":"Prequisites"},{"location":"LokiNET/Guides/TestNetRelay/#installing","text":"// TODO: insert install guide here","title":"Installing"},{"location":"LokiNET/Guides/TestNetRelay/#configuration","text":"// TODO: insert config guide here","title":"Configuration"},{"location":"LokiNET/Guides/TestNetRelay/#exit-traffic","text":"// TODO: exit node oper overview goes here For More information see the Exit Node Guide .","title":"Exit Traffic"},{"location":"Mining/ASICResistance/","text":"ASIC Resistance \u00b6 An Application-Specific Integrated Circuit (ASIC) is a computer chip that is built specifically for a single function. In the context of mining, ASICs are used to compute for specific hashing algorithms. They pose a risk to decentralisation because they outpace all other mining methods, are manufactured by specific companies, have very limited distribution channels due to the specialised nature of the hardware, and they require significant capital costs to develop and operate profitably. There are potential benefits to ASICs, such as the capital cost requirements that miners must undertake to invest in algorithm specific hardware which makes it less likely that they would behave in a manner that undermines their own investment by acting dishonestly. However, the distribution and manufacture of ASIC chips, with mature hashing algorithms, is still centralised around a few large companies. These companies can refuse shipment to certain areas, decide what regions and customers get the best performing ASICs, and they can structure limited runs and manipulate prices. To prevent ASIC miners from monopolising the network hashrate, many cryptocurrencies developed ASIC resistant hashing algorithms, like Scrypt and Ethash . Until recently, Monero used the CryptoNight hashing algorithm, which requires large amounts of L3 cache to operate. In theory, this should have made it difficult to produce an ASIC chip due to large memory requirements. However in 2018 Bitmain released the X3, a CryptoNight specific ASIC that could effectively mine at ten times the speed of a graphics processing unit (GPU). Other hashing algorithms have suffered similar fates, with Scrypt, Ethash, and Equihash all now being mined by ASICs. To combat the use of ASICs, Monero proposed a strategy of hard forking every 3-6 months to slightly change the CryptoNight hashing algorithm ( the first fork moving to CryptoNightV7 ). The capital and time required to build an ASIC is significant, and with highly specific hardware designs, slight tweaks in a hashing algorithm should invalidate the chip design, wasting the time and capital investment of ASIC manufacturers. However, this approach introduces its own issues. If changes made to the algorithm are insufficient to prevent ASICs being reprogrammed, then the network can become vulnerable to hashrate centralisation until another hard fork is possible. Field Programmable Gate Arrays (FPGAs) should also 12 be considered in ASIC resistance strategies, where infrequent, slight changes to hashing algorithms can be easily reprogrammed for FPGAs. Another concern is that regular changes to core consensus mechanisms introduce the chance of unintended bugs and generally centralise the development of such changes around the core team of developers. A number of alternative proof-of-work algorithms have been proposed to combat the need to hard fork regularly, including provably memory-hard hashing algorithms like Argon2 , Balloon hash , and polymorphic hashing algorithms like ProgPoW and RandProg . The Loki team will be publishing additional research on the aforementioned algorithms to develop a long-term solution to ASIC resistance. While this work is undertaken, Loki will incorporate a version of CryptoNight called CryptoNight Heavy, which maintains ASIC resistance against CryptoNight ASIC miners. CryptoNight Heavy differs from CryptoNight V7 in a number of ways: it provides an increase in scratchpad size to 4mb a change in the way implodes and explodes are handled These changes differentiate it from the largest target for ASIC miners which is Monero\u2019s CryptoNight V7 and also provide more robust protection against ASIC development until a more permanent solution is proposed.","title":"ASIC Resistance"},{"location":"Mining/ASICResistance/#asic-resistance","text":"An Application-Specific Integrated Circuit (ASIC) is a computer chip that is built specifically for a single function. In the context of mining, ASICs are used to compute for specific hashing algorithms. They pose a risk to decentralisation because they outpace all other mining methods, are manufactured by specific companies, have very limited distribution channels due to the specialised nature of the hardware, and they require significant capital costs to develop and operate profitably. There are potential benefits to ASICs, such as the capital cost requirements that miners must undertake to invest in algorithm specific hardware which makes it less likely that they would behave in a manner that undermines their own investment by acting dishonestly. However, the distribution and manufacture of ASIC chips, with mature hashing algorithms, is still centralised around a few large companies. These companies can refuse shipment to certain areas, decide what regions and customers get the best performing ASICs, and they can structure limited runs and manipulate prices. To prevent ASIC miners from monopolising the network hashrate, many cryptocurrencies developed ASIC resistant hashing algorithms, like Scrypt and Ethash . Until recently, Monero used the CryptoNight hashing algorithm, which requires large amounts of L3 cache to operate. In theory, this should have made it difficult to produce an ASIC chip due to large memory requirements. However in 2018 Bitmain released the X3, a CryptoNight specific ASIC that could effectively mine at ten times the speed of a graphics processing unit (GPU). Other hashing algorithms have suffered similar fates, with Scrypt, Ethash, and Equihash all now being mined by ASICs. To combat the use of ASICs, Monero proposed a strategy of hard forking every 3-6 months to slightly change the CryptoNight hashing algorithm ( the first fork moving to CryptoNightV7 ). The capital and time required to build an ASIC is significant, and with highly specific hardware designs, slight tweaks in a hashing algorithm should invalidate the chip design, wasting the time and capital investment of ASIC manufacturers. However, this approach introduces its own issues. If changes made to the algorithm are insufficient to prevent ASICs being reprogrammed, then the network can become vulnerable to hashrate centralisation until another hard fork is possible. Field Programmable Gate Arrays (FPGAs) should also 12 be considered in ASIC resistance strategies, where infrequent, slight changes to hashing algorithms can be easily reprogrammed for FPGAs. Another concern is that regular changes to core consensus mechanisms introduce the chance of unintended bugs and generally centralise the development of such changes around the core team of developers. A number of alternative proof-of-work algorithms have been proposed to combat the need to hard fork regularly, including provably memory-hard hashing algorithms like Argon2 , Balloon hash , and polymorphic hashing algorithms like ProgPoW and RandProg . The Loki team will be publishing additional research on the aforementioned algorithms to develop a long-term solution to ASIC resistance. While this work is undertaken, Loki will incorporate a version of CryptoNight called CryptoNight Heavy, which maintains ASIC resistance against CryptoNight ASIC miners. CryptoNight Heavy differs from CryptoNight V7 in a number of ways: it provides an increase in scratchpad size to 4mb a change in the way implodes and explodes are handled These changes differentiate it from the largest target for ASIC miners which is Monero\u2019s CryptoNight V7 and also provide more robust protection against ASIC development until a more permanent solution is proposed.","title":"ASIC Resistance"},{"location":"Mining/ProofOfWork/","text":"TO DO","title":"Proof Of Work"},{"location":"ServiceNodes/RunServiceNodeAsService/","text":"How to configure the Loki daemon as a service \u00b6 IMPORTANT : This guide is a work in progress that may be updated. It may contain errors. USE AT YOUR OWN RISK! This guide will help you set up the Loki daemon (lokid) as a service. By doing this, the Loki daemon will automatically start after a crash or reboot, which helps your Service Node keep running without undesired interruptions. This guide details the process of managing the Loki daemon as a regular system process rather than in a screen session. This guide has been tested on Ubuntu Server 18.04 Read the guide carefully. You must change file path of your Loki daemon and username wherever needed. It is also recommended that you avoid running your Service Node as root user. Follow Full Guide on Service Nodes - Set up Non-root User for directions on how to create a new user for this purpose. Be careful if your server is already running as you will have to move your Loki binaries folder and .loki hidden folder, where your Service Node public key is stored, from root's home path to your new user's home path. You can read Jagerman's guide if you need a more in depth approach. Table of Contents \u00b6 Configuring the Loki daemon as a service for the first time How to update Loki binaries when running daemon as a service How to access Loki daemon in interactive mode when running daemon as a service Configuring the Loki daemon as a service for the first time \u00b6 Connect to your server via SSH (as is explained at Full Guide on Service Nodes - Step 2 - Prepare your Server ) and copy & paste the following commands into the terminal window: Create the lokid.service file: sudo touch /etc/systemd/system/lokid.service Change the file permissions: sudo chmod 664 /etc/systemd/system/lokid.service Start editing the created empty file: sudo nano /etc/systemd/system/lokid.service Copy the text between the #s below and paste it into your empty file. ########################################################################################### [Unit] Description=lokid service After=network-online.target [Service] Type=simple User=YOUR_USERNAME ExecStart=/home/YOUR_USERNAME/YOUR_LOKI_FILES_FOLDER/lokid --non-interactive --service-node Restart=always RestartSec=30s [Install] WantedBy=multi-user.target ########################################################################################### Modify YOUR_USERNAME and YOUR_LOKI_FILES_FOLDER in the text that is between #s. You must change YOUR_USERNAME on two different places and YOUR_LOKI_FILES_FOLDER in one. If you are running your Service Node as root, /home must be removed from ExecStart path: ExecStart=/root/YOUR_LOKI_FILES_FOLDER/lokid --non-interactive --service-node For Testnet, append the --testnet flag at the end of your modified ExecStart line. Once completed save and quit nano: CTRL+X -> Y -> ENTER Reload systemd manager configuration: sudo systemctl daemon-reload Stop the Loki daemon if it's running (see NOTE ). Here you have to go into the screen session where you are running lokid and type: exit + ENTER Start lokid.service: sudo systemctl start lokid.service Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Now, everything should be working. We won't have a Loki daemon interactive screen but we can use RPC to communicate with the service. The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status (remember to replace YOUR_LOKI_FILES_FOLDER with your own): ~/YOUR_LOKI_FILES_FOLDER/./lokid print_sn_status ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Your Loki daemon should start as a service on every reboot. How to update Loki binaries when running daemon as a service \u00b6 To update your Loki node, a process like the one found at Full Guide on Service Nodes - Updating loki can be followed. The main inconvenience of this method is that lokid.service file has to be edited on every update as the Loki daemon file path is changed. So we are forced to run several additional steps that are otherwise unnecessary. Because of this, two Loki daemon updating methods are described below: - Method based on \"Full Guide on Service Nodes - Updating loki\" - Updating Loki binaries without editing lokid.service file method Method based on \"Full Guide on Service Nodes - Updating loki\" \u00b6 Connect to your server via SSH and: Find the latest binary version, for example 1.0.4 . Check https://github.com/loki-project/loki/releases/latest . Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Run an update on your machine (Linux based systems): sudo apt-get update && sudo apt-get upgrade Download and unzip the latest binary: wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip and unzip loki-linux-x64-<VERSION>.zip (replace <VERSION> with the one found on step 1, 1.0.4 in our example). Re-run steps 3 and 5 described in the previous section in order to change YOUR_LOKI_FILES_FOLDER to loki-linux-x64-<VERSION> (replace <VERSION> with the one found on step 1, 1.0.4 in our example). Re-run steps from 6 to 9 described in the previous section . You can skip step 8 as your Loki daemon should not be running at this point. The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status: ~/loki-linux-x64-<VERSION>/./lokid print_sn_status (replace <VERSION> with the one found on step 1, 1.0.4 in our example).. For Testnet, append the --testnet flag at the end of the command. Updating Loki binaries without editing lokid.service file method \u00b6 If you do not want to edit your lokid.service file on every update, connect to your server via SSH and follow these alternative steps: Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Run an update on your machine (Linux based systems): sudo apt-get update && sudo apt-get upgrade If your Loki binaries' folder name still looks like loki-linux-x64-<VERSION> then: Rename it to loki to prevent the need of creating a new folder on every update: mv ~/loki-linux-x64-<VERSION> ~/loki (remember to replace loki-linux-x64-<VERSION> with your Loki binaries' folder name). Re-run steps 3 and 5 described in the previous section in order to change YOUR_LOKI_FILES_FOLDER to loki . Re-run steps 6 and 7 described in the previous section . Find the latest binary version, for example 1.0.4 . Check https://github.com/loki-project/loki/releases/latest . Download the latest binary: wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip (replace <VERSION> with the one found on step 4, 1.0.4 in our example). Unzip the latest binary in ~/loki folder (replace <VERSION> with the one found on step 4, 1.0.4 in our example): If you want to be asked for confirmation everytime a file is going to be overwritten: unzip loki-linux-x64-<VERSION>.zip -d ~/loki If you do not want to be asked, force overwriting: unzip -o loki-linux-x64-<VERSION>.zip -d ~/loki Start lokid.service: sudo systemctl start lokid.service The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status (remember to replace YOUR_LOKI_FILES_FOLDER with your own): ~/loki/./lokid print_sn_status ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Test 3. Check what Loki daemon version is running now that this information is not in its folder's name: ~/loki/./lokid version . For Testnet, append the --testnet flag at the end of the command. Skip step 3 in future updates. How to access Loki daemon in interactive mode when running daemon as a service \u00b6 Whenever you want to access lokid in interactive mode, for example to run Service Node registration command, you have to connect to your server via SSH and: Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Start lokid from shell: ~/YOUR_LOKI_FILES_FOLDER/./lokid ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Run the commands you need. For instance: prepare_registration if you are registering your Service Node. Quit lokid by typing: exit + ENTER Start the service again: sudo systemctl start lokid.service NOTE: \u00b6 If you have not updated your Loki binary files to the latest version yet you are encouraged to, since 1.0.0 or 1.0.1 users can run into timing issues that lead to deregistration with multiple consecutive daemon restarts.","title":"Service Node As Service Guide"},{"location":"ServiceNodes/RunServiceNodeAsService/#how-to-configure-the-loki-daemon-as-a-service","text":"IMPORTANT : This guide is a work in progress that may be updated. It may contain errors. USE AT YOUR OWN RISK! This guide will help you set up the Loki daemon (lokid) as a service. By doing this, the Loki daemon will automatically start after a crash or reboot, which helps your Service Node keep running without undesired interruptions. This guide details the process of managing the Loki daemon as a regular system process rather than in a screen session. This guide has been tested on Ubuntu Server 18.04 Read the guide carefully. You must change file path of your Loki daemon and username wherever needed. It is also recommended that you avoid running your Service Node as root user. Follow Full Guide on Service Nodes - Set up Non-root User for directions on how to create a new user for this purpose. Be careful if your server is already running as you will have to move your Loki binaries folder and .loki hidden folder, where your Service Node public key is stored, from root's home path to your new user's home path. You can read Jagerman's guide if you need a more in depth approach.","title":"How to configure the Loki daemon as a service"},{"location":"ServiceNodes/RunServiceNodeAsService/#table-of-contents","text":"Configuring the Loki daemon as a service for the first time How to update Loki binaries when running daemon as a service How to access Loki daemon in interactive mode when running daemon as a service","title":"Table of Contents"},{"location":"ServiceNodes/RunServiceNodeAsService/#configuring-the-loki-daemon-as-a-service-for-the-first-time","text":"Connect to your server via SSH (as is explained at Full Guide on Service Nodes - Step 2 - Prepare your Server ) and copy & paste the following commands into the terminal window: Create the lokid.service file: sudo touch /etc/systemd/system/lokid.service Change the file permissions: sudo chmod 664 /etc/systemd/system/lokid.service Start editing the created empty file: sudo nano /etc/systemd/system/lokid.service Copy the text between the #s below and paste it into your empty file. ########################################################################################### [Unit] Description=lokid service After=network-online.target [Service] Type=simple User=YOUR_USERNAME ExecStart=/home/YOUR_USERNAME/YOUR_LOKI_FILES_FOLDER/lokid --non-interactive --service-node Restart=always RestartSec=30s [Install] WantedBy=multi-user.target ########################################################################################### Modify YOUR_USERNAME and YOUR_LOKI_FILES_FOLDER in the text that is between #s. You must change YOUR_USERNAME on two different places and YOUR_LOKI_FILES_FOLDER in one. If you are running your Service Node as root, /home must be removed from ExecStart path: ExecStart=/root/YOUR_LOKI_FILES_FOLDER/lokid --non-interactive --service-node For Testnet, append the --testnet flag at the end of your modified ExecStart line. Once completed save and quit nano: CTRL+X -> Y -> ENTER Reload systemd manager configuration: sudo systemctl daemon-reload Stop the Loki daemon if it's running (see NOTE ). Here you have to go into the screen session where you are running lokid and type: exit + ENTER Start lokid.service: sudo systemctl start lokid.service Enable lokid.service so that it starts automatically upon boot: sudo systemctl enable lokid.service Now, everything should be working. We won't have a Loki daemon interactive screen but we can use RPC to communicate with the service. The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status (remember to replace YOUR_LOKI_FILES_FOLDER with your own): ~/YOUR_LOKI_FILES_FOLDER/./lokid print_sn_status ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Your Loki daemon should start as a service on every reboot.","title":"Configuring the Loki daemon as a service for the first time"},{"location":"ServiceNodes/RunServiceNodeAsService/#how-to-update-loki-binaries-when-running-daemon-as-a-service","text":"To update your Loki node, a process like the one found at Full Guide on Service Nodes - Updating loki can be followed. The main inconvenience of this method is that lokid.service file has to be edited on every update as the Loki daemon file path is changed. So we are forced to run several additional steps that are otherwise unnecessary. Because of this, two Loki daemon updating methods are described below: - Method based on \"Full Guide on Service Nodes - Updating loki\" - Updating Loki binaries without editing lokid.service file method","title":"How to update Loki binaries when running daemon as a service"},{"location":"ServiceNodes/RunServiceNodeAsService/#method-based-on-full-guide-on-service-nodes-updating-loki","text":"Connect to your server via SSH and: Find the latest binary version, for example 1.0.4 . Check https://github.com/loki-project/loki/releases/latest . Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Run an update on your machine (Linux based systems): sudo apt-get update && sudo apt-get upgrade Download and unzip the latest binary: wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip and unzip loki-linux-x64-<VERSION>.zip (replace <VERSION> with the one found on step 1, 1.0.4 in our example). Re-run steps 3 and 5 described in the previous section in order to change YOUR_LOKI_FILES_FOLDER to loki-linux-x64-<VERSION> (replace <VERSION> with the one found on step 1, 1.0.4 in our example). Re-run steps from 6 to 9 described in the previous section . You can skip step 8 as your Loki daemon should not be running at this point. The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status: ~/loki-linux-x64-<VERSION>/./lokid print_sn_status (replace <VERSION> with the one found on step 1, 1.0.4 in our example).. For Testnet, append the --testnet flag at the end of the command.","title":"Method based on \"Full Guide on Service Nodes - Updating loki\""},{"location":"ServiceNodes/RunServiceNodeAsService/#updating-loki-binaries-without-editing-lokidservice-file-method","text":"If you do not want to edit your lokid.service file on every update, connect to your server via SSH and follow these alternative steps: Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Run an update on your machine (Linux based systems): sudo apt-get update && sudo apt-get upgrade If your Loki binaries' folder name still looks like loki-linux-x64-<VERSION> then: Rename it to loki to prevent the need of creating a new folder on every update: mv ~/loki-linux-x64-<VERSION> ~/loki (remember to replace loki-linux-x64-<VERSION> with your Loki binaries' folder name). Re-run steps 3 and 5 described in the previous section in order to change YOUR_LOKI_FILES_FOLDER to loki . Re-run steps 6 and 7 described in the previous section . Find the latest binary version, for example 1.0.4 . Check https://github.com/loki-project/loki/releases/latest . Download the latest binary: wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip (replace <VERSION> with the one found on step 4, 1.0.4 in our example). Unzip the latest binary in ~/loki folder (replace <VERSION> with the one found on step 4, 1.0.4 in our example): If you want to be asked for confirmation everytime a file is going to be overwritten: unzip loki-linux-x64-<VERSION>.zip -d ~/loki If you do not want to be asked, force overwriting: unzip -o loki-linux-x64-<VERSION>.zip -d ~/loki Start lokid.service: sudo systemctl start lokid.service The following commands should let us know if everything went fine: Test 1. Check lokid.service status: systemctl status lokid.service Test 2. Check the Service Node status (remember to replace YOUR_LOKI_FILES_FOLDER with your own): ~/loki/./lokid print_sn_status ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Test 3. Check what Loki daemon version is running now that this information is not in its folder's name: ~/loki/./lokid version . For Testnet, append the --testnet flag at the end of the command. Skip step 3 in future updates.","title":"Updating Loki binaries without editing lokid.service file method"},{"location":"ServiceNodes/RunServiceNodeAsService/#how-to-access-loki-daemon-in-interactive-mode-when-running-daemon-as-a-service","text":"Whenever you want to access lokid in interactive mode, for example to run Service Node registration command, you have to connect to your server via SSH and: Stop the Loki daemon service: sudo systemctl stop lokid.service (see NOTE ) Start lokid from shell: ~/YOUR_LOKI_FILES_FOLDER/./lokid ( ~ character replaces user's home directory full path, do not skip it!). For Testnet, append the --testnet flag at the end of the command. Run the commands you need. For instance: prepare_registration if you are registering your Service Node. Quit lokid by typing: exit + ENTER Start the service again: sudo systemctl start lokid.service","title":"How to access Loki daemon in interactive mode when running daemon as a service"},{"location":"ServiceNodes/RunServiceNodeAsService/#note","text":"If you have not updated your Loki binary files to the latest version yet you are encouraged to, since 1.0.0 or 1.0.1 users can run into timing issues that lead to deregistration with multiple consecutive daemon restarts.","title":"NOTE:"},{"location":"ServiceNodes/SNFullGuide/","text":"Full Guide on Service Nodes \u00b6 This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. Also available is a video guide, which provides a more simplified version of the written guide, it can be viewed here . If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 16.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from. Summary of Loki Service Node Requirements \u00b6 Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our telegram / discord announcements channel. Spec Note Latest Binary loki-linux-x64-1.0.3 Software Ubuntu 16.04 Memory 30-50gb Ram 2-4 gb Table of Contents \u00b6 Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Download Binaries Step 4 Run the Loki Daemon Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Express Setup Guide Additional Functions Overview \u00b6 To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki for 30 days (2 days on testnet) and submits a registration transaction Once accepted by the network, the Service Node is eligible to win block rewards Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay in a novel mixnet Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions (Blink) Act as remote nodes for users Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements. New User Guide \u00b6 This section of this guide is for new users to servers and the CLI interface. Step 1 - Get a Server \u00b6 Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds for 30 days (2 days for testnet) at a time, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ) A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 10 - 15 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 80 - 40 MiB\u2019s 4 / 10 Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 16.04 64 bit or Ubuntu 18.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply. Step 2 - Prepare your Server \u00b6 Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS. Hot Tips for using the Console \u00b6 Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. This is why you shouldn't try copying something with this hotkey ;) You can always check the directory you are in and its contents by typing ls You can always return to your home directory by typing cd ~ You can move into a given directory by typing cd <name> or move back up one level by typing cd .. PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the terminal may prompt us for a new password for our root account. The terminal will require you to enter the new password twice before we can start running commands. Optional - Set up Non-root User \u00b6 Best practice when running a public server is to not run your software as the root user. Although it is optional, we will create a non-root user to our VPS by running the following command. sudo adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. sudo adduser snode The terminal will prompt you for a new password for our newly created user. Use a different password to the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. sudo usermod -aG sudo snode su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node. Server Preparation Continued \u00b6 We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running in root. On to the fun part! Step 3 - Download the Loki Binaries \u00b6 First download the Linux binaries by running the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location . Your command should look something like: wget https://github.com/loki-project/loki/releases/download/1.0.3/loki-linux-x64-1.0.3.zip If wget is not installed you may need to run sudo apt-get install wget To get to the binaries, we need to unzip them. Download and install unzip by running the following command. sudo apt-get install unzip If unzip is not installed you may need to run sudo apt-get install unzip To unzip the downloaded zip file run the following command: unzip loki-linux-x64-1.0.3.zip You should see 8 files unzipped: loki-blockchain-export loki-wallet-cli loki-blockchain-usage lokid loki-blockchain-blackball loki-wallet-rpc loki-blockchain-import Loki-gen-trusted-multisig Check they are unzipped by running: ls If not, sometimes unzip will dump the binaries in a folder. In our case the folder would be called loki-linux-x64-1.0.3 , so to get into it we can type: cd loki-linux-x64-1.0.3 To check that they are in that folder, once again, type: ls Excellent! We now have all of the necessary files to get this show on the road! NOTE: If you\u2019re nervous about trusting the binaries or the link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki Step 4 - Run the Service Node Daemon \u00b6 Let\u2019s start up the daemon so we can sync the blockchain and register our Service Node. The problem with the terminal we currently have open is that once we close PuTTY the program running inside it will also shut down. We can run a program called screen which can keep our Service Node running for 30 days without having to look at it all the time. The screen command is generally included in Ubuntu by default. If it isn\u2019t, run sudo apt install screen . Running it opens up a terminal shell inside your session that will continue to run in the background once you detach it from the session. Type the following command: screen Enter through the information that the terminal shell is providing until we get back a blank screen awaiting an input. To begin the Service Node daemon we must launch lokid with the flag --service-node . ./lokid --service-node If you are testing the daemon on testnet run the following command ./lokid --service-node --testnet The daemon will now start syncing. You won\u2019t be able to do much if it hasn\u2019t synced. To have the daemon to continue to run in the background hold Ctrl and type ad. To test your screen is still running in the background run the command screen -ls and take note of the port number at the start of the screen. This number will help us re-enter the daemon at future times. Typing screen -x <port number> will reattach the session so we can see what\u2019s going on inside. Hold CTRL and type \"ad\" again to detach the screen once more. For now, we can just leave the session open to see the daemon messages while we set up the Service Node. Just don't forget to use CTRL + A + D to detach the session before you close PuTTY later on. Step 5 - Get/Open A Wallet \u00b6 While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! You can run the CLI wallet (Command Line Interface wallet) on any other computer, including your home computer to avoid leaving your wallet on the server. However, if you do want to run the CLI wallet on another computer, you will either need to run another daemon on that local machine or use a remote node (uk.loki.cash:22020, for example). There is also a list of trusted remote nodes in the Loki Project Discord channel under #links-and-resources. Alternatively if your Service Node is synced up, you could actually use the address of that daemon. When you run 'loki-wallet-cli' locally and wish to use a remote daemon, use the syntax: ./loki-wallet-cli --daemon-address <insert address here> Or on windows: loki-wallet-cli.exe --daemon-address <insert address here> If you are made of money and are willing to take the small risk of losing all of your funds, you can continue running the wallet inside the Service Node VPS. So we don't have to talk about a myriad of other operating systems or potential user cases, the rest of this guide will assume you are running the wallet in the same VPS. As such, it\u2019ll probably save us time to open a second PuTTY session. You can do this by right clicking the window of the current PuTTY session and clicking \u201cDuplicate Session.\u201d Log in to your non-root user that we set up before, in our case snode, and once in we should open a new screen by typing screen and hitting return twice. Change directory to where our binaries are saved: cd loki-linux-x64-1.0.3 Then to launch the wallet run the command: ./loki-wallet-cli If you are on testnet run the command with the --testnet flag: ./loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note: - When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. - Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. - Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address. Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet. It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask someone in the Loki Discord Community for some testnet Loki, or alternatively you can run the command start_mining in your wallet. This may take an hour or two to get enough Loki. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: LPoiZQ43qG18FzKq7WhEbk3gfNNiemGsd7REdSQaFv4RdB8E97RxP8WFLRR2xHQStiSM61EFEicXU3EEPj7GEHdz8WHUrWRkbGeQ1r8ro8 NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute. Step 6 - Service Node Registration \u00b6 The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking 6.1 - Individual Staking \u00b6 If you want to run the Service Node as an individual you will require the following things. A Loki daemon running with --service-node flag (see step 4). A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement (see step 5). Now if we have the two above items we can proceed to our daemon to register our Service Node. Type screen -ls to get a list of the screens running. Your daemon will normally be the bottom one on the list. To enter our daemon run the following command, replacing <port number> with the number that corresponds with your daemon. screen -x <port number> To start the registration process we are going to run the following interactive command within the daemon terminal: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify if you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask if you wish to enable automatic re-staking. Type y and click enter if you would like to have your Service Node re-stake automatically for you at the end of every 30 days. Type n if you would like to re-stake manually. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . if registering multiple nodes, please wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. We do not require our daemon terminal anymore, however we do need to daemon to be running. Hold CTRL and type ad to detach the screen. Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. Alternatively, you can also include the auto command, this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. register_service_node auto args..... If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop the auto command. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Well done! Let's continue to the next step \"Step 7 - Service Node Check\" to check if our Service Node is running. 6.2 - Pool Staking \u00b6 Service Nodes can be split between multiple parties. At a minimum, the operator must stake at least 25% of the total required amount. The operator can also reserve contribution slots for specific addresses to prevent random users from adding to the pool. In any given pool, there will be at most 4 contributors including the operator. After the operator, each new participant must also contribute 25% of the minimum, except the last one. So for example, valid splits might be: Operator Contributor 1 Contributor 2 Contributor 3 25% 25% 40% 10% 65% 25% 10% 90% 10% 99% 1% Depending on the individual and their circumstance they will need to: Jump into section \"6.2.1 - Operator\" if they are running the daemon and hosting the pool; Jump into section \"6.2.2 - Pool Contributor\" if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \"6.2 - Pool Staking\" to have a better understanding of the process. 6.2.1 - Operator \u00b6 The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A Loki daemon running with --service-node flag (see step 4) at all times. A loki-wallet-cli primary address with enough Loki in their account to meet 25% of the Staking Requirement. 1-3 other contributors who also have a loki-wallet-cli with enough Loki in their accounts to meet 25% of the staking requirement. The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Type screen -ls to get a list of the screens running. Your daemon will normally be the bottom one on the list. To enter our daemon run the following command, replacing <port number> with the number that corresponds with your daemon: screen -x <port number> To start the registration process we are going to run the following interactive command within the daemon terminal: prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node. Reserved Pool \u00b6 If the operator wishes to have their pool closed they should type y and click continue. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. They must type in the number of contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input each of the contributors amount of Loki they will stake and each contributors address. The daemon will now ask if you wish to enable automatic re-staking. Type y and hit return if you would like to have your Service Node re-stake automatically at the end of every 30 days. Type n if you would like to re-stake manually. You will now be asked to confirm the information above is correct. Open Pool \u00b6 If the operator wishes to leave their pool open they should type n and click continue. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed in your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before we leave the daemon run the following command to get our <Service Node Public Key> and save it in your notepad: print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Alternatively, the operator can also include the auto command, when staking this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. register_service_node auto args..... If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop the auto command. We must now send the <Service Node Public Key> to our contributors with the amount of Loki they are required to stake. At this point the we will need to wait until all contributors have staked before rewards will be received. 6.2.2 - Pool Contributor \u00b6 The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through the loki-wallet-cli , and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <address> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator, the <address> the service node operator will likely reserve an address for which they want you to stake for, this will usually be the same address as the wallet you are planning to stake from, in the case of an open pool this will always be the address you will you stake from and you will also receive rewards here too. <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. The Pool Contributor can also include the auto command, when staking this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. stake auto <Service Node Pubkey> <address> <contribution amount> If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop autostaking. The auto command does not work with a multsig wallet as there is a requirement for the party who is staking to have the transaction signed by another signer. Thus is it advised if you are using a multisig wallet to maintain the staking once a month when the funds are unlocked. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking. Step 7 - Service Node Check \u00b6 After we have locked your collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Let\u2019s go into our daemon screen by typing screen -x <port number> . To find the port number use screen -ls and your daemon should be sitting at the bottom of the list. Once we are in the daemon again we can run the following command to see our Service Node Public Key: print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. We will want to know the current block height, type status into the daemon and it will output this information. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the command print_quorum_state <block height> replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking. Additional Functions \u00b6 Autostaking - Checking/stopping autostake command \u00b6 To check the processes running in the background, run the command: top -u <username> Under the COMMAND column we should see a process called loki-wallet-cli . If you do not see this process you are either looking at the wrong <username> or your autostake command is not running. If you want to stop the autostake then run the following command while logged on to the specific <username> which has loki-wallet-cli running in the background: pkill loki-wallet-cli ### Running Autostake on startup If the host machine your VPS is running on shuts down or restarts unexpectedly then so to will your your autostaking wallet, you can use the following command to start the autostaking wallet again, you can also include these commands in your startup scripts, ensuring if your node goes down it automatically restarts the wallet process. loki-wallet-cli --testnet --wallet-file <PATH TO WALLET FILE> --password <WALLET PASSWORD> set ask-password 0 register_service_node auto ... Running this command if you have already staked will not stake over the top of an already staked node Express Setup Guide \u00b6 This section is for power users who are more familiar with servers and the CLI interface. There's a couple of things your going to want to do before you commence. 1. Get a Server that meets requirements 2. Run the Daemon on a server from a non-root user account, then stake from a local wallet (or a wallet on a separate server). where <VERSION> is mentioned replace with the latest version , example 1.0.3 3. Connect via SSH to your server 4. add new user sudo adduser snode <enter> Y exit 5. login to your new user account via SSH snode@<ipaddress> 6. Update necessary security patches and system utilities sudo apt-get update sudo apt-get upgrade 7. Download & unzip Loki wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip sudo apt-get install unzip unzip loki-linux-x64-<VERSION>.zip 8. Run Loki in a screen and Detach Screen <enter> cd loki-linux-x64-<VERSION> ./lokid --service-node Ctrl +AD Wait for the Loki Daemon sync the blockchain (1 - 8 Hours depending on internet speed) 9. Open a Wallet This wallet can be in a screen on the Service Node machine, or a wallet on your local computer (assuming you have downloaded the binaries). cd loki-linux-x64-<VERSION> Linux/MAC - ./loki-wallet-cli Windows - loki-wallet-cli Enter Name: Name your wallet Enter password Language: 1 (for English) Securely store: 1. Address 2. Seed Phrase 3. Pass-phrase Send enough Loki to fund a node, wait for Balance to be unlocked (20 mins, 10 confirmations) 10. Register your Service Node On your Service Node reattach to the screen which has the Service Node running. screen -r prepare_registration Contribute entire Stake: Y/N Enter Loki Address Enable Restaking: Y/N Confirm: Y Copy green registration message Ctrl +AD 11. Reattach to Service Node or local wallet Paste in registration message <enter> 12 Attach Back to Service Node Daemon screen -r print_sn_key Copy service node key, and search for it on: https://lokiblocks.com/service_nodes CTRL +AD ctrl +ad detaches screen and runs your Loki Service Node in background this is critical Conclusion \u00b6 Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus Add the community-run telegram bot @lokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 View jagerman.com/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Service Node Full Guide"},{"location":"ServiceNodes/SNFullGuide/#full-guide-on-service-nodes","text":"This document will tell you exactly how to set up and operate a Service Node for the Loki Project. This document was written with non-developers in mind, so people new to linux or command line operations should be able to follow along without any trouble. Also available is a video guide, which provides a more simplified version of the written guide, it can be viewed here . If you feel confident around servers and the CLI, then skip to the Express Setup Guide You can of course run the Loki software on any operating system that you can get it to build on, but for the purposes of this document, the instructions apply to running a Service Node on a remote Ubuntu 16.04 server. If that isn\u2019t what you want to do, syntax and server set up will of course differ according to whatever OS you choose to run your Service Node from.","title":"Full Guide on Service Nodes"},{"location":"ServiceNodes/SNFullGuide/#summary-of-loki-service-node-requirements","text":"Full summary of Loki Service Node Requirements. This may change depending on Service Node functionality, so you should check here regularly, or follow our telegram / discord announcements channel. Spec Note Latest Binary loki-linux-x64-1.0.3 Software Ubuntu 16.04 Memory 30-50gb Ram 2-4 gb","title":"Summary of Loki Service Node Requirements"},{"location":"ServiceNodes/SNFullGuide/#table-of-contents","text":"Overview of Service Nodes New User Guide Step 1 Server Step 2 Server Prep Step 3 Download Binaries Step 4 Run the Loki Daemon Step 5 Open a Loki Wallet Step 6 Register Node Step 7 Check Registration Express Setup Guide Additional Functions","title":"Table of Contents"},{"location":"ServiceNodes/SNFullGuide/#overview","text":"To understand what a Service Node is, you can refer to the whitepaper to get an in depth understanding. For now, all you need to know is that: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki for 30 days (2 days on testnet) and submits a registration transaction Once accepted by the network, the Service Node is eligible to win block rewards Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay in a novel mixnet Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions (Blink) Act as remote nodes for users Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. For the purposes of this guide, however, we will only consider the current requirements.","title":"Overview"},{"location":"ServiceNodes/SNFullGuide/#new-user-guide","text":"This section of this guide is for new users to servers and the CLI interface.","title":"New User Guide"},{"location":"ServiceNodes/SNFullGuide/#step-1-get-a-server","text":"Righto! Let\u2019s get started. Choosing where to set up a Service Node is the biggest choice you will make when running a Service Node. There are a number of things to consider. Because you will be locking up funds for 30 days (2 days for testnet) at a time, you will want to ensure that your server has: A stable, relatively fast connection to be able to respond to ping requests to avoid being booted off the network We recommend 2GB of RAM to cope with running the software reliably ( Note: This requirement may be much greater once services are live ). 1GB is fine for testing. At Least a 20GB SSD or Hard disk drive, this will be used to store the blockchain ( Note: to future proof yourself against blockchain growth and message storage we recommend a 30 - 40 GB drive ) A stable power supply. If your server goes down during the staking period, you may get kicked off the network, and not receive rewards while your funds are still locked for the remainder of the staking period. For most users, we assume that your home internet connection is relatively slow (< 4MB/s down and up) and probably lacks support for external connections. If this is the case, you will probably not want to run a Service Node from your home in the long term, as this could cost you if and when you get booted off. Since we\u2019re just testing at the moment, you could run it from home anyway, but for this guide we\u2019ll avoid it. Typically, the easiest and cheapest way to host a server outside of your home is to use a Virtual Private Server (VPS). There are thousands of options when it comes to VPS providers, but for now, just about any one will do. In the future, selection will be made more difficult because most providers will not allow exit node traffic, so we have compiled a list of exit node friendly providers to choose from if you want to stay with your provider for more than a few months. Hosting Provider Product Name Cost Per Month $USD Bandwidth Provided Exit Friendliness Rating Netcup VPS 1000 G8 10.50 30 - 35 MiB\u2019s 5 / 10 Online.net Start-2-S-SSD 13.99 15 - 17 MiB\u2019s 9 / 10 Scaleway START1-M 9.33 20 - 25 MiB\u2019s 7 / 10 OVH VPS SSD 2 7.61 10 - 15 MiB\u2019s 9 / 10 Leaseweb Virtual Server XL 34.45 30 - 35 MiB\u2019s 5 / 10 Digital Ocean 2 GB, 2 vCPUs 15 9 - 11 MiB\u2019s 8 / 10 Feral Hosting Neon Capability 19.68 9 - 11 MiB\u2019s 9 / 10 Trabia VDS-8G 38.54 9 - 11 MiB\u2019s 8 / 10 Hetzner EX41-SSD (30 TB) 39.71 80 - 40 MiB\u2019s 4 / 10 Try not to pick the first one off the list. Do some digging and see which one looks the best to you, what your budget is, and what the latency is like for you based on the server location that you choose. When selecting your VPS\u2019 operating system, choose Ubuntu 16.04 64 bit or Ubuntu 18.04 64 bit if you want to follow this guide. If you feel more confident or wish to run your server on another distribution or operating system, the Loki commands in this guide will still apply.","title":"Step 1 - Get a Server"},{"location":"ServiceNodes/SNFullGuide/#step-2-prepare-your-server","text":"Every provider has a slightly different way of issuing you access to your new VPS. Most will send an email with the IP address, root username, and a root password of the VPS. To access your server, you will need a SSH client for your operating system. Because we\u2019re on Windows today, we\u2019ll download PuTTY, Mac users can also use PuTTY. If you\u2019re a Linux user, you probably don\u2019t want us telling you where to get a SSH client from. To connect to our VPS we will need to paste the IP address into the SSH client\u2019s \u201cHost Name (or IP address)\u201d input box and click the \u201cOpen\u201d button. The Port number can usually just be left as 22 . A terminal window will now appear prompting for your log-in details, username(root) and password, which were provided by your VPS provider. When entering your password, nothing will visually appear in the terminal. This is normal. Hit enter when it\u2019s typed or pasted, and you should be logged in to your VPS.","title":"Step 2 - Prepare your Server"},{"location":"ServiceNodes/SNFullGuide/#hot-tips-for-using-the-console","text":"Consoles don't work like the rest of your computer. Here are some basic tips for navigating your way around the command line! Don't try copying something by using the usual Ctrl + C hotkey! If you want to copy something, do so by highlighting text and then right clicking it. Pasting works by right clicking a blank area in the console. If you want to kill a process or stop something from running, press Ctrl + C. This is why you shouldn't try copying something with this hotkey ;) You can always check the directory you are in and its contents by typing ls You can always return to your home directory by typing cd ~ You can move into a given directory by typing cd <name> or move back up one level by typing cd .. PuTTY allows you to easily duplicate or restart a session by right clicking the top of the window. Handy if you\u2019re trying to do a few things at once. Once we have logged in correctly to the VPS for the first time, the terminal may prompt us for a new password for our root account. The terminal will require you to enter the new password twice before we can start running commands.","title":"Hot Tips for using the Console"},{"location":"ServiceNodes/SNFullGuide/#optional-set-up-non-root-user","text":"Best practice when running a public server is to not run your software as the root user. Although it is optional, we will create a non-root user to our VPS by running the following command. sudo adduser <username> Replacing <username> with a name you will log-in with. For this user-guide we will use snode as our username. sudo adduser snode The terminal will prompt you for a new password for our newly created user. Use a different password to the root password. Once the password has been set, the terminal will prompt for a few details about the individual running the user. You can hit enter through each of the inputs as the details are not important for the purposes of running a Service Node. Once that\u2019s done, run the following two commands to give our new account admin privileges and to change to such account. sudo usermod -aG sudo snode su - snode Before we proceed further, it is advised to close your terminal and reopen PuTTY to set up a saved session with our snode user. Your SSH client will have a load and save session function. For PuTTY we will need to type in our VPS IP address again, on the same screen type snode under \u201cSaved Session\u201d. Click on \u201cData\u201d under the drop-down menu \u201cConnection\u201d, and type in snode (or your username defined before) into the input box \u201cAuto-login username\u201d. Go back to your session screen, where we entered the IP address, and click \u201cSave\u201d. You can load this session whenever you want to check on your Service Node.","title":"Optional - Set up Non-root User"},{"location":"ServiceNodes/SNFullGuide/#server-preparation-continued","text":"We should update our package lists, the below command downloads the package lists from the repositories and \"updates\" them to get information on the newest versions of packages and their dependencies. It will do this for all repositories and PPAs. sudo apt-get update You will notice a bunch of package lists were downloaded, once this is complete run the below command to fetch new versions of any packages we currently have installed on the system. sudo apt-get upgrade You will be prompted to authorise the use of disk space, type y and enter to authorise. If you are prompted at any time that a version of any file is available then click the up and down arrows until you are hovering over install the package maintainer\u2019s version and click enter. Alright, good to go. Our server is now set up, up to date, and is not running in root. On to the fun part!","title":"Server Preparation Continued"},{"location":"ServiceNodes/SNFullGuide/#step-3-download-the-loki-binaries","text":"First download the Linux binaries by running the following command: wget <link> Where <link> is the download link of the latest linux release. To find the link go to https://github.com/loki-project/loki/releases/latest , right click the latest linux release and click Copy Link Location . Your command should look something like: wget https://github.com/loki-project/loki/releases/download/1.0.3/loki-linux-x64-1.0.3.zip If wget is not installed you may need to run sudo apt-get install wget To get to the binaries, we need to unzip them. Download and install unzip by running the following command. sudo apt-get install unzip If unzip is not installed you may need to run sudo apt-get install unzip To unzip the downloaded zip file run the following command: unzip loki-linux-x64-1.0.3.zip You should see 8 files unzipped: loki-blockchain-export loki-wallet-cli loki-blockchain-usage lokid loki-blockchain-blackball loki-wallet-rpc loki-blockchain-import Loki-gen-trusted-multisig Check they are unzipped by running: ls If not, sometimes unzip will dump the binaries in a folder. In our case the folder would be called loki-linux-x64-1.0.3 , so to get into it we can type: cd loki-linux-x64-1.0.3 To check that they are in that folder, once again, type: ls Excellent! We now have all of the necessary files to get this show on the road! NOTE: If you\u2019re nervous about trusting the binaries or the link, you should build it from source yourself. Instructions for that can be found in the README of https://github.com/loki-project/loki","title":"Step 3 - Download the Loki Binaries"},{"location":"ServiceNodes/SNFullGuide/#step-4-run-the-service-node-daemon","text":"Let\u2019s start up the daemon so we can sync the blockchain and register our Service Node. The problem with the terminal we currently have open is that once we close PuTTY the program running inside it will also shut down. We can run a program called screen which can keep our Service Node running for 30 days without having to look at it all the time. The screen command is generally included in Ubuntu by default. If it isn\u2019t, run sudo apt install screen . Running it opens up a terminal shell inside your session that will continue to run in the background once you detach it from the session. Type the following command: screen Enter through the information that the terminal shell is providing until we get back a blank screen awaiting an input. To begin the Service Node daemon we must launch lokid with the flag --service-node . ./lokid --service-node If you are testing the daemon on testnet run the following command ./lokid --service-node --testnet The daemon will now start syncing. You won\u2019t be able to do much if it hasn\u2019t synced. To have the daemon to continue to run in the background hold Ctrl and type ad. To test your screen is still running in the background run the command screen -ls and take note of the port number at the start of the screen. This number will help us re-enter the daemon at future times. Typing screen -x <port number> will reattach the session so we can see what\u2019s going on inside. Hold CTRL and type \"ad\" again to detach the screen once more. For now, we can just leave the session open to see the daemon messages while we set up the Service Node. Just don't forget to use CTRL + A + D to detach the session before you close PuTTY later on.","title":"Step 4 - Run the Service Node Daemon"},{"location":"ServiceNodes/SNFullGuide/#step-5-getopen-a-wallet","text":"While we wait for the daemon to sync, we can now get a wallet going. You do not have to run this wallet on the server and you should not! Download the software and run it from elsewhere for security reasons! You can run the CLI wallet (Command Line Interface wallet) on any other computer, including your home computer to avoid leaving your wallet on the server. However, if you do want to run the CLI wallet on another computer, you will either need to run another daemon on that local machine or use a remote node (uk.loki.cash:22020, for example). There is also a list of trusted remote nodes in the Loki Project Discord channel under #links-and-resources. Alternatively if your Service Node is synced up, you could actually use the address of that daemon. When you run 'loki-wallet-cli' locally and wish to use a remote daemon, use the syntax: ./loki-wallet-cli --daemon-address <insert address here> Or on windows: loki-wallet-cli.exe --daemon-address <insert address here> If you are made of money and are willing to take the small risk of losing all of your funds, you can continue running the wallet inside the Service Node VPS. So we don't have to talk about a myriad of other operating systems or potential user cases, the rest of this guide will assume you are running the wallet in the same VPS. As such, it\u2019ll probably save us time to open a second PuTTY session. You can do this by right clicking the window of the current PuTTY session and clicking \u201cDuplicate Session.\u201d Log in to your non-root user that we set up before, in our case snode, and once in we should open a new screen by typing screen and hitting return twice. Change directory to where our binaries are saved: cd loki-linux-x64-1.0.3 Then to launch the wallet run the command: ./loki-wallet-cli If you are on testnet run the command with the --testnet flag: ./loki-wallet-cli --testnet When loki-wallet-cli first runs, it will request for you to specify a wallet name. Assuming we haven't created one yet, we will use the e.g. name MyWallet Because this is the first time we have used the name MyWallet the client will prompt us to create a new wallet. Type y and click return to continue. The loki-wallet-cli has generated us a wallet called MyWallet and is now prompting us for a password. Note: - When typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character you type including if it is capitalised or lowercase. - Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. - Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing in 1 and clicking return. The CLI will generate and spit out several lines of text. The first two lines of text show your wallet public address. This address can be shared, will be used to receive Loki to your wallet, and will be used during the preparation and registration of our Service Node. All Mainnet Loki public addresses start with an L and are followed with a string of characters, Testnet Public addresses start with a T. The public address shown will be your primary address, however multiple public addresses can be generated from this primary address. Line 13 to 17 show your 25-word mnemonic (\u201cnew-monic\u201d) seed. The seed is used to easily backup and restore your wallet without needing any other information. At this stage, grab a pen and paper, and write down your 25 words in order. Store the piece of paper in a safe and secure place, if your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your wallet. It is at this point that we should get some Loki in the wallet. The amount of Loki required to run a node is derived from the function shown in Lokis Cryptoeconomic paper . Don't worry if you cant work out the formula, you can use this community created tool or, the daemon will display the amount of Loki required to run the node. If you do not have enough you will have the option to join in or run your own Service Node pool. If you are running a Service Node on the testnet you will only ever require 100 testnet Loki to run the Node. You can ask someone in the Loki Discord Community for some testnet Loki, or alternatively you can run the command start_mining in your wallet. This may take an hour or two to get enough Loki. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet We will need our address to register our Service Node later, to get your primary address type the following command: address Highlight the string of characters that were outputted and save this in a notepad for later use, your public address should look similar to: LPoiZQ43qG18FzKq7WhEbk3gfNNiemGsd7REdSQaFv4RdB8E97RxP8WFLRR2xHQStiSM61EFEicXU3EEPj7GEHdz8WHUrWRkbGeQ1r8ro8 NOTE: Do not use CTRL + C to copy your address, it will close the wallet down. Simply highlight the address and this will automatically save the portion you highlighted into your clipboard. Once you have enough Loki in this wallet, just leave it open, we\u2019ll come back to it in a minute.","title":"Step 5 - Get/Open A Wallet"},{"location":"ServiceNodes/SNFullGuide/#step-6-service-node-registration","text":"The next part of the guide will split into two sections: If you are an individual staker and do not require any other contributors to run your Service Node jump into 6.1 - individual Staking . If you want to run a pooled Service Node or contribute towards a pool jump into 6.2 - Pool Staking","title":"Step 6 - Service Node Registration"},{"location":"ServiceNodes/SNFullGuide/#61-individual-staking","text":"If you want to run the Service Node as an individual you will require the following things. A Loki daemon running with --service-node flag (see step 4). A loki-wallet-cli primary address with enough Loki in your account to meet the Service Node Staking Requirement (see step 5). Now if we have the two above items we can proceed to our daemon to register our Service Node. Type screen -ls to get a list of the screens running. Your daemon will normally be the bottom one on the list. To enter our daemon run the following command, replacing <port number> with the number that corresponds with your daemon. screen -x <port number> To start the registration process we are going to run the following interactive command within the daemon terminal: prepare_registration The daemon will output the current staking requirement and prompt you with an input to clarify if you are an individual staker or you will be running a pool. Type y and click enter as we will be the sole staker. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your Loki Address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address. Double check the address matches the one of your wallet then click enter if it is the same. The daemon will now ask if you wish to enable automatic re-staking. Type y and click enter if you would like to have your Service Node re-stake automatically for you at the end of every 30 days. Type n if you would like to re-stake manually. The daemon will now ask for a final confirmation, if you agree to the information provided type y and click enter. The daemon will output a command for us to run looking similar to: register_service_node 4294967292 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 4294967292 100.000000000 1535677391 ec3895ea70a4a91b5ec4b5e1df96a45e07046f1fb0123c754d98fb2d70f4529d 5bb35d7b8ab1acb943bc47913ada8f9d2e6d6e22264e57484a04c1bbfd461f0ee2e5435454cd9b7059b221eb506ce9ea4537ddd9faf1f1757e0ef611a41c0609 Copy the whole line of text and paste it into your notepad as we will need to run this command in our loki-wallet-cli . if registering multiple nodes, please wait at least 10 blocks between Service Nodes before running the register Service Node command in the wallet You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. We do not require our daemon terminal anymore, however we do need to daemon to be running. Hold CTRL and type ad to detach the screen. Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. Alternatively, you can also include the auto command, this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. register_service_node auto args..... If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop the auto command. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Well done! Let's continue to the next step \"Step 7 - Service Node Check\" to check if our Service Node is running.","title":"6.1 - Individual Staking"},{"location":"ServiceNodes/SNFullGuide/#62-pool-staking","text":"Service Nodes can be split between multiple parties. At a minimum, the operator must stake at least 25% of the total required amount. The operator can also reserve contribution slots for specific addresses to prevent random users from adding to the pool. In any given pool, there will be at most 4 contributors including the operator. After the operator, each new participant must also contribute 25% of the minimum, except the last one. So for example, valid splits might be: Operator Contributor 1 Contributor 2 Contributor 3 25% 25% 40% 10% 65% 25% 10% 90% 10% 99% 1% Depending on the individual and their circumstance they will need to: Jump into section \"6.2.1 - Operator\" if they are running the daemon and hosting the pool; Jump into section \"6.2.2 - Pool Contributor\" if they are contributing to someone's Service Node. NOTE: It is advised to read both sections of \"6.2 - Pool Staking\" to have a better understanding of the process.","title":"6.2 - Pool Staking"},{"location":"ServiceNodes/SNFullGuide/#621-operator","text":"The Operator is the individual who will be hosting the pool and running the Service Node daemon, thus incurring the operating expenses encompassed by running a node. The Operator will need to have: A Loki daemon running with --service-node flag (see step 4) at all times. A loki-wallet-cli primary address with enough Loki in their account to meet 25% of the Staking Requirement. 1-3 other contributors who also have a loki-wallet-cli with enough Loki in their accounts to meet 25% of the staking requirement. The address and contribution amounts the 1-3 contributors will stake. NOTE: The other contributors addresses are optional to have as you can create your pool to be open to anyone to contribute to, however they are recommended to have to avoid any issues of other individuals stealing their spots. Now if we have the three/four above items we can proceed to our daemon to register our Service Node. Type screen -ls to get a list of the screens running. Your daemon will normally be the bottom one on the list. To enter our daemon run the following command, replacing <port number> with the number that corresponds with your daemon: screen -x <port number> To start the registration process we are going to run the following interactive command within the daemon terminal: prepare_registration The terminal will prompt the operator to specify if they will contribute the entire stake, because we are running this as a pooled Service Node we will type n and click enter. Next the terminal will request the input for the operator cut. This value is between 0-100 and represents the percentage of the reward the operator will receive before the reward is distributor to the share holders. If you have agreed to a 10% operator cut with the other contributors you would type 10 and click return. The terminal will now display the minimum reserve the operator can contribute and request the operator to input the amount in Loki they wish to contribute. Type your desired <operator contribution> and click return. Once we have set the operators desired stake amount we have the option to either leave the pool open for anyone to contribute or lock a reserve for individuals that have agreed with us to stake within our Service Node.","title":"6.2.1 - Operator"},{"location":"ServiceNodes/SNFullGuide/#reserved-pool","text":"If the operator wishes to have their pool closed they should type y and click continue. The terminal will now prompt the operator for the number of additional contributors they have organised to be apart of this Service Node. They must type in the number of contributors, not including themselves, and click return. The daemon will now prompt us for the Loki address of the operator. If you followed step 5 you should have this address saved in a notepad, if not run through step 5 again to find your address. Once we have the Loki Address copied to our clipboard we can then right click the terminal screen to paste the address then click return to confirm your address. Next the operator must input each of the contributors amount of Loki they will stake and each contributors address. The daemon will now ask if you wish to enable automatic re-staking. Type y and hit return if you would like to have your Service Node re-stake automatically at the end of every 30 days. Type n if you would like to re-stake manually. You will now be asked to confirm the information above is correct.","title":"Reserved Pool"},{"location":"ServiceNodes/SNFullGuide/#open-pool","text":"If the operator wishes to leave their pool open they should type n and click continue. The terminal will prompt the operator to input their address. Once the address has been inputted the terminal will display the remaining portion that needs to be contributed by others. If you agree click y and hit return. The daemon will display a summary of the information we entered. This is our chance for a final check over to make sure we entered in the right information. If you confirm the information is correct type y and click return. The daemon will output a command for us to run within our wallet, looking similar to: register_service_node 214748364 T6UCEoWvJHCJq5biK3LMQZ4CRXAaqiPda2kCRRYYYEMFfxYoqnUo7Nx88RL3wmENwN4kfjDSp2jMN1g6PSErKrSu2EEp8UMy5 1073741823 T6TCCyDgjjbddtzwNGryRJ5HntgGYvqZTagBb2mtHhn7WWz7i5JDeqhFiHqu7ret56411ZJS7Thfeis718bVteBZ2UA6Y7G2d 3221225469 25.000000000 1535692249 5dac247e90ced2dcd9e51faec8792acb0c11b4c700640d9104b17c868ea167e3 cc11eef804c11d3e93cf8c488c10d97b8cec9ee2b38e6666ff07749c2911aa06ce310edc926a4d2f50a588e9c15afcc20e935a0f188aa7caa764a62058dec80d NOTE: You must run the command outputed in your daemon and not the command shown above. Copy the whole line of text in your daemon and paste it into your notepad as we will need to run this command in our loki-wallet-cli . You have 2 weeks from the moment of registering the Service Node to run the register_service_node command, however it is advised to do it as soon as possible. Before we leave the daemon run the following command to get our <Service Node Public Key> and save it in your notepad: print_sn_key Run through step 5 once more to open our Loki wallet. Once we are in our wallet run the command the daemon outputted for us when we prepared our Service Node. The wallet will prompt us to confirm our password, then the amount of Loki to stake. Confirm this by typing y and clicking enter. Alternatively, the operator can also include the auto command, when staking this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. register_service_node auto args..... If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop the auto command. We must now send the <Service Node Public Key> to our contributors with the amount of Loki they are required to stake. At this point the we will need to wait until all contributors have staked before rewards will be received.","title":"Open Pool"},{"location":"ServiceNodes/SNFullGuide/#622-pool-contributor","text":"The pool contributor must first receive the Service Node Pubkey and the requirements (amount of loki to send) from the Service Node Operator. If you are staking please do not use Subaddresses. They are currently unsupported by the Loki wallet The pool contributor must have downloaded the necessary binaries, is running a daemon or is connected to a remote node, has generated a wallet through the loki-wallet-cli , and has enough Loki to stake. They can then run the following command in their loki-wallet-cli . stake <Service Node Pubkey> <address> <contribution amount> Where the <Service Node Pubkey> is the Pubkey provided from the Service Node operator, the <address> the service node operator will likely reserve an address for which they want you to stake for, this will usually be the same address as the wallet you are planning to stake from, in the case of an open pool this will always be the address you will you stake from and you will also receive rewards here too. <contribution amount> is the amount of Loki they are going to stake which they agreed to with the Service Node Operator. The Pool Contributor can also include the auto command, when staking this will create a wallet which runs as a background process and automatically signs a register transaction each 30 days, so the contributor need not sign a new transaction manually each registration period. stake auto <Service Node Pubkey> <address> <contribution amount> If you run the auto command the wallet will close pushing the process into the background. See additional information at the end of this guide to learn how to stop autostaking. The auto command does not work with a multsig wallet as there is a requirement for the party who is staking to have the transaction signed by another signer. Thus is it advised if you are using a multisig wallet to maintain the staking once a month when the funds are unlocked. At this stage you will need to wait for the other contributors to provide their collateral. Once everyone has staked you can refer to \u201cStep 7 - Service Node Check\u201d to see where your Service Node Operator\u2019s node is in the list. Congratulations, you are now staking.","title":"6.2.2 - Pool Contributor"},{"location":"ServiceNodes/SNFullGuide/#step-7-service-node-check","text":"After we have locked your collateral we will need to check if our Service Node Pubkey is sitting in the list with the other Service Node\u2019s on the network. This will prove our Service Node is running, recognised and will receive a reward if it keeps running. Let\u2019s go into our daemon screen by typing screen -x <port number> . To find the port number use screen -ls and your daemon should be sitting at the bottom of the list. Once we are in the daemon again we can run the following command to see our Service Node Public Key: print_sn_key The Service Node Public Key is used to identify our Service Node within the list of Service Nodes currently on the network. You can jump onto https://lokiblocks.com/ to see if your Service Node is in the list or we can continue in the terminal to output the same information. If you are running your Service Node on testnet go to https://lokitestnet.com/ instead. We will want to know the current block height, type status into the daemon and it will output this information. Once we have the block height we can then check the current Service Nodes on the network at our specified block height. Run the command print_quorum_state <block height> replacing <block height> with the number minus 1 that was outputted when running status command. If your <Service Node Pubkey> is sitting in the list you know you are now staking.","title":"Step 7 - Service Node Check"},{"location":"ServiceNodes/SNFullGuide/#additional-functions","text":"","title":"Additional Functions"},{"location":"ServiceNodes/SNFullGuide/#autostaking-checkingstopping-autostake-command","text":"To check the processes running in the background, run the command: top -u <username> Under the COMMAND column we should see a process called loki-wallet-cli . If you do not see this process you are either looking at the wrong <username> or your autostake command is not running. If you want to stop the autostake then run the following command while logged on to the specific <username> which has loki-wallet-cli running in the background: pkill loki-wallet-cli ### Running Autostake on startup If the host machine your VPS is running on shuts down or restarts unexpectedly then so to will your your autostaking wallet, you can use the following command to start the autostaking wallet again, you can also include these commands in your startup scripts, ensuring if your node goes down it automatically restarts the wallet process. loki-wallet-cli --testnet --wallet-file <PATH TO WALLET FILE> --password <WALLET PASSWORD> set ask-password 0 register_service_node auto ... Running this command if you have already staked will not stake over the top of an already staked node","title":"Autostaking - Checking/stopping autostake command"},{"location":"ServiceNodes/SNFullGuide/#express-setup-guide","text":"This section is for power users who are more familiar with servers and the CLI interface. There's a couple of things your going to want to do before you commence. 1. Get a Server that meets requirements 2. Run the Daemon on a server from a non-root user account, then stake from a local wallet (or a wallet on a separate server). where <VERSION> is mentioned replace with the latest version , example 1.0.3 3. Connect via SSH to your server 4. add new user sudo adduser snode <enter> Y exit 5. login to your new user account via SSH snode@<ipaddress> 6. Update necessary security patches and system utilities sudo apt-get update sudo apt-get upgrade 7. Download & unzip Loki wget https://github.com/loki-project/loki/releases/download/v<VERSION>/loki-linux-x64-<VERSION>.zip sudo apt-get install unzip unzip loki-linux-x64-<VERSION>.zip 8. Run Loki in a screen and Detach Screen <enter> cd loki-linux-x64-<VERSION> ./lokid --service-node Ctrl +AD Wait for the Loki Daemon sync the blockchain (1 - 8 Hours depending on internet speed) 9. Open a Wallet This wallet can be in a screen on the Service Node machine, or a wallet on your local computer (assuming you have downloaded the binaries). cd loki-linux-x64-<VERSION> Linux/MAC - ./loki-wallet-cli Windows - loki-wallet-cli Enter Name: Name your wallet Enter password Language: 1 (for English) Securely store: 1. Address 2. Seed Phrase 3. Pass-phrase Send enough Loki to fund a node, wait for Balance to be unlocked (20 mins, 10 confirmations) 10. Register your Service Node On your Service Node reattach to the screen which has the Service Node running. screen -r prepare_registration Contribute entire Stake: Y/N Enter Loki Address Enable Restaking: Y/N Confirm: Y Copy green registration message Ctrl +AD 11. Reattach to Service Node or local wallet Paste in registration message <enter> 12 Attach Back to Service Node Daemon screen -r print_sn_key Copy service node key, and search for it on: https://lokiblocks.com/service_nodes CTRL +AD ctrl +ad detaches screen and runs your Loki Service Node in background this is critical","title":"Express Setup Guide"},{"location":"ServiceNodes/SNFullGuide/#conclusion","text":"Well done! You will receive a block reward when your Service Node has been active for some time and the network chooses you within the list. Bonus Add the community-run telegram bot @lokiSNBot to receive on-the-fly updates about your service node. Props to @jagerman42 for building this. Bonus 2 View jagerman.com/sn/ for more details on Loki Service Node staking requirements. This guide will be regularly updated when new features are added to Snodes. Join the discord for more discussion. If you can improve this guide, please submit a pull request.","title":"Conclusion"},{"location":"ServiceNodes/SNOverview/","text":"Service Nodes Overview \u00b6 Although Loki implements novel changes on top of the CryptoNote protocol (see 7), much of Loki\u2019s networking functionality and scalability is enabled by a set of incentivised nodes called Service Nodes. To operate a Service Node, an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block. The resulting network provides market-based resistance to Sybil attacks , addressing a range of problems with existing mixnets and privacy-centric services. This resistance is based on supply and demand interactions which help prevent single actors from having a large enough stake in Loki to have a significant negative impact on the second-layer privacy services Loki provides. DASH first theorised that Sybil attack resistant networks can be derived from cryptoeconomics. As an attacker accumulates Loki, the circulating supply decreases, in turn applying demand-side pressure, driving the price of Loki up. As this continues, it becomes increasingly costly for additional Loki to be purchased, making the attack prohibitively expensive. To achieve this economic protection, Loki encourages the active suppression of the circulating supply. In particular, the emissions curve and collateral requirements must be designed to ensure enough circulating supply is locked and reasonable returns are provided for operators to ensure Sybil attack resistance. Service Node Activities \u00b6 Right now Service Nodes can: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki for 30 days (2 days on testnet) and submits a registration transaction Once accepted by the network, the Service Node is eligible to win block rewards Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay in a novel mixnet Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions (Blink) Act as remote nodes for users Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth. Terms \u00b6 Service Node : Full nodes on the Loki Network. Staking Requirement : Collateral requirement to run a Service Node. Sybil Resistance : >> Add information Guides & Resources \u00b6 Setting up Service Node : How to host and maintain a Service Node using the CLI wallet . Service Node as Service : How to run the daemon to automatically start after a crash or reboot, which helps your Service Node keep running without undesired interruptions. Service Node RPC : How to use JSON 2.0 RPC Calls with Service Nodes. Active Service Node List : Loki Block explorer showing the current Service Node Pubkeys.","title":"Overview"},{"location":"ServiceNodes/SNOverview/#service-nodes-overview","text":"Although Loki implements novel changes on top of the CryptoNote protocol (see 7), much of Loki\u2019s networking functionality and scalability is enabled by a set of incentivised nodes called Service Nodes. To operate a Service Node, an operator time-locks a significant amount of Loki and provides a minimum level of bandwidth and storage to the network. In return for their services, Loki Service Node operators receive a portion of the block reward from each block. The resulting network provides market-based resistance to Sybil attacks , addressing a range of problems with existing mixnets and privacy-centric services. This resistance is based on supply and demand interactions which help prevent single actors from having a large enough stake in Loki to have a significant negative impact on the second-layer privacy services Loki provides. DASH first theorised that Sybil attack resistant networks can be derived from cryptoeconomics. As an attacker accumulates Loki, the circulating supply decreases, in turn applying demand-side pressure, driving the price of Loki up. As this continues, it becomes increasingly costly for additional Loki to be purchased, making the attack prohibitively expensive. To achieve this economic protection, Loki encourages the active suppression of the circulating supply. In particular, the emissions curve and collateral requirements must be designed to ensure enough circulating supply is locked and reasonable returns are provided for operators to ensure Sybil attack resistance.","title":"Service Nodes Overview"},{"location":"ServiceNodes/SNOverview/#service-node-activities","text":"Right now Service Nodes can: Service Nodes are full nodes on the Loki network Full nodes become Service Nodes when the owner locks the required amount of Loki for 30 days (2 days on testnet) and submits a registration transaction Once accepted by the network, the Service Node is eligible to win block rewards Multiple participants can be involved in one Service Node and can have the reward automatically distributed It is also worth noting that Service Nodes are quite basic at the moment, and operators will need to stay up to date with new updates to keep in line with software and hardware requirements. Once all of the updates are out, Service Nodes will also: Route end user\u2019s internet traffic, either as an exit node or relay in a novel mixnet Receive, store and forward encrypted user messages Monitor other Service Nodes and vote on their performance Be called into quorums which give them authority over instant transactions (Blink) Act as remote nodes for users Once these features come out, Service Node operation will require better servers, particularly when it comes to bandwidth.","title":"Service Node Activities"},{"location":"ServiceNodes/SNOverview/#terms","text":"Service Node : Full nodes on the Loki Network. Staking Requirement : Collateral requirement to run a Service Node. Sybil Resistance : >> Add information","title":"Terms"},{"location":"ServiceNodes/SNOverview/#guides-resources","text":"Setting up Service Node : How to host and maintain a Service Node using the CLI wallet . Service Node as Service : How to run the daemon to automatically start after a crash or reboot, which helps your Service Node keep running without undesired interruptions. Service Node RPC : How to use JSON 2.0 RPC Calls with Service Nodes. Active Service Node List : Loki Block explorer showing the current Service Node Pubkeys.","title":"Guides &amp; Resources"},{"location":"ServiceNodes/StakingRequirement/","text":"TO DO","title":"Staking Requirement"},{"location":"Wallets/Multisigniture/","text":"Multisignature \u00b6 In cryptocurrencies, multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Use cases: Shared account (1-of-2; both husband and wife individually have full access to their funds) Consensus account (2-of-2; both husband and wife must agree to spend their funds) Threshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree) Secure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks) Arbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers) Loki Multisignature \u00b6 Loki doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting and Loki has brought this code from Moneros code base. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Loki there is no multisig addresses as such. The Address structure does not care how the underlying private spend key got created. In Loki, only N-of-N and (N-1)-of-N multisignature schemes are supported. This covers all common scenarios mentioned above but does not allow for arbitrary voting (like \"3-of-5 board members\"). After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign. Guides \u00b6 2-of-2 Multisigniture Wallet Setup - Setup Guide for a 2 of 2 Multsig Wallet. 2-of-3 Multisigniture Wallet Setup - Setup Guide for a 2 of 3 Multsig Wallet.","title":"Multsigniture"},{"location":"Wallets/Multisigniture/#multisignature","text":"In cryptocurrencies, multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with M-of-N keys. Use cases: Shared account (1-of-2; both husband and wife individually have full access to their funds) Consensus account (2-of-2; both husband and wife must agree to spend their funds) Threshold account (2-of-3; an escrow service is involved as an independent 3rd party, to co-sign with either the seller, or with the buyer, if seller and buyer do not agree) Secure account (2-of-3; a single owner controlls all 3 keys but secures them via a different means to diversify risks) Arbitrary threshold account (M-of-N; some cryptocurrencies provide full flexibility on the number of signers)","title":"Multisignature"},{"location":"Wallets/Multisigniture/#loki-multisignature","text":"Loki doesn't directly implement multisignatures (at least not in a classical sense). Monero emulates the feature by secret splitting and Loki has brought this code from Moneros code base. Transactions are still signed with a single spend key. The spend key is a sum of all N private keys. The rationale for such design is to decouple multisig from ring signatures. Let's consider the 2-of-3 scheme. We have 3 participants. Each participant is granted exactly 2 private keys in a way that pairs do not repeat between participants. This way any 2 participants together have all 3 private keys required to create the private spend key. Multi-signing is a wallet-level feature. There is no way to learn from the blockchain which transactions were created using multiple signatures. It is also worth noting in Loki there is no multisig addresses as such. The Address structure does not care how the underlying private spend key got created. In Loki, only N-of-N and (N-1)-of-N multisignature schemes are supported. This covers all common scenarios mentioned above but does not allow for arbitrary voting (like \"3-of-5 board members\"). After multisig wallet setup every participant ends up knowing the public address and private view key. This is necessary for participants to recognize and decipher transactions they are supposed to co-sign.","title":"Loki Multisignature"},{"location":"Wallets/Multisigniture/#guides","text":"2-of-2 Multisigniture Wallet Setup - Setup Guide for a 2 of 2 Multsig Wallet. 2-of-3 Multisigniture Wallet Setup - Setup Guide for a 2 of 3 Multsig Wallet.","title":"Guides"},{"location":"Wallets/WalletsOverview/","text":"Wallets \u00b6 The Loki wallet is a gateway to private decentralised transactions and communications. It allows you to hold and secure Loki, mine and trade peer-to-peer. Download the official Loki wallet today and start taking back control of your online privacy. Web Wallet (Loki Locker) \u00b6 The quickest way to access a Loki Wallet is through a web based wallet, Loki Locker . The Web Wallet is the easiest to use and doesn't require any downloaded files. Graphical User Interface Wallet (GUI) \u00b6 The Gui Wallet is just as easy to use as the Web Wallet and can be downloaded from Loki Projects Github . For installation help you can check out the following guide: Gui-Guide-Windows Command Line Interface Wallet (CLI) \u00b6 The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. You can download the latest release of the Loki CLI Wallet from Loki Projects Github .","title":"Overview"},{"location":"Wallets/WalletsOverview/#wallets","text":"The Loki wallet is a gateway to private decentralised transactions and communications. It allows you to hold and secure Loki, mine and trade peer-to-peer. Download the official Loki wallet today and start taking back control of your online privacy.","title":"Wallets"},{"location":"Wallets/WalletsOverview/#web-wallet-loki-locker","text":"The quickest way to access a Loki Wallet is through a web based wallet, Loki Locker . The Web Wallet is the easiest to use and doesn't require any downloaded files.","title":"Web Wallet (Loki Locker)"},{"location":"Wallets/WalletsOverview/#graphical-user-interface-wallet-gui","text":"The Gui Wallet is just as easy to use as the Web Wallet and can be downloaded from Loki Projects Github . For installation help you can check out the following guide: Gui-Guide-Windows","title":"Graphical User Interface Wallet (GUI)"},{"location":"Wallets/WalletsOverview/#command-line-interface-wallet-cli","text":"The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. You can download the latest release of the Loki CLI Wallet from Loki Projects Github .","title":"Command Line Interface Wallet (CLI)"},{"location":"Wallets/WhatWalletToUse/","text":"","title":"What wallet to use?"},{"location":"Wallets/CliWallet/2of2Multisig/","text":"Loki 2/2 Multisig \u00b6 First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong. Overview \u00b6 In short, the process is: Set-up Both parties prepare loki-wallet-cli files Both parties command prepare_multisig and send data to each other Both parties command make_multisig Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending both parties command export_multisig_info <filename> and send the file to the other party To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx Below is a step-by-step walkthrough. Set-up \u00b6 Step 1 Initiate Creation of Multisig Wallet and Exchange Data \u00b6 Requirements: 2 empty loki-wallet-cli wallets Both wallets connected to lokid Private communication channel Person A must run the command in their loki-wallet-cli : prepare_multisig Person A will receive the output: MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig...5ozpN and be sure to capture the whole thing when copying. Send this line to person B through a private communication channel. Person B does the same and sends his output to person A. Person B must run the command in their loki-wallet-cli : prepare_multisig Person B will receive the output: MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Person B will copy the Multisig\u2026...eJi4FS and send it to person A through a private communication channel. Step 2 Create Multisig Wallets \u00b6 Both person A and person B now have the Multisig...arg text from the other one. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying account when converted to multisig. This is not really a problem, since we started with an empty one, and if all goes ok with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying account and want to reconstruct the multisig wallet). Person A will use the output Person B sent and will run the command: make_multisig 2 MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Person B will use the output Person A sent and run the command: make_multisig 2 MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Now each person involved should exchange addresses and compare, they must be the same. Receiving \u00b6 Step 1 Fund The Multisig Account \u00b6 This is simple. Just send to the shared address. You can send multiple times, this is the same as a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other. Step 2 Check Multisig Account Balance \u00b6 Just open the wallet and command refresh. Once completed, both persons can verify that the funds arrived. Person A commands: show_transfers Person A outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Person B can do the same: show_tranfers Person B has the same outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Spending \u00b6 Step 1 Synchronizing Key Images \u00b6 1.1 Exporting Multisig Info \u00b6 Without this step, it will not be possible to create a spending transaction. Both persons need to run the following command to sync their key images: export_multisig_info <filename> Where <filename> can be any filename. Person A will run the command: export_multisig_info mi1 Person A will receive the output: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person A sends that file to Person B. They can send the file in many ways, preferably through by handing a usb drive with the file on it, however If you would like to send the file through terminal use https://transfer.sh/ , an optional step has been added if you choose to use this method. Person B does the same, but changing the filename and runs the command: export_multisig_info mi2 Person B will receive the output: Multisig info exported to mi2 The file mi2 will be located in the shell working folder* Person B sends that file to person A. Now, they must both import each other's file. Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh \u00b6 It is optional to use the terminal to send each person the multisig info files. Uploading Multisig Info file \u00b6 Person A will open up a new terminal and change to the directory \u201cmi1\u201d has been saved.* Person A will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person A will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person A will need to send this link to Person B. Person B will run a similar command: curl --upload-file ./mi1 https://transfer.sh/mi2 Person B will receive the link to the file as an output, looking similar to: https://transfer.sh/Iedv9/mi2 Person B will need to send this link to Person A. Downloading Multisig Info file \u00b6 Person A should change to the directory of their loki-wallet-cli and use Person B\u2019s download link to run the command: curl <Person B link> -o <filename> Replacing <Person B link> with the link Person B shared with Person A and <filename> with the filename of the Multisig info file that Person A generated, for example Person A will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 Likewise, Person B should do the same, changing directories to their loki-wallet-cli and downloading with Person A\u2019s download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1 Step 1.3 Importing Multisig Info \u00b6 Person A will run the command: import_multisig_info mi2 Depending on the transactions made in to the multsig wallet the output will look similar to: 2 outputs found in mi2 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Person B will run a similar command: import_multisig_info mi1 and the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Step 2 Preparing Spending Transaction \u00b6 Either person A or person B can do this, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. Person A performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like*: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from*. There should be a file named multisig_loki_tx . Person A will send the file multisig_loki_tx to the Person B. Person A can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person A chooses to use transfer.sh command to send the file to Person B they will receive a <link> to pass to Person B. Person B must finish the signature. Person B copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli *. Person B can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person A. Then, Person B runs the command: sign_multisig multisig_loki_tx A prompt will be displayed to allow person B to check the transaction before signing: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully signed to file multisig_loki_tx, txid 3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb It may be relayed to the network with submit_multisig Finally, person B submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> The person B could also send the signed TX to person A, who could then submit it to the network himself. If you want to make another one, you have to go back to step 1 of spending (sync the key images again). *Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki-windows-x64\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stackexchange: How to use Monero Multisigniture Wallets","title":"2/2 Multisig"},{"location":"Wallets/CliWallet/2of2Multisig/#loki-22-multisig","text":"First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong.","title":"Loki 2/2 Multisig"},{"location":"Wallets/CliWallet/2of2Multisig/#overview","text":"In short, the process is: Set-up Both parties prepare loki-wallet-cli files Both parties command prepare_multisig and send data to each other Both parties command make_multisig Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending both parties command export_multisig_info <filename> and send the file to the other party To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx Below is a step-by-step walkthrough.","title":"Overview"},{"location":"Wallets/CliWallet/2of2Multisig/#set-up","text":"","title":"Set-up"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-initiate-creation-of-multisig-wallet-and-exchange-data","text":"Requirements: 2 empty loki-wallet-cli wallets Both wallets connected to lokid Private communication channel Person A must run the command in their loki-wallet-cli : prepare_multisig Person A will receive the output: MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig...5ozpN and be sure to capture the whole thing when copying. Send this line to person B through a private communication channel. Person B does the same and sends his output to person A. Person B must run the command in their loki-wallet-cli : prepare_multisig Person B will receive the output: MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Person B will copy the Multisig\u2026...eJi4FS and send it to person A through a private communication channel.","title":"Step 1 Initiate Creation of Multisig Wallet and Exchange Data"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-create-multisig-wallets","text":"Both person A and person B now have the Multisig...arg text from the other one. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying account when converted to multisig. This is not really a problem, since we started with an empty one, and if all goes ok with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying account and want to reconstruct the multisig wallet). Person A will use the output Person B sent and will run the command: make_multisig 2 MultisigV1BU9w9mysQMhNTYcNFQgD82VQiKFGpkwy8Jmu13iWWBmoeRbqyuYmEh22bJRk945ntuDeazTsYwUCYZcCL1cxuf4xDzwUJCLkiYhPCvF7gv3xrCGkAiozirNUG6CxRa53mHqp4Cvdj3yxcQcYbXNYC1ecybbQMW1gs5BBQiruVGeJi4FS The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Person B will use the output Person A sent and run the command: make_multisig 2 MultisigV1cYuTGuf8FSiCYnMtLU4sZzeKZgeMy51qf4CcG2EQ2BPqKTii6YanpNLJDTM9rVRNfBPNFnJHoCWwGT9d8kB2UEDNHDxjgaAZX6DAWtj9VBFq9Q5qHjduozaYzgYpbVfHKHUQR2UrJjyX7tCSyd8gFEHUSocDRejRZBrFrKNifri5ozpN The wallet will output something similar to: 2/2 multisig address: T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8 Now each person involved should exchange addresses and compare, they must be the same.","title":"Step 2 Create Multisig Wallets"},{"location":"Wallets/CliWallet/2of2Multisig/#receiving","text":"","title":"Receiving"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-fund-the-multisig-account","text":"This is simple. Just send to the shared address. You can send multiple times, this is the same as a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other.","title":"Step 1 Fund The Multisig Account"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-check-multisig-account-balance","text":"Just open the wallet and command refresh. Once completed, both persons can verify that the funds arrived. Person A commands: show_transfers Person A outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 - Person B can do the same: show_tranfers Person B has the same outputs: 1357156 in 07:50:35 PM 0.100000000000 88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873 0000000000000000 - 1357161 in 08:00:18 PM 0.100000000000 d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da 0000000000000000 -","title":"Step 2 Check Multisig Account Balance"},{"location":"Wallets/CliWallet/2of2Multisig/#spending","text":"","title":"Spending"},{"location":"Wallets/CliWallet/2of2Multisig/#step-1-synchronizing-key-images","text":"","title":"Step 1 Synchronizing Key Images"},{"location":"Wallets/CliWallet/2of2Multisig/#11-exporting-multisig-info","text":"Without this step, it will not be possible to create a spending transaction. Both persons need to run the following command to sync their key images: export_multisig_info <filename> Where <filename> can be any filename. Person A will run the command: export_multisig_info mi1 Person A will receive the output: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person A sends that file to Person B. They can send the file in many ways, preferably through by handing a usb drive with the file on it, however If you would like to send the file through terminal use https://transfer.sh/ , an optional step has been added if you choose to use this method. Person B does the same, but changing the filename and runs the command: export_multisig_info mi2 Person B will receive the output: Multisig info exported to mi2 The file mi2 will be located in the shell working folder* Person B sends that file to person A. Now, they must both import each other's file.","title":"1.1 Exporting Multisig Info"},{"location":"Wallets/CliWallet/2of2Multisig/#optional-step-12-sending-multisig-info-file-with-terminal-transfersh","text":"It is optional to use the terminal to send each person the multisig info files.","title":"Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh"},{"location":"Wallets/CliWallet/2of2Multisig/#uploading-multisig-info-file","text":"Person A will open up a new terminal and change to the directory \u201cmi1\u201d has been saved.* Person A will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person A will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person A will need to send this link to Person B. Person B will run a similar command: curl --upload-file ./mi1 https://transfer.sh/mi2 Person B will receive the link to the file as an output, looking similar to: https://transfer.sh/Iedv9/mi2 Person B will need to send this link to Person A.","title":"Uploading Multisig Info file"},{"location":"Wallets/CliWallet/2of2Multisig/#downloading-multisig-info-file","text":"Person A should change to the directory of their loki-wallet-cli and use Person B\u2019s download link to run the command: curl <Person B link> -o <filename> Replacing <Person B link> with the link Person B shared with Person A and <filename> with the filename of the Multisig info file that Person A generated, for example Person A will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 Likewise, Person B should do the same, changing directories to their loki-wallet-cli and downloading with Person A\u2019s download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1","title":"Downloading Multisig Info file"},{"location":"Wallets/CliWallet/2of2Multisig/#step-13-importing-multisig-info","text":"Person A will run the command: import_multisig_info mi2 Depending on the transactions made in to the multsig wallet the output will look similar to: 2 outputs found in mi2 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Person B will run a similar command: import_multisig_info mi1 and the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000","title":"Step 1.3 Importing Multisig Info"},{"location":"Wallets/CliWallet/2of2Multisig/#step-2-preparing-spending-transaction","text":"Either person A or person B can do this, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. Person A performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like*: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from*. There should be a file named multisig_loki_tx . Person A will send the file multisig_loki_tx to the Person B. Person A can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person A chooses to use transfer.sh command to send the file to Person B they will receive a <link> to pass to Person B. Person B must finish the signature. Person B copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli *. Person B can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person A. Then, Person B runs the command: sign_multisig multisig_loki_tx A prompt will be displayed to allow person B to check the transaction before signing: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully signed to file multisig_loki_tx, txid 3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb It may be relayed to the network with submit_multisig Finally, person B submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> The person B could also send the signed TX to person A, who could then submit it to the network himself. If you want to make another one, you have to go back to step 1 of spending (sync the key images again). *Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki-windows-x64\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki-windows-x64\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stackexchange: How to use Monero Multisigniture Wallets","title":"Step 2 Preparing Spending Transaction"},{"location":"Wallets/CliWallet/2of3Multisig/","text":"Loki 2/3 Multisig \u00b6 First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong. Overview \u00b6 In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough. Wallet Creation \u00b6 Requirements: 3 empty loki-wallet-cli wallets All parties wallets connected to a lokid Private communication channel Step 1 - Prepare Multisig \u00b6 Here some data will be shown to the user, which has to be exchanged with ALL other parties. Person 1, 2 and 3 commands: prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Person 1 to send the Multsig...arg to Person 2 and 3, Person 2 to send their output to Person 1 and 3 and Person 3 to send their output to Person 1 and 2. Step 2 - Make Multisig \u00b6 All 3 persons now have the Multisig...arg text from the other 2. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> Where <threshold> is the number of signers required out of the 3 people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3. The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With 2/3 there's an additional step to be done here. The new Multisig...arg info must be passed to ALL other participants (persons 2 & 3). Persons 2 & 3 do the same as above and send the info to other 2 parties. Step 3 - Finalize Multisig \u00b6 Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person 1 will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All 3 persons do the same, and all 3 wallets will show the same address after this step. Now each person run the command: address And each 3 parties of the multisig wallet should be shown the same address in their wallet. Receiving \u00b6 Step 1 Fund The Multisig Account \u00b6 This is simple. Just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address. Step 2 Check Multisig Account Balance \u00b6 Just open the wallet and run the refresh command . Once completed, all persons can verify that the funds arrived. Person 1, 2 & 3 can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance Preparation for Spending \u00b6 Step 1 - Export Multisig \u00b6 Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from the same person who will sign the transaction with him later. He could get from both parties immediately and then later decide with whom to sign. Person 1 commands: export_multisig_info mi1 Where mi1 can be any filename. The output will be: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person 1 sends that file to other persons. Persons 2 & 3 do the same. Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh \u00b6 It is optional to use the terminal to send each person the multisig info files. Uploading Multisig Info file \u00b6 Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2 and Person 3. Person 2 will need to do the same and send the link to Person 1 and 3. Person 3 will need to do the same and send the link to Person 1 and 2. Downloading Multisig Info file \u00b6 Person 1 should change to the directory of their loki-wallet-cli and use Person 2 and 3\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2 and 3 shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2 or 3 generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 Likewise, Person 2 and 3 should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1 Step 2 - Import Multisig \u00b6 Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 The wallet will look for files in the shell working folder* and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 & 3 do the same. Spending \u00b6 Step 1 - Transfer (Preparing Unsigned Transaction) \u00b6 Any of the 3 persons can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from*. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to either person 1 or 2. Person 3 will send the file multisig_loki_tx to the Person 1 or 2. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli *. Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3. Step 2 - Sign Multisig \u00b6 Let's say Person 2 was picked as the partner. He must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli *. Then, Person 2 commands: sign_multisig multisig_loki_tx and he/she will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> Step 3 - Submit Multisig \u00b6 Finally, person with the signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). *Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"2/3 Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#loki-23-multisig","text":"First, the wallet to be converted to multisig must be empty. It is best to use a brand-new wallet for the purpose, although not required. It is strongly advised to make a copy of the wallet files first, just in case something goes wrong.","title":"Loki 2/3 Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#overview","text":"In short, the process is: Wallet Creation All parties command prepare_multisig and send data to ALL other parties All parties command make_multisig <threshold> <data1> <data2> and send 2nd batch of data to ALL other parties All parties command finalize_multisig <data1> <data2> with the data from ALL other parties. Receiving All parties can type address to see the created multisig wallet address. The address will, of course, be the same for all parties since they're all watching the same wallet. Preparation for Sending To prepare for sending all parties command export_multisig_info <filename> and send the file to all other parties To complete preparation, all parties command import_multisig_info <filename1> <filename2> and import files from other parties Sending To send, any party can use the usual transfer command, but the result will be a file named multisig_loki_tx which must be sent to any 1 other signer The other party commands sign_multisig multisig_loki_tx and the file is updated with the signature. The completely signed file is pushed to the network with use of submit_multisig multisig_loki_tx . Below is a step-by-step walkthrough.","title":"Overview"},{"location":"Wallets/CliWallet/2of3Multisig/#wallet-creation","text":"Requirements: 3 empty loki-wallet-cli wallets All parties wallets connected to a lokid Private communication channel","title":"Wallet Creation"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-prepare-multisig","text":"Here some data will be shown to the user, which has to be exchanged with ALL other parties. Person 1, 2 and 3 commands: prepare_multisig The output will be something like: MultisigV1cR7X7ZAfa5ncRmQv1hpt4P1DmmnhinhokhDMqsmuWXmHFrb6xUr3FtBGygCfMScxnKJvXK1vvPNahXNWfYWVquieBErr98sFtgs24c2YuYrQT78uxV8oYx1A9bKeHSUfYzCniN5kMznEfvKCw3FiomjLvw364gg98ZWp16zA7pUVozid Send this multisig info to all other participants, then use make_multisig <threshold> <info1> [<info2>...] with others' multisig info This includes the PRIVATE view key, so needs to be disclosed only to that multisig wallet's participants Copy the entire line Multisig\u2026...Vozid and be sure to capture the whole thing when copying. Person 1 to send the Multsig...arg to Person 2 and 3, Person 2 to send their output to Person 1 and 3 and Person 3 to send their output to Person 1 and 2.","title":"Step 1 - Prepare Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-make-multisig","text":"All 3 persons now have the Multisig...arg text from the other 2. With that, each of them can create their part of the multisig wallet. Before you proceed, note that the wallet will lose access to the underlying wallet when converted to multisig. This is not really a problem, since we started with an empty wallet, and if all goes OK with this step, you won't ever need it unless you want to go through the process again for whatever reason (like HDD died, but you have the seed mnemonic of the underlying wallet and want to reconstruct the multisig wallet). Person 1 commands: make_multisig <threshold> <data person 2> <data person 3> Where <threshold> is the number of signers required out of the 3 people, <data person 2> is the output provided by Person 2, and <data person 3> is the output provided by Person 3. This should look similar to: make_multisig 2 MultisigV12EHtuvxFyAYDNcDsbDqWHDfkRr4JZchSdf8eZQSFwiMKDk15CYEJeQyEwtSnqUZdRr2BsEaT9z2biUdDTEQM4T3N625owvKMDoyhbRj3bwkBtceLKimap8DBAiUmSABpdf62HnPYiRtLW4JdVFmfqjndhWjYBypx1duvpi3qwfSrBY9a MultisigV1TqQ8Gt5Sb3GYtVJa1fQrK7e7hPm59XbooNvLxPSBR4856bW9jtD1hEyWy4yULKrX7reZZ6vrKdBCdSdk4nfApCGYJAA2WP4pKNwHDyKTuLEeuoDhqno8keEVeEF9AZsWXvng1avUTRREmy11h8wu8pdjopC4AguQKiHCJCN7aT9W6b8C Notice how there are 2 strings starting with Multisig....arg . One is from person 2 and other from person 3. The number at the beginning is the minimum required number of signatures. Since it's a 2/3 scheme - it's 2. The output from the make_multisig command will be similar to: Another step is needed MultisigxV1PKCwmVrucV8bXi18VnHFqRXcnAq4osFL3ahzPHCiN48zhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTS8r9EX1DmVPXgFKkFzw4Yj4ZtMcJVo77b5ayuMzjFtsaijko9X2bjd9AVfFVGBFMCSLa4xXhNVNz19CTUJx5gpoPG Send this multisig info to all other participants, then use finalize_multisig <info1> [<info2>...] with others' multisig info With 2/3 there's an additional step to be done here. The new Multisig...arg info must be passed to ALL other participants (persons 2 & 3). Persons 2 & 3 do the same as above and send the info to other 2 parties.","title":"Step 2 - Make Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-3-finalize-multisig","text":"Here we do one last command to make the wallet ready for receiving. It requires the 2nd batch of Multisig\u2026....arg strings received from other parties. Person 1 will run the command: finalize_multisig MultisigxV1Vg1tsRLurvAc5aSA9Hd9God3MQhijCFoE1rPDFzx7ufwhs28u6jmEhy7ktZbUEGfRtTuFjjKzJYb61fnFwnysBBnfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmgSQ1NZLyBj48R1tVpiGNxa7TDnGbSgLuKBq35AX6jfu5PECAcDDn22CFQbJZip7xnBbn89Szzh27xeozfxcLiqqm MultisigxV14xDZBGACz3iUh2aVKGE5q5VzcvJdg2qCvZECgUWCdy5QNXsUtCgFMXPa7FyNKVy2AnUg3ePEnKqWkgKVvA81axTSfYm4xJWcJ4qM4khSb2KkyAKDuT39pTvdmemhojNjeYCmCNaRSsDEcemLLL8wCvzsy5R6hhkhWLYkD9vhZwprSFFKMZ7tfRko2VfMBoKQhB7PKXbf1npk2xceVKu2y7kExywb Unfortunately the wallet will not display an output at this point. There's no indication that the process was successfully completed (for now). All 3 persons do the same, and all 3 wallets will show the same address after this step. Now each person run the command: address And each 3 parties of the multisig wallet should be shown the same address in their wallet.","title":"Step 3 - Finalize Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#receiving","text":"","title":"Receiving"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-fund-the-multisig-account","text":"This is simple. Just send to the shared address. You can send multiple times, just like a normal wallet. You can use payment ID\u2019s as well, or generate an integrated address to receive funds. Best part, whomever is sending the funds won't be able to tell that the address belongs to a multisig wallet since it looks like any other Loki address.","title":"Step 1 Fund The Multisig Account"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-check-multisig-account-balance","text":"Just open the wallet and run the refresh command . Once completed, all persons can verify that the funds arrived. Person 1, 2 & 3 can run the command: show_transfers To see incoming transfers or the following command to see the balance of the wallet: balance","title":"Step 2 Check Multisig Account Balance"},{"location":"Wallets/CliWallet/2of3Multisig/#preparation-for-spending","text":"","title":"Preparation for Spending"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-export-multisig","text":"Without this step, it will not be possible to create a transaction that spends Loki. As a minimum, the sender needs to get a partial key image from the same person who will sign the transaction with him later. He could get from both parties immediately and then later decide with whom to sign. Person 1 commands: export_multisig_info mi1 Where mi1 can be any filename. The output will be: Multisig info exported to mi1 The file mi1 will be located in the shell working folder* Person 1 sends that file to other persons. Persons 2 & 3 do the same.","title":"Step 1 - Export Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#optional-step-12-sending-multisig-info-file-with-terminal-transfersh","text":"It is optional to use the terminal to send each person the multisig info files.","title":"Optional: Step 1.2 Sending Multisig Info File with terminal - transfer.sh"},{"location":"Wallets/CliWallet/2of3Multisig/#uploading-multisig-info-file","text":"Person 1 will open up a new terminal and change to the directory mi1 has been saved.* Person 1 will run the following command: curl --upload-file ./mi1 https://transfer.sh/mi1 Person 1 will receive the link to the file as an output, looking similar to: https://transfer.sh/Ehl5q/mi1 Person 1 will need to send this link to Person 2 and Person 3. Person 2 will need to do the same and send the link to Person 1 and 3. Person 3 will need to do the same and send the link to Person 1 and 2.","title":"Uploading Multisig Info file"},{"location":"Wallets/CliWallet/2of3Multisig/#downloading-multisig-info-file","text":"Person 1 should change to the directory of their loki-wallet-cli and use Person 2 and 3\u2019s download link to run the commands: curl <link> -o <filename> Replacing <link> with the link Person 2 and 3 shared with Person 1 and <filename> with the filename of the Multisig info file that Person 2 or 3 generated, for example Person 1 will run the command: curl https://transfer.sh/Iedv9/mi2 -o mi2 And the command: curl https://transfer.sh/dfvr3/mi3 -o mi3 Likewise, Person 2 and 3 should do the same, changing directories to their loki-wallet-cli and downloading with the alternative Persons download link, and filename. curl https://transfer.sh/Ehl5q/mi1 -o mi1","title":"Downloading Multisig Info file"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-import-multisig","text":"Now, they must all import each other's file so they can be ready to make a TX later. For example, Person 2 commands: import_multisig_info mi1 The wallet will look for files in the shell working folder* and if the files are found the output will look like: 2 outputs found in mi1 Height 1357156, transaction <88ba687dc79a0b39e6de6d0763eda8363d33d9f58ec9a096171bd9a7f1dae873>, received 0.100000000000 Height 1357161, transaction <d6ac845b9400759525519cdc5d514eb8f5b1d265b24d1c016e75b20ed3b4b7da>, received 0.100000000000 Persons 1 & 3 do the same.","title":"Step 2 - Import Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#spending","text":"","title":"Spending"},{"location":"Wallets/CliWallet/2of3Multisig/#step-1-transfer-preparing-unsigned-transaction","text":"Any of the 3 persons can start a transaction, it doesn't matter. To avoid weird things from happening only do it for 1 transaction at a time. If anything weird happens, do the step 1 & 2 again to fix. For example, let's say that Person 3 will make the TX. Person 3 performs the usual transfer command: transfer T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 50 The output will look like: Unsigned transaction(s) successfully written to file: multisig_loki_tx Check in the folder where you started loki-wallet-cli from*. There should be a file named multisig_loki_tx . Send the file multisig_loki_tx to either person 1 or 2. Person 3 will send the file multisig_loki_tx to the Person 1 or 2. Person 3 can send this file through email or alternatively use the transfer.sh commands outside of the wallet: curl --upload-file ./multisig_loki_tx https://transfer.sh/multisig_loki_tx If Person 3 chooses to use transfer.sh command to send the file to Person 1 or 2 they will receive a <link> . Person 1 or 2 must finish the signature. Person 1 or 2 copies/downloads the file to the same folder from where he started (or will start) loki-wallet-cli *. Person 1 or 2 can run the command to download the file to the loki-wallet-cli directory. curl https://transfer.sh/CJqnM/multisig_loki_tx -o multisig_loki_tx Replacing https://transfer.sh/CJqnM/multisig_loki_tx with the link provided by Person 3.","title":"Step 1 - Transfer (Preparing Unsigned Transaction)"},{"location":"Wallets/CliWallet/2of3Multisig/#step-2-sign-multisig","text":"Let's say Person 2 was picked as the partner. He must finish the signature. Person 2 copies the file to the same folder from where he started (or will start) loki-wallet-cli *. Then, Person 2 commands: sign_multisig multisig_loki_tx and he/she will be prompted to check it first: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb>","title":"Step 2 - Sign Multisig"},{"location":"Wallets/CliWallet/2of3Multisig/#step-3-submit-multisig","text":"Finally, person with the signed file submits the transaction to the network by commanding: submit_multisig multisig_loki_tx There will be a confirmation prompt: Loaded 1 transactions, for 108.082287779, fee 0.061108880, sending 50.000000000 to T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7, 58.021178899 change to T6ScXhWpAG2aUHmFemwvn4HddHA5GQ4u6MvYsW2hVteJSwLJXCEhk2aVp4XzyqGmvyUqc3w8fwWwg6szGEytUSx51C6WQ3er8, with min ring size 10, no payment ID. Is this okay? (Y/Yes/N/No): If ok, answer Y , and the transaction will be sent. The output will look like: Transaction successfully submitted, transaction <3b03b16c79eaa5564171ae88242c4cdb1f9e0b41fc3de949c6524c5026a3f3bb> You can check its status by using the show_transfers command. The person 2 could also send the signed TX to person 3, who could then submit it to the network himself. If you want to make another one, you have to go back to preparation for spending step (sync the key images again). *Note on folders and file locations, as it could create some confusions. The wallet will look for the files and export them to the folder from where it was started, ie where your command prompt / shell was when you called loki-wallet-cli . It may or may not be the same folder as your actual wallet files or loki-wallet-cli , depending on how you go about it. For example, your wallet could be on some USB drive like f:\\temp\\ , and your wallet software on c:\\loki\\ and your shell working folder could be c:\\ . If you remain in c:\\ with the shell, you could start the wallet by its full path and specify the wallet file location: c:\\loki\\loki-wallet-cli.exe --wallet-file f:\\temp\\mywallet . In this case, all the import/export stuff would be read/written to c:\\ because that's still your shell's working folder. It would be probably feel more natural to cd into the wallet folder. Do f: to change drive and then cd f:\\temp\\ . Then, simply start the wallet from that location by its full path again: c:\\loki\\loki-wallet-cli.exe --wallet-file mywallet . Notice how you don't have to write the full wallet path now as you're already there with your shell. In this case, all the files mentioned above would be written or read from the same folder as the wallet files. Source: Monero Stack Exchange: how to use monero multisigniture wallets","title":"Step 3 - Submit Multisig"},{"location":"Wallets/CliWallet/CLIOverview/","text":"CLI Overview \u00b6 The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. You can download the latest release of the Loki CLI Wallet from Loki Projects Github . Guides & Resources \u00b6 The following are useful guides or resources for the CLI Wallet: CLI Wallet Repository : Latest release of the CLI Wallet. CLI Commands : Details on different commands within the loki-wallet-cli . CLI Setup - Mac : How to setup the loki-wallet-cli for the first time on Mac OS. 2 of 2 - Multisignature Setup : Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-2 keys. 2 of 3 - Multisignature Setup : Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-3 keys.","title":"CLI Overview"},{"location":"Wallets/CliWallet/CLIOverview/#cli-overview","text":"The Cli Wallet is for more advanced users and offers the most tools when interacting with the Loki Blockchain. You can download the latest release of the Loki CLI Wallet from Loki Projects Github .","title":"CLI Overview"},{"location":"Wallets/CliWallet/CLIOverview/#guides-resources","text":"The following are useful guides or resources for the CLI Wallet: CLI Wallet Repository : Latest release of the CLI Wallet. CLI Commands : Details on different commands within the loki-wallet-cli . CLI Setup - Mac : How to setup the loki-wallet-cli for the first time on Mac OS. 2 of 2 - Multisignature Setup : Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-2 keys. 2 of 3 - Multisignature Setup : Multisig feature allows you to sign a transaction with more than one private key. Funds protected with multisig can only be spent by signing with 2-of-3 keys.","title":"Guides &amp; Resources"},{"location":"Wallets/CliWallet/WalletCommands/","text":"Commands: \u00b6 Displaying commands \u00b6 The loki-wallet-cli has multiple commands to conduct different operations on the Loki Blockchain. By typing help and clicking enter after loading your wallet will bring up the commands that can be used. 1 Accounts \u00b6 1.1 Creating new account \u00b6 When a wallet is generated it will automatically have an account labelled Primary account with index 0 . If at any time you wish to create an additional account use the command: account new <label text with white spaces allowed> This command will create a subaddress which is labelled with a tag and index number. This subaddress will share the same seed as your Primary address. To ensure this new account is displayed you must type exit to save your session. You will note that there is now an asterisk to the left of index 1. The asterisks show us the account in which the commands we run will apply to. Note: Restoring your wallet from your seed will not restore your accounts as the index of your subaddress data is stored on your computer within your wallet file. All the funds stored in your additional accounts will be shown in your Primary account if you need to restore your wallet from scratch. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 1.2 Switching account \u00b6 When transferring out or receiving to a specific account we need to make sure that the account we are performing the action is the one the CLI is currently connected to. An asterisk will show which account we are connected to. In the below example the asterisk is shown to the left of Secondary account so any operations will be associated with that account. Each of the accounts connected to your Primary address will have an index associated with them. The index number will be shown to the left of the Account column. By default, index \u201c0\u201d is your Primary account. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 To switch between the accounts you have created run the command: account switch <index> After running the command a similar output shown below will be on your terminal. [wallet L9LnR2]: account switch 0 [wallet L9LnR2]: Currently selected account: [0] Primary account [wallet L9LnR2]: Tag: (No tag assigned) [wallet L9LnR2]: Balance: 0.000000000, unlocked balance: 0.000000000 1.3 Changing account labels \u00b6 To change the label name connected to a specific Loki Primary or Sub-address use the command: account label <index> <label text with white spaces allowed> Replacing <index> with the index number associated with the account you wish to relabel, and replacing <label text with white spaces allowed> with the new label you would like to name the specified account. Below shows the current accounts and labels for a specific wallet. [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 Primary account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 Using the command account label 0 My Account we have changed the label connected to our Primary address from \u201cPrimary account\u201d to \u201cMy Account\u201d. [wallet LCmjSH]: account label 0 My Account [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 My Account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 1.4 Tagging and untagging accounts: \u00b6 The loki-wallet-cli allows you to group accounts by tagging or untagging them. Below shows a wallet with 4 accounts, Dog, Kid 1 and Kid 2. [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 We can tag a single account with the following command: account tag <tag_name> <account_index> [wallet LVP3bv]: account tag Pets 1 [wallet LVP3bv]: Accounts with tag: Pets [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 When needing to perform multiple tags we can do it through one command: account tag <tag_name> <account_index_1> [<account_index_2> ...] [wallet LVP3bv]: account tag Family 2 3 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 Similarly we can untag accounts by running the following command: account untag <account_index_1> [<account_index_2> ...] Using the above exampled wallet we will remove our \u201cDog\u201d account from \u201cPets\u201d. [wallet LVP3bv]: account untag 1 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 [wallet LVP3bv]: [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 1.5 Adding Tag descriptions \u00b6 If you require additional information attached to a specific tag you can add a description with the following command: account tag_description <tag_name> <description> For example: [wallet LVP3bv]: account tag_description Family This is my family. [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: This is my family. [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 2 Balance \u00b6 To check the balance of your wallet you can run one of two commands: balance balance detail Running the command balance will generated a simple output showing your balance and unlocked balance of the specific account you are in. For example: [wallet T6TmZX]: balance Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 While running the command balance detail will generate a more detailed output, showing the account number, first few characters of the address, balance, unlocked balance, Outputs and the Label of the account. For example: [wallet T6TmZX]: balance detail Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 Balance per address: Address Balance Unlocked balance Outputs Label 0 T6TmZX 172286.035054991 172086.338373771 3347 Primary account There are other commands that will also output the balance which have been covered by this guide, such as the account command. 3 Getting the Block Height \u00b6 To show the blockchain height run the command: bc_height 4 Blackballing Transactions \u00b6 Blackballing transactions allows you to ignore others' outputs (containers of money) that are known to be spent in a certain transaction. For example let\u2019s imagine that txid: 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 is known to be fake and if this txid is seen within a RingCT transaction the network can assume it is fake, therefore an actor has a better chance of deducing the real transaction within the RingCT. By blackballing the above txid we remove the chance of it being used within our RingCT. To do this we will use the following command: blackball <output public key> | <filename> [add] For example: [wallet LAXk6e]: blackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 To check if the txid was added to our list of txids not to use we can use the following command: blackballed <output public key> If the txid is on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: Blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> Alternatively if the txid is not on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: not blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> To unblackball a txid use the following command: unblackball <output public key> For example: [wallet LAXk6e]: unblackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 5 Reserve Proof \u00b6 Reserve Proofs are used to generate a signature proving that you own an amount of Loki, with the option to sign the reserve proof with a key. For example let\u2019s imagine you see a car for sale but they will accept Loki as payment, however they have advised in their online listing that they are only interested in serious buyers and require you to prove you have the Loki within your initial contact. Luckily we can use the Reserve Proof commands for this proof. 5.1 Generate Reserve Proof \u00b6 To begin we will need to run the get_reserve_proof command to generate our proof. get_reserve_proof (all|<amount>) [<message>] If the individual you are sending this proof to requires you to prove you have 1000 Loki you will need to replace the section (all|<amount>) with a 1000, otherwise replace it with the amount you need to prove you have reserved. If you want to put an extra layer of encryption over the file replace [<message>] with a password. Your command will similar to the below command: get_reserve_proof 1000 Car The Cli will request your wallet password and once your password is entered it will tell you it generated a signature file. [wallet T6TmZX]: get_reserve_proof 1000 Car Wallet password: signature file saved to: loki_reserve_proof This signature file loki_reserve_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_reserve_proof command it will overwrite your loki_reserve_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_reserve_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_reserve_proof https://transfer.sh/loki_reserve_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. https://transfer.sh/QhoC7/loki_reserve_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_reserve_proof file through the transfer.sh link. The loki address you are proving has Loki in it. The <message> if you encrypted the file. 5.2 Checking Reserve Proof \u00b6 To check a reserve proof we need to first have the loki_reserve_proof file in our Loki folder. If you do not have the loki_reserve_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_reserve_proof you can use the following command to download it. curl <link> -o loki_reserve_proof Replacing <link> with the link to download the loki_reserve_proof . Now that the loki_reserve_proof is in our folder we can run the following command: check_reserve_proof <address> <signature_file> [<message>] Where <address> is the address of the wallet where the command get_reserve_proof was ran. <signiture_file> is the file that was received from the individual sending you the reserve proof, normally generated as loki_reserve_proof and <message> is the key set by the individual who sent you the reserve proof. Therefor for the previous example where we created a reserve proof for 1000 loki and signed with \u201ccar\u201d, we would run the command: check_reserve_proof T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 loki_reserve_proof Car If all goes well, the terminal will output the following: Good signature -- total: 1014.862440831, spent: 0.000000000, unspent: 1014.862440831 You may note that it shows a reserve proof which is greater than 1000, this is because the command is adding up all the transactions into the address specified until it is greater than the reserve proof set. 6 Spend Proof: \u00b6 Spend Proofs are used to generate a signature proving that you generated a TXID, with the option to sign the spend proof with a key. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_spend_proof command. 6.1 Generate Spend Proof \u00b6 To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_spend_proof command to generate our proof. get_spend_proof <txid> [<message>] Replacing <txid> with the txid of our transfer out and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_spend_proof This signature file loki_spend_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_spend_proof command it will overwrite your loki_spend_proof file . You will want to send this file to the person who requires the proof. You can upload the loki_spend_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_spend_proof https://transfer.sh/loki_spend_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_spend_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_spend_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The <message> if you encrypted the file. 6.2 Checking Spend Proof \u00b6 To check a spend proof we need to first have the loki_spend_proof file in our Loki folder and the txid associated with the transaction being proved. If you do not have the loki_spend_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_spend_proof you can use the following command to download it. curl <link> -o loki_spend_proof Replacing <link> with the link to download the loki_spend_proof . Now that the loki_spend_proof is in our folder we can run the following command: check_spend_proof <txid> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved. <signiture_file> is the file that was received from the individual sending you the spend proof, normally generated as loki_spend_proof and <message> is the key set by the individual who sent you the spend proof. An example would look like the following command check_spend_proof 20eb3b5545d6587e5a379feb2fc69b43d4f8b6b825bb7eff78e263d4e7e8eaa9 loki_spend_proof car If all goes well, the terminal will output the following: Good signature If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file. 7 TX Proof: \u00b6 TX Proofs are used to generate a signature file proving that you generated a TXID, with the option to sign the spend proof with a key. TX proofs work similar to Reserve Proof\u2019s and Spend Proofs however they show more detailed information. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_tx_proof command. 7.1 Generate Spend Proof \u00b6 To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_tx_proof command to generate our proof. get_tx_proof <txid> <address> [<message>] Replacing <txid> with the txid of our transfer out, <address> with the receiver's address, and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_tx_proof This signature file loki_tx_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_tx_proof command it will overwrite your loki_tx_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_tx_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_tx_proof https://transfer.sh/loki_tx_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_tx_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_tx_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The receivers loki address. The <message> if you encrypted the file. 7.2 Checking tx Proof \u00b6 To check a tx proof we need to first have the loki_tx_proof file in our Loki folder, the receiver's address and the txid associated with the transaction being proved. If you do not have the loki_tx_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_tx_proof you can use the following command to download it. curl <link> -o loki_tx_proof Replacing <link> with the link to download the loki_tx_proof . Now that the loki_tx_proof is in our folder we can run the following command: check_tx_proof <txid> <address> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved, <address> is the receiver\u2019s address and <signiture_file> is the file that was received from the individual sending you the tx proof, normally generated as loki_tx_proof and <message> is the key set by the individual who sent you the tx proof. An example would look like the following command: check_tx_proof 3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044 TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc loki_tx_proof If all goes well, the terminal will output the following: Good signature TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc received 40000.000000 in txid <3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044> This transaction has 1 confirmations If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file. 8 TX key: \u00b6 A TX key is a private key associated with a TXid. Only the wallet that has sent the transaction can generate a TX key from the TXID that both parties can see. A TX key can be used to validate a transaction on a case by case basis. In essence, you can provide the tx key, txid and the receiver address to someone to prove you had generate that transaction. 8.1 View TX key \u00b6 To view the TX key of a specific transaction you have generate you will need to run the command: get_tx_key <txid> Where <txid> is the transaction id associated with the transfer out you are proving is yours. The terminal will prompt the user for the wallets password and then print out the tx key, which will look similar to: [wallet T6TmZX]: get_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f Wallet password: Tx key: 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e Provide the <tx key> with the <txid> and <receiving address> to the individual who will run the validation, thus this will prove you generated the transaction. 8.2 Validate transaction with TX key \u00b6 Once we have a <tx key> , <txid> and <receiving address> from a specific transaction we can use the following command to prove they are all associated: check_tx_key <txid> <txkey> <address> For the previous example we would run the following command from any loki wallet: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 The terminal will show text of how much Loki the address received. It will also show how many confirmations the transaction has received from the blockchain. For example: [wallet T6TZ2V]: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 received 10000.000000000 in txid <d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f> This transaction has 10 confirmations 9 Tx Notes \u00b6 The loki-wallet-cli allows you to add notes to specific txid\u2019s, however this note does not get stored on the blockchain, rather it is stored on client side, on the device that generates the tx_note . 9.1 Set tx note \u00b6 To set a tx note we will need a the <txid> and the <message> you want to add to the txid. For instance, if you want to add a note to a txid that is connected to your wallet run the following command to show your transactions in/out with their <txid> \u2019s: show_transfers To set the note to the <txid> run the following command: set_tx_note <txid> [free text note] Where <txid> is the transaction id associated to the transaction you are adding the [free text note] too. Your command will look similar to the following example: [wallet T6TmZX]: set_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f This is a tx note example. 9.2 View tx note \u00b6 To view a note connected to a txid run the following command: get_tx_note <txid> Where <txid> is the transaction id that has the note connected to it. For example, if we run the command on the previous <txid> mentioned, the terminal will display the following text: [wallet T6TmZX]: get_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f note found: This is a tx note example. You can also view a tx note by running the show_transfers command, each transaction that has a note connected to it will display the text to the right of each transfer. 10 Changing wallet password \u00b6 Changing the wallet password is only client side(locally), and if the password is forgotten the wallet can always be restored with the mnemonic seed. If you know the password to the wallet and want to change it you can run the following command: password Once the command has been run the terminal will prompt you for the current password and the new password twice. If entered correctly the terminal will go back to receiving inputs, otherwise the terminal will output an error such as Passwords do not match! Please try again or Error: invalid password . 11 Encrypting seed phrase \u00b6 Your seed passphrase is a 25 word phrase which is used to recover access to your wallet on a client or gui and is. The command encrypted_seed allows your to add an additional password, or encryption layer, to your 25 word mnemonic seed. Encrypting your seed will stop others from recovering access to your wallet if they somehow gain access to your 25 word mnemonic seed as they will not have the passphrase that decrypts them. This means, your passphrase should not be written or saved in the same location as your encrypted 25 word mnemonic seed phrase. To encrypt your seed run the following command: encrypted_seed Initially the cli wallet will prompt you to enter your wallet password. Next it will request for your seed encryption passphrase, enter in your desired password/passphrase once, click enter, then type the passphrase in again. The wallet will output your mnemonic seed which is a 25 word passphrase. It is generally best practice to write these 25 words down and store them somewhere safe and securely, write your passphrase down(which is the phrase you used to encrypt the 25 words) and store this somewhere else. Storing the 25 words with the passphrase in a file on your computer that is not encrypted is giving others easier access to your mnemonic seed.","title":"CLI Wallet Commands"},{"location":"Wallets/CliWallet/WalletCommands/#commands","text":"","title":"Commands:"},{"location":"Wallets/CliWallet/WalletCommands/#displaying-commands","text":"The loki-wallet-cli has multiple commands to conduct different operations on the Loki Blockchain. By typing help and clicking enter after loading your wallet will bring up the commands that can be used.","title":"Displaying commands"},{"location":"Wallets/CliWallet/WalletCommands/#1-accounts","text":"","title":"1 Accounts"},{"location":"Wallets/CliWallet/WalletCommands/#11-creating-new-account","text":"When a wallet is generated it will automatically have an account labelled Primary account with index 0 . If at any time you wish to create an additional account use the command: account new <label text with white spaces allowed> This command will create a subaddress which is labelled with a tag and index number. This subaddress will share the same seed as your Primary address. To ensure this new account is displayed you must type exit to save your session. You will note that there is now an asterisk to the left of index 1. The asterisks show us the account in which the commands we run will apply to. Note: Restoring your wallet from your seed will not restore your accounts as the index of your subaddress data is stored on your computer within your wallet file. All the funds stored in your additional accounts will be shown in your Primary account if you need to restore your wallet from scratch. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000","title":"1.1 Creating new account"},{"location":"Wallets/CliWallet/WalletCommands/#12-switching-account","text":"When transferring out or receiving to a specific account we need to make sure that the account we are performing the action is the one the CLI is currently connected to. An asterisk will show which account we are connected to. In the below example the asterisk is shown to the left of Secondary account so any operations will be associated with that account. Each of the accounts connected to your Primary address will have an index associated with them. The index number will be shown to the left of the Account column. By default, index \u201c0\u201d is your Primary account. [wallet L9LnR2]: account new Secondary account [wallet L9LnR2]: Untagged accounts: [wallet L9LnR2]: Account Balance Unlocked balance Label [wallet L9LnR2]: 0 L9LnR2 0.000000000 0.000000000 Primary account [wallet L9LnR2]: * 1 LY5J5W 0.000000000 0.000000000 Secondary account [wallet L9LnR2]: ---------------------------------------------------------------------------------- [wallet L9LnR2]: Total 0.000000000 0.000000000 To switch between the accounts you have created run the command: account switch <index> After running the command a similar output shown below will be on your terminal. [wallet L9LnR2]: account switch 0 [wallet L9LnR2]: Currently selected account: [0] Primary account [wallet L9LnR2]: Tag: (No tag assigned) [wallet L9LnR2]: Balance: 0.000000000, unlocked balance: 0.000000000","title":"1.2 Switching account"},{"location":"Wallets/CliWallet/WalletCommands/#13-changing-account-labels","text":"To change the label name connected to a specific Loki Primary or Sub-address use the command: account label <index> <label text with white spaces allowed> Replacing <index> with the index number associated with the account you wish to relabel, and replacing <label text with white spaces allowed> with the new label you would like to name the specified account. Below shows the current accounts and labels for a specific wallet. [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 Primary account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000 Using the command account label 0 My Account we have changed the label connected to our Primary address from \u201cPrimary account\u201d to \u201cMy Account\u201d. [wallet LCmjSH]: account label 0 My Account [wallet LCmjSH]: Untagged accounts: [wallet LCmjSH]: Account Balance Unlocked balance Label [wallet LCmjSH]: * 0 LCmjSH 0.000000000 0.000000000 My Account [wallet LCmjSH]: 1 LTLgNy 0.000000000 0.000000000 Secondary [wallet LCmjSH]: ---------------------------------------------------------------------------------- [wallet LCmjSH]: Total 0.000000000 0.000000000","title":"1.3 Changing account labels"},{"location":"Wallets/CliWallet/WalletCommands/#14-tagging-and-untagging-accounts","text":"The loki-wallet-cli allows you to group accounts by tagging or untagging them. Below shows a wallet with 4 accounts, Dog, Kid 1 and Kid 2. [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 We can tag a single account with the following command: account tag <tag_name> <account_index> [wallet LVP3bv]: account tag Pets 1 [wallet LVP3bv]: Accounts with tag: Pets [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 When needing to perform multiple tags we can do it through one command: account tag <tag_name> <account_index_1> [<account_index_2> ...] [wallet LVP3bv]: account tag Family 2 3 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 Similarly we can untag accounts by running the following command: account untag <account_index_1> [<account_index_2> ...] Using the above exampled wallet we will remove our \u201cDog\u201d account from \u201cPets\u201d. [wallet LVP3bv]: account untag 1 [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000 [wallet LVP3bv]: [wallet LVP3bv]: Untagged accounts: [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 0 LAXk6e 0.000000000 0.000000000 My Account [wallet LVP3bv]: 1 LRDvY6 0.000000000 0.000000000 Dog [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000","title":"1.4 Tagging and untagging accounts:"},{"location":"Wallets/CliWallet/WalletCommands/#15-adding-tag-descriptions","text":"If you require additional information attached to a specific tag you can add a description with the following command: account tag_description <tag_name> <description> For example: [wallet LVP3bv]: account tag_description Family This is my family. [wallet LVP3bv]: Accounts with tag: Family [wallet LVP3bv]: Tag's description: This is my family. [wallet LVP3bv]: Account Balance Unlocked balance Label [wallet LVP3bv]: 2 LVJDwN 0.000000000 0.000000000 Kid 1 [wallet LVP3bv]: * 3 LVP3bv 0.000000000 0.000000000 Kid 2 [wallet LVP3bv]: ---------------------------------------------------------------------------------- [wallet LVP3bv]: Total 0.000000000 0.000000000","title":"1.5 Adding Tag descriptions"},{"location":"Wallets/CliWallet/WalletCommands/#2-balance","text":"To check the balance of your wallet you can run one of two commands: balance balance detail Running the command balance will generated a simple output showing your balance and unlocked balance of the specific account you are in. For example: [wallet T6TmZX]: balance Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 While running the command balance detail will generate a more detailed output, showing the account number, first few characters of the address, balance, unlocked balance, Outputs and the Label of the account. For example: [wallet T6TmZX]: balance detail Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 172286.035054991, unlocked balance: 172086.338373771 Balance per address: Address Balance Unlocked balance Outputs Label 0 T6TmZX 172286.035054991 172086.338373771 3347 Primary account There are other commands that will also output the balance which have been covered by this guide, such as the account command.","title":"2 Balance"},{"location":"Wallets/CliWallet/WalletCommands/#3-getting-the-block-height","text":"To show the blockchain height run the command: bc_height","title":"3 Getting the Block Height"},{"location":"Wallets/CliWallet/WalletCommands/#4-blackballing-transactions","text":"Blackballing transactions allows you to ignore others' outputs (containers of money) that are known to be spent in a certain transaction. For example let\u2019s imagine that txid: 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 is known to be fake and if this txid is seen within a RingCT transaction the network can assume it is fake, therefore an actor has a better chance of deducing the real transaction within the RingCT. By blackballing the above txid we remove the chance of it being used within our RingCT. To do this we will use the following command: blackball <output public key> | <filename> [add] For example: [wallet LAXk6e]: blackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 To check if the txid was added to our list of txids not to use we can use the following command: blackballed <output public key> If the txid is on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: Blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> Alternatively if the txid is not on our list the following will output: [wallet LAXk6e]: blackballed 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542 [wallet LAXk6e]: not blackballed: <4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542> To unblackball a txid use the following command: unblackball <output public key> For example: [wallet LAXk6e]: unblackball 4f4b371a0da8858bbeab8a40ff37de1f6ff33e64a616e5ced8239062570b7542","title":"4 Blackballing Transactions"},{"location":"Wallets/CliWallet/WalletCommands/#5-reserve-proof","text":"Reserve Proofs are used to generate a signature proving that you own an amount of Loki, with the option to sign the reserve proof with a key. For example let\u2019s imagine you see a car for sale but they will accept Loki as payment, however they have advised in their online listing that they are only interested in serious buyers and require you to prove you have the Loki within your initial contact. Luckily we can use the Reserve Proof commands for this proof.","title":"5 Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#51-generate-reserve-proof","text":"To begin we will need to run the get_reserve_proof command to generate our proof. get_reserve_proof (all|<amount>) [<message>] If the individual you are sending this proof to requires you to prove you have 1000 Loki you will need to replace the section (all|<amount>) with a 1000, otherwise replace it with the amount you need to prove you have reserved. If you want to put an extra layer of encryption over the file replace [<message>] with a password. Your command will similar to the below command: get_reserve_proof 1000 Car The Cli will request your wallet password and once your password is entered it will tell you it generated a signature file. [wallet T6TmZX]: get_reserve_proof 1000 Car Wallet password: signature file saved to: loki_reserve_proof This signature file loki_reserve_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_reserve_proof command it will overwrite your loki_reserve_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_reserve_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_reserve_proof https://transfer.sh/loki_reserve_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. https://transfer.sh/QhoC7/loki_reserve_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_reserve_proof file through the transfer.sh link. The loki address you are proving has Loki in it. The <message> if you encrypted the file.","title":"5.1 Generate Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#52-checking-reserve-proof","text":"To check a reserve proof we need to first have the loki_reserve_proof file in our Loki folder. If you do not have the loki_reserve_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_reserve_proof you can use the following command to download it. curl <link> -o loki_reserve_proof Replacing <link> with the link to download the loki_reserve_proof . Now that the loki_reserve_proof is in our folder we can run the following command: check_reserve_proof <address> <signature_file> [<message>] Where <address> is the address of the wallet where the command get_reserve_proof was ran. <signiture_file> is the file that was received from the individual sending you the reserve proof, normally generated as loki_reserve_proof and <message> is the key set by the individual who sent you the reserve proof. Therefor for the previous example where we created a reserve proof for 1000 loki and signed with \u201ccar\u201d, we would run the command: check_reserve_proof T6TmZX8EzZVjS9zNg7zAsrEQFDgcVC2qV2ZMyoWsbyK4SNB2SwMHZtMhPSsFyTmRBQUaGVF5k3qy5CMFM6Lvj7gi3AeszDag7 loki_reserve_proof Car If all goes well, the terminal will output the following: Good signature -- total: 1014.862440831, spent: 0.000000000, unspent: 1014.862440831 You may note that it shows a reserve proof which is greater than 1000, this is because the command is adding up all the transactions into the address specified until it is greater than the reserve proof set.","title":"5.2 Checking Reserve Proof"},{"location":"Wallets/CliWallet/WalletCommands/#6-spend-proof","text":"Spend Proofs are used to generate a signature proving that you generated a TXID, with the option to sign the spend proof with a key. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_spend_proof command.","title":"6 Spend Proof:"},{"location":"Wallets/CliWallet/WalletCommands/#61-generate-spend-proof","text":"To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_spend_proof command to generate our proof. get_spend_proof <txid> [<message>] Replacing <txid> with the txid of our transfer out and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_spend_proof This signature file loki_spend_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_spend_proof command it will overwrite your loki_spend_proof file . You will want to send this file to the person who requires the proof. You can upload the loki_spend_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_spend_proof https://transfer.sh/loki_spend_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_spend_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_spend_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The <message> if you encrypted the file.","title":"6.1 Generate Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#62-checking-spend-proof","text":"To check a spend proof we need to first have the loki_spend_proof file in our Loki folder and the txid associated with the transaction being proved. If you do not have the loki_spend_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_spend_proof you can use the following command to download it. curl <link> -o loki_spend_proof Replacing <link> with the link to download the loki_spend_proof . Now that the loki_spend_proof is in our folder we can run the following command: check_spend_proof <txid> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved. <signiture_file> is the file that was received from the individual sending you the spend proof, normally generated as loki_spend_proof and <message> is the key set by the individual who sent you the spend proof. An example would look like the following command check_spend_proof 20eb3b5545d6587e5a379feb2fc69b43d4f8b6b825bb7eff78e263d4e7e8eaa9 loki_spend_proof car If all goes well, the terminal will output the following: Good signature If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file.","title":"6.2 Checking Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#7-tx-proof","text":"TX Proofs are used to generate a signature file proving that you generated a TXID, with the option to sign the spend proof with a key. TX proofs work similar to Reserve Proof\u2019s and Spend Proofs however they show more detailed information. For example let\u2019s imagine you have bought a car from a dealership with loki and have sent 1000 loki to the seller. Unfortunately the dealer does not know which transaction is yours as he has received 5 transactions of 1000 loki in the same block for 5 different cars. He knows the txid\u2019s but wants you to prove that you have generate one of the txid\u2019s in his list. Luckily we can prove we generated the txid by using the get_tx_proof command.","title":"7 TX Proof:"},{"location":"Wallets/CliWallet/WalletCommands/#71-generate-spend-proof","text":"To begin we will first need to find the txid associated with our transaction. To do this run the following command in our wallet: show_transfers The terminal will output a list of transactions in and out of your address. You should have a transaction in your list with the amount you spent to the dealership. Copy the txid(by highlighting) associated with this transaction and save it in a notepad for later. We can now run the get_tx_proof command to generate our proof. get_tx_proof <txid> <address> [<message>] Replacing <txid> with the txid of our transfer out, <address> with the receiver's address, and replacing <message> if we want to add a password to the proof. If all went well the terminal will output the following text: signature file saved to: loki_tx_proof This signature file loki_tx_proof will be saved in your Loki folder, where your daemon and wallet keys are. Keep in mind every time you run the get_tx_proof command it will overwrite your loki_tx_proof file. You will want to send this file to the person who requires the proof. You can upload the loki_tx_proof file through https://transfer.sh/ by running the command within the folder of your signature file: curl --upload-file ./loki_tx_proof https://transfer.sh/loki_tx_proof The terminal will then print out a link to your signature file which you can then provide to the individual performing the check. For example: https://transfer.sh/QhoC7/loki_tx_proof Make sure you provide the following to the individual who will be checking your reserve proof: The loki_tx_proof file through the transfer.sh link. The loki transaction txid associated with the transaction you are proving you generated. The receivers loki address. The <message> if you encrypted the file.","title":"7.1 Generate Spend Proof"},{"location":"Wallets/CliWallet/WalletCommands/#72-checking-tx-proof","text":"To check a tx proof we need to first have the loki_tx_proof file in our Loki folder, the receiver's address and the txid associated with the transaction being proved. If you do not have the loki_tx_proof file in your loki folder request the individual sending the file to you to use https://transfer.sh/ , once they send you the link to their loki_tx_proof you can use the following command to download it. curl <link> -o loki_tx_proof Replacing <link> with the link to download the loki_tx_proof . Now that the loki_tx_proof is in our folder we can run the following command: check_tx_proof <txid> <address> <signature_file> [<message>] Where <txid> is the txid associated with the transaction that is being proved, <address> is the receiver\u2019s address and <signiture_file> is the file that was received from the individual sending you the tx proof, normally generated as loki_tx_proof and <message> is the key set by the individual who sent you the tx proof. An example would look like the following command: check_tx_proof 3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044 TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc loki_tx_proof If all goes well, the terminal will output the following: Good signature TRrEpWMLd3rRuirYqsjg1iaNsukAAojWjFDhJ2kK2o4uM6tkcjMerA4SZNat6QHEYe1SoGCFQddVPgRqmkA8kARX1ffU1Wcjc received 40000.000000 in txid <3f8c62b4d83100ff4f89b44a96350e65aeaa83a9b4273c31f94b9aa12e713044> This transaction has 1 confirmations If you receive a Good signature message that should be a good proof that the txid you are checking was generated from the sender. Keep in mind however that this can potentially not always be the case, considering someone could get access to someone else's computer thus having access to this file.","title":"7.2 Checking tx Proof"},{"location":"Wallets/CliWallet/WalletCommands/#8-tx-key","text":"A TX key is a private key associated with a TXid. Only the wallet that has sent the transaction can generate a TX key from the TXID that both parties can see. A TX key can be used to validate a transaction on a case by case basis. In essence, you can provide the tx key, txid and the receiver address to someone to prove you had generate that transaction.","title":"8 TX key:"},{"location":"Wallets/CliWallet/WalletCommands/#81-view-tx-key","text":"To view the TX key of a specific transaction you have generate you will need to run the command: get_tx_key <txid> Where <txid> is the transaction id associated with the transfer out you are proving is yours. The terminal will prompt the user for the wallets password and then print out the tx key, which will look similar to: [wallet T6TmZX]: get_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f Wallet password: Tx key: 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e Provide the <tx key> with the <txid> and <receiving address> to the individual who will run the validation, thus this will prove you generated the transaction.","title":"8.1 View TX key"},{"location":"Wallets/CliWallet/WalletCommands/#82-validate-transaction-with-tx-key","text":"Once we have a <tx key> , <txid> and <receiving address> from a specific transaction we can use the following command to prove they are all associated: check_tx_key <txid> <txkey> <address> For the previous example we would run the following command from any loki wallet: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 The terminal will show text of how much Loki the address received. It will also show how many confirmations the transaction has received from the blockchain. For example: [wallet T6TZ2V]: check_tx_key d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f 5dfc4d677e2707317f306219b6aa445feaab4c652927237c012f7e72cb41bf0e T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 T6TZ2VaG1p9PQkDgdVCYwnjoxYSU7ErXX56etGsqHLugAGqynFwBvP4dnN7wvYCcJfMa9LPgtYu8UEUqyc4xsxmx2ZTyMp4U3 received 10000.000000000 in txid <d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f> This transaction has 10 confirmations","title":"8.2 Validate transaction with TX key"},{"location":"Wallets/CliWallet/WalletCommands/#9-tx-notes","text":"The loki-wallet-cli allows you to add notes to specific txid\u2019s, however this note does not get stored on the blockchain, rather it is stored on client side, on the device that generates the tx_note .","title":"9 Tx Notes"},{"location":"Wallets/CliWallet/WalletCommands/#91-set-tx-note","text":"To set a tx note we will need a the <txid> and the <message> you want to add to the txid. For instance, if you want to add a note to a txid that is connected to your wallet run the following command to show your transactions in/out with their <txid> \u2019s: show_transfers To set the note to the <txid> run the following command: set_tx_note <txid> [free text note] Where <txid> is the transaction id associated to the transaction you are adding the [free text note] too. Your command will look similar to the following example: [wallet T6TmZX]: set_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f This is a tx note example.","title":"9.1 Set tx note"},{"location":"Wallets/CliWallet/WalletCommands/#92-view-tx-note","text":"To view a note connected to a txid run the following command: get_tx_note <txid> Where <txid> is the transaction id that has the note connected to it. For example, if we run the command on the previous <txid> mentioned, the terminal will display the following text: [wallet T6TmZX]: get_tx_note d5fb415aad43f4e45bc72566d5ad4c8f12629db1f924d953efc2521c137a987f note found: This is a tx note example. You can also view a tx note by running the show_transfers command, each transaction that has a note connected to it will display the text to the right of each transfer.","title":"9.2 View tx note"},{"location":"Wallets/CliWallet/WalletCommands/#10-changing-wallet-password","text":"Changing the wallet password is only client side(locally), and if the password is forgotten the wallet can always be restored with the mnemonic seed. If you know the password to the wallet and want to change it you can run the following command: password Once the command has been run the terminal will prompt you for the current password and the new password twice. If entered correctly the terminal will go back to receiving inputs, otherwise the terminal will output an error such as Passwords do not match! Please try again or Error: invalid password .","title":"10 Changing wallet password"},{"location":"Wallets/CliWallet/WalletCommands/#11-encrypting-seed-phrase","text":"Your seed passphrase is a 25 word phrase which is used to recover access to your wallet on a client or gui and is. The command encrypted_seed allows your to add an additional password, or encryption layer, to your 25 word mnemonic seed. Encrypting your seed will stop others from recovering access to your wallet if they somehow gain access to your 25 word mnemonic seed as they will not have the passphrase that decrypts them. This means, your passphrase should not be written or saved in the same location as your encrypted 25 word mnemonic seed phrase. To encrypt your seed run the following command: encrypted_seed Initially the cli wallet will prompt you to enter your wallet password. Next it will request for your seed encryption passphrase, enter in your desired password/passphrase once, click enter, then type the passphrase in again. The wallet will output your mnemonic seed which is a 25 word passphrase. It is generally best practice to write these 25 words down and store them somewhere safe and securely, write your passphrase down(which is the phrase you used to encrypt the 25 words) and store this somewhere else. Storing the 25 words with the passphrase in a file on your computer that is not encrypted is giving others easier access to your mnemonic seed.","title":"11 Encrypting seed phrase"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/","text":"loki-wallet-cli Mac Setup \u00b6 The loki-wallet-cli is the \u201cCommand Line Interface\u201d wallet software that is used to run Loki accounts through command prompt or terminal. The CLI wallet only uses text to do operations, where the oki-wallet-gui wallet offers a graphical user interface with buttons to do most of the operations the loki-wallet-cli does. If you are new to console or terminal commands and/or would prefer a wallet with buttons and Loki branding we would suggest you download the latest loki-wallet-gui release from here and follow the guide found here to get started. Bear in mind that the CLI wallet, while harder to use, is generally faster and more reliable. If you are still interested in the 'Loki-wallet-cli' you can find it here . Download the latest release for your specified Operating System, for this user guide we are going to assume you are running the latest MAC OS and have XCode installed. Step 1: Opening loki-wallet-cli and lokid. \u00b6 To use the loki-wallet-cli we must first have the daemon, lokid , up and running. The lokid is your node which the loki-wallet-cli broadcasts through. Without the node running the loki-wallet-cli will not be able to operate. Open up the lokid file in the folder you extracted the release from. In most cases you will have the following security dialog box pop up. If the dialog box opens up you will need to allow the lokid to open by moving your cursor to the top-left of your screen, clicking the apple logo, and then clicking on system preferences. Once in system preferences click on the Security & Privacy button, check in this new screen that the lokid file was blocked, if it was you should be confident to click \u201cOpen Anyway\u201d. Keep clicking open and allow to give the software permission to run. Once the software has permission a terminal window should pop up and say the following text: ********************************************************************** The daemon will start synchronizing with the network. This may take a long time to complete. You can set the level of process detailization through \"set_log <level|categories>\" command, where <level> is between 0 (no details) and 4 (very verbose), or custom category based levels (eg, *:WARNING). Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. ********************************************************************** Let the daemon run until the node is completely synced, you will know the node is synced once the terminal outputs the following text: ********************************************************************** You are now synchronized with the network. You may now start loki-wallet-cli. Use the \"help\" command to see the list of available commands. ********************************************************************** Now the daemon is synced we can run the loki-wallet-cli file. Step 2: Setting up your loki-wallet-cli account. \u00b6 If this is your first time opening the loki-wallet-cli it will request for you to specify a wallet name. For the purposes of this user guide we will use the example name MyWallet Specify wallet file name (e.g., MyWallet). If the wallet doesn't exist, it will be created. Wallet file name (or Ctrl-C to quit): MyWallet Because this is the first time we have used the name MyWallet the following text will appear in our terminal. Type in Y or Yes to confirm your wallet name. No wallet found with that name. Confirm creation of new wallet named: MyWallet (Y/Yes/N/No): Yes The loki-wallet-cli has now generated us a wallet called MyWallet and is now prompting us for a password for our generated wallet. Please note: when typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character your clicking including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Generating new wallet... Enter a new password for the wallet: Confirm password: Now once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing 1 and clicking enter. List of available languages for your wallet's seed: If your display freezes, exit blind with ^C, then run again with --use-english-language-names 0 : Deutsch 1 : English 2 : Espa\u00f1ol 3 : Fran\u00e7ais 4 : Italiano 5 : Nederlands 6 : Portugu\u00eas 7 : \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a 8 : \u65e5\u672c\u8a9e 9 : \u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd) 10 : Esperanto 11 : Lojban Enter the number corresponding to the language of your choice: 1 The loki-wallet-cli will generate and spit out several lines of text. Some of the information that was outputted will only ever show once, therefore it is very important to do this next section properly otherwise we may lose access to our account, thus losing access to our funds. Let\u2019s take a close look at each section of the newly generated wallet: The text after Generated new wallet shows your public address. This address can be shared and will be used to receive Loki to your wallet. All Loki public addresses start with an L.... and are followed with a string of characters. The public address shown will be your primary address however multiple public addresses can be generated from this primary address. You do not need to write down the public address, the command address will re-display it whenever required. Generated new wallet: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 The View key address is not to be shared unless you want to show the transactions received to the public address connected to this wallet. You do not need to write down the view key as it can be re-displayed with the command viewkey . View key: 97d3c27e20818e5e23a6548458b50d4f128a2709c55eb7f9518d0e957a5d2e0d The next few lines of text show how to navigate the loki-wallet-client . This user guide will look into more detail the commands that can be used within the loki-wallet-client further in the guide. Your wallet has been generated! To start synchronizing with the daemon, use the \"refresh\" command. Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. Always use the \"exit\" command when closing loki-wallet-cli to save your current session's state. Otherwise, you might need to synchronize your wallet again (your wallet keys are NOT at risk in any case). The next section with the random 25 words is your mnemonic seed. The seed is used to easily back-up and restore your wallet without needing any other information. At this stage, grab a pen and paper and write down your 25 words in order(having these words out of order will not restore your wallet) and store the piece of paper in a safe and secure place. If your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your account. NOTE: the following 25 words can be used to recover access to your wallet. Write them down and store them somewhere safe and secure. Please do not store them in your email or on file storage services outside of your immediate control. ponies innocent oyster whale autumn knapsack jostle elapse inroads joining doorway ticket drying obnoxious algebra tutor biplane sack alpine zinger huge duets refer rigid inroads The last of the outputs are the account balance, because your wallet does not have any Loki in it currently the balance is showing 0. Once we receive a transaction of Loki into our wallet the balance will appear as soon as the transaction is confirmed in one block (usually less than 2 minutes). Once the transaction has been confirmed over 10 blocks the balance will show in unlocked balance. The unlocked balance is the Loki available to be spent/sent to other addresses. Starting refresh... Refresh done, blocks received: 0 Untagged accounts: Account Balance Unlocked balance Label * 0 LAXk6e 0.000000000 0.000000000 Primary account ---------------------------------------------------------------------------------- Total 0.000000000 0.000000000 Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 0.000000000, unlocked balance: 0.000000000 Background refresh thread started\u201d","title":"CLI Mac Setup"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#loki-wallet-cli-mac-setup","text":"The loki-wallet-cli is the \u201cCommand Line Interface\u201d wallet software that is used to run Loki accounts through command prompt or terminal. The CLI wallet only uses text to do operations, where the oki-wallet-gui wallet offers a graphical user interface with buttons to do most of the operations the loki-wallet-cli does. If you are new to console or terminal commands and/or would prefer a wallet with buttons and Loki branding we would suggest you download the latest loki-wallet-gui release from here and follow the guide found here to get started. Bear in mind that the CLI wallet, while harder to use, is generally faster and more reliable. If you are still interested in the 'Loki-wallet-cli' you can find it here . Download the latest release for your specified Operating System, for this user guide we are going to assume you are running the latest MAC OS and have XCode installed.","title":"loki-wallet-cli Mac Setup"},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#step-1-opening-loki-wallet-cli-and-lokid","text":"To use the loki-wallet-cli we must first have the daemon, lokid , up and running. The lokid is your node which the loki-wallet-cli broadcasts through. Without the node running the loki-wallet-cli will not be able to operate. Open up the lokid file in the folder you extracted the release from. In most cases you will have the following security dialog box pop up. If the dialog box opens up you will need to allow the lokid to open by moving your cursor to the top-left of your screen, clicking the apple logo, and then clicking on system preferences. Once in system preferences click on the Security & Privacy button, check in this new screen that the lokid file was blocked, if it was you should be confident to click \u201cOpen Anyway\u201d. Keep clicking open and allow to give the software permission to run. Once the software has permission a terminal window should pop up and say the following text: ********************************************************************** The daemon will start synchronizing with the network. This may take a long time to complete. You can set the level of process detailization through \"set_log <level|categories>\" command, where <level> is between 0 (no details) and 4 (very verbose), or custom category based levels (eg, *:WARNING). Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. ********************************************************************** Let the daemon run until the node is completely synced, you will know the node is synced once the terminal outputs the following text: ********************************************************************** You are now synchronized with the network. You may now start loki-wallet-cli. Use the \"help\" command to see the list of available commands. ********************************************************************** Now the daemon is synced we can run the loki-wallet-cli file.","title":"Step 1: Opening loki-wallet-cli and lokid."},{"location":"Wallets/CliWallet/loki-wallet-cliMacSetup/#step-2-setting-up-your-loki-wallet-cli-account","text":"If this is your first time opening the loki-wallet-cli it will request for you to specify a wallet name. For the purposes of this user guide we will use the example name MyWallet Specify wallet file name (e.g., MyWallet). If the wallet doesn't exist, it will be created. Wallet file name (or Ctrl-C to quit): MyWallet Because this is the first time we have used the name MyWallet the following text will appear in our terminal. Type in Y or Yes to confirm your wallet name. No wallet found with that name. Confirm creation of new wallet named: MyWallet (Y/Yes/N/No): Yes The loki-wallet-cli has now generated us a wallet called MyWallet and is now prompting us for a password for our generated wallet. Please note: when typing the password, the characters will not appear. It will seem as if you are typing and no text is appearing however the terminal is logging every character your clicking including if it is capitalised or lowercase. Write down your wallet name and password on a piece of paper as this information will be required every time we want to enter our wallet. Use a password with uppercase letters, lowercase letters, numbers, symbols and make the password at least 9 characters long. Generating new wallet... Enter a new password for the wallet: Confirm password: Now once we have chosen our password for the wallet we must choose our language. For the purposes of this user guide I suggest you use English by typing 1 and clicking enter. List of available languages for your wallet's seed: If your display freezes, exit blind with ^C, then run again with --use-english-language-names 0 : Deutsch 1 : English 2 : Espa\u00f1ol 3 : Fran\u00e7ais 4 : Italiano 5 : Nederlands 6 : Portugu\u00eas 7 : \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a 8 : \u65e5\u672c\u8a9e 9 : \u7b80\u4f53\u4e2d\u6587 (\u4e2d\u56fd) 10 : Esperanto 11 : Lojban Enter the number corresponding to the language of your choice: 1 The loki-wallet-cli will generate and spit out several lines of text. Some of the information that was outputted will only ever show once, therefore it is very important to do this next section properly otherwise we may lose access to our account, thus losing access to our funds. Let\u2019s take a close look at each section of the newly generated wallet: The text after Generated new wallet shows your public address. This address can be shared and will be used to receive Loki to your wallet. All Loki public addresses start with an L.... and are followed with a string of characters. The public address shown will be your primary address however multiple public addresses can be generated from this primary address. You do not need to write down the public address, the command address will re-display it whenever required. Generated new wallet: LAXk6eS3Ng98QxDTdC47eNdfCXttJycKraXxfsw9cMVngGUqP3kiSE6cwXoApU6gjzSXVX1ASAPAi1MSXA935XUs1MWEcv9 The View key address is not to be shared unless you want to show the transactions received to the public address connected to this wallet. You do not need to write down the view key as it can be re-displayed with the command viewkey . View key: 97d3c27e20818e5e23a6548458b50d4f128a2709c55eb7f9518d0e957a5d2e0d The next few lines of text show how to navigate the loki-wallet-client . This user guide will look into more detail the commands that can be used within the loki-wallet-client further in the guide. Your wallet has been generated! To start synchronizing with the daemon, use the \"refresh\" command. Use the \"help\" command to see the list of available commands. Use \"help <command>\" to see a command's documentation. Always use the \"exit\" command when closing loki-wallet-cli to save your current session's state. Otherwise, you might need to synchronize your wallet again (your wallet keys are NOT at risk in any case). The next section with the random 25 words is your mnemonic seed. The seed is used to easily back-up and restore your wallet without needing any other information. At this stage, grab a pen and paper and write down your 25 words in order(having these words out of order will not restore your wallet) and store the piece of paper in a safe and secure place. If your words are stored in a text file on your computer or stored online, you increase your risk of someone else getting control of your account. NOTE: the following 25 words can be used to recover access to your wallet. Write them down and store them somewhere safe and secure. Please do not store them in your email or on file storage services outside of your immediate control. ponies innocent oyster whale autumn knapsack jostle elapse inroads joining doorway ticket drying obnoxious algebra tutor biplane sack alpine zinger huge duets refer rigid inroads The last of the outputs are the account balance, because your wallet does not have any Loki in it currently the balance is showing 0. Once we receive a transaction of Loki into our wallet the balance will appear as soon as the transaction is confirmed in one block (usually less than 2 minutes). Once the transaction has been confirmed over 10 blocks the balance will show in unlocked balance. The unlocked balance is the Loki available to be spent/sent to other addresses. Starting refresh... Refresh done, blocks received: 0 Untagged accounts: Account Balance Unlocked balance Label * 0 LAXk6e 0.000000000 0.000000000 Primary account ---------------------------------------------------------------------------------- Total 0.000000000 0.000000000 Currently selected account: [0] Primary account Tag: (No tag assigned) Balance: 0.000000000, unlocked balance: 0.000000000 Background refresh thread started\u201d","title":"Step 2: Setting up your loki-wallet-cli account."},{"location":"Wallets/GuiWallet/GUIOverview/","text":"","title":"GUI Overview"},{"location":"Wallets/GuiWallet/Guides/","text":"","title":"Guides"},{"location":"Wallets/MobileWallet/Guides/","text":"TO DO","title":"Android Wallet Guide"},{"location":"Wallets/MobileWallet/MobileWalletOverview/","text":"TO DO","title":"Mobile Wallet Overview"},{"location":"Wallets/WebWallet/Guides/","text":"TO DO","title":"Guides"},{"location":"Wallets/WebWallet/WebWalletOverview/","text":"TO DO","title":"WW Overview"}]}